{
  "functions": {
    "empirica.cli.cli_utils.print_component_status": {
      "name": "print_component_status",
      "module": "empirica.cli.cli_utils",
      "params": [
        "component_name",
        "status",
        "details"
      ],
      "returns": "",
      "docstring": "Print standardized component status information",
      "decorators": [],
      "calls": [
        "get",
        "lower",
        "print"
      ],
      "line_number": 10
    },
    "empirica.cli.cli_utils.format_uncertainty_output": {
      "name": "format_uncertainty_output",
      "module": "empirica.cli.cli_utils",
      "params": [
        "uncertainty_scores",
        "verbose"
      ],
      "returns": "str",
      "docstring": "Format uncertainty scores for display",
      "decorators": [],
      "calls": [
        "append",
        "items",
        "sorted",
        "join"
      ],
      "line_number": 25
    },
    "empirica.cli.cli_utils.handle_cli_error": {
      "name": "handle_cli_error",
      "module": "empirica.cli.cli_utils",
      "params": [
        "error",
        "command",
        "verbose"
      ],
      "returns": "None",
      "docstring": "Standardized error handling for CLI commands",
      "decorators": [],
      "calls": [
        "format_exc",
        "print"
      ],
      "line_number": 45
    },
    "empirica.cli.cli_utils.parse_json_safely": {
      "name": "parse_json_safely",
      "module": "empirica.cli.cli_utils",
      "params": [
        "json_string",
        "default"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Safely parse JSON string with fallback",
      "decorators": [],
      "calls": [
        "print",
        "loads"
      ],
      "line_number": 55
    },
    "empirica.cli.cli_utils.format_execution_time": {
      "name": "format_execution_time",
      "module": "empirica.cli.cli_utils",
      "params": [
        "start_time",
        "end_time"
      ],
      "returns": "str",
      "docstring": "Format execution time for display",
      "decorators": [],
      "calls": [
        "time"
      ],
      "line_number": 67
    },
    "empirica.cli.cli_utils.validate_confidence_threshold": {
      "name": "validate_confidence_threshold",
      "module": "empirica.cli.cli_utils",
      "params": [
        "threshold"
      ],
      "returns": "bool",
      "docstring": "Validate confidence threshold is in valid range",
      "decorators": [],
      "calls": [],
      "line_number": 82
    },
    "empirica.cli.cli_utils.print_header": {
      "name": "print_header",
      "module": "empirica.cli.cli_utils",
      "params": [
        "title",
        "emoji"
      ],
      "returns": "None",
      "docstring": "Print a formatted header for CLI sections",
      "decorators": [],
      "calls": [
        "len",
        "print"
      ],
      "line_number": 87
    },
    "empirica.cli.cli_utils.print_separator": {
      "name": "print_separator",
      "module": "empirica.cli.cli_utils",
      "params": [
        "char",
        "length"
      ],
      "returns": "None",
      "docstring": "Print a separator line",
      "decorators": [],
      "calls": [
        "print"
      ],
      "line_number": 93
    },
    "empirica.cli.cli_utils.format_component_list": {
      "name": "format_component_list",
      "module": "empirica.cli.cli_utils",
      "params": [
        "components",
        "show_details"
      ],
      "returns": "str",
      "docstring": "Format component list for display",
      "decorators": [],
      "calls": [
        "join",
        "append",
        "len",
        "get",
        "sum"
      ],
      "line_number": 98
    },
    "empirica.cli.uvl_formatter.get_confidence_color": {
      "name": "get_confidence_color",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "confidence"
      ],
      "returns": "str",
      "docstring": "Map confidence score to UVL color code",
      "decorators": [],
      "calls": [],
      "line_number": 33
    },
    "empirica.cli.uvl_formatter.get_agent_emoji": {
      "name": "get_agent_emoji",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "provider"
      ],
      "returns": "str",
      "docstring": "Get emoji for AI agent/provider",
      "decorators": [],
      "calls": [
        "get",
        "lower"
      ],
      "line_number": 43
    },
    "empirica.cli.uvl_formatter.detect_state_modifier": {
      "name": "detect_state_modifier",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "adapter_response"
      ],
      "returns": "str",
      "docstring": "Detect agent state from response metadata",
      "decorators": [],
      "calls": [
        "hasattr",
        "get",
        "lower",
        "any"
      ],
      "line_number": 48
    },
    "empirica.cli.uvl_formatter.format_uvl_response": {
      "name": "format_uvl_response",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "content",
        "adapter_response",
        "show_vectors"
      ],
      "returns": "str",
      "docstring": "Format AI response with UVL visual indicators.\n\nArgs:\n    content: The response text\n    adapter_response: AdapterResponse object with metadata\n    show_vectors: Whether to show epistemic vectors\n\nRet",
      "decorators": [],
      "calls": [
        "detect_state_modifier",
        "get_confidence_color",
        "run",
        "get_agent_emoji",
        "strip",
        "rstrip",
        "any",
        "get"
      ],
      "line_number": 69
    },
    "empirica.cli.uvl_formatter.format_routing_decision": {
      "name": "format_routing_decision",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "task",
        "strategy",
        "selected_adapter",
        "candidates",
        "verbose"
      ],
      "returns": "str",
      "docstring": "Format routing decision with UVL transparency.\n\nArgs:\n    task: The user's query/task\n    strategy: Routing strategy used\n    selected_adapter: Which adapter was selected\n    candidates: Dict of adapt",
      "decorators": [],
      "calls": [
        "title",
        "int",
        "items",
        "sorted",
        "len",
        "ljust",
        "get_agent_emoji"
      ],
      "line_number": 149
    },
    "empirica.cli.uvl_formatter.format_epistemic_delta": {
      "name": "format_epistemic_delta",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "preflight_vectors",
        "postflight_vectors"
      ],
      "returns": "str",
      "docstring": "Format epistemic delta (learning) in UVL format.\n\nShows how epistemic state changed during interaction.",
      "decorators": [],
      "calls": [
        "get",
        "abs",
        "upper"
      ],
      "line_number": 196
    },
    "empirica.cli.uvl_formatter.format_uvl_stream_message": {
      "name": "format_uvl_stream_message",
      "module": "empirica.cli.uvl_formatter",
      "params": [
        "event_type",
        "agent_id",
        "content",
        "adapter_response",
        "session_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Format message for UVL stream protocol (for visualization layer).\n\nReturns structured JSON that can be consumed by visualization AIs.",
      "decorators": [],
      "calls": [
        "detect_state_modifier",
        "isoformat",
        "get_agent_emoji",
        "utcnow",
        "get"
      ],
      "line_number": 220
    },
    "empirica.cli.simple_session_server.create_session": {
      "name": "create_session",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "req"
      ],
      "returns": "",
      "docstring": "Create new collaboration session",
      "decorators": [],
      "calls": [
        "create",
        "_dashboard",
        "post"
      ],
      "line_number": 499
    },
    "empirica.cli.simple_session_server.execute_command": {
      "name": "execute_command",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "sid",
        "cmd",
        "args"
      ],
      "returns": "dict",
      "docstring": "Execute command in session context",
      "decorators": [],
      "calls": [
        "_list_files",
        "_run_bash",
        "_get_guidance",
        "_move_file",
        "isoformat",
        "_handle_plan_proposal",
        "_store_assessment",
        "utcnow",
        "append",
        "get",
        "_read_file",
        "_prompt_assessment",
        "_dashboard"
      ],
      "line_number": 55
    },
    "empirica.cli.simple_session_server.get_dashboard": {
      "name": "get_dashboard",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "Get current session dashboard",
      "decorators": [],
      "calls": [
        "get",
        "HTTPException",
        "_dashboard"
      ],
      "line_number": 517
    },
    "empirica.cli.simple_session_server.list_sessions": {
      "name": "list_sessions",
      "module": "empirica.cli.simple_session_server",
      "params": [],
      "returns": "",
      "docstring": "List all active sessions",
      "decorators": [],
      "calls": [
        "get",
        "items",
        "len"
      ],
      "line_number": 526
    },
    "empirica.cli.simple_session_server.root": {
      "name": "root",
      "module": "empirica.cli.simple_session_server",
      "params": [],
      "returns": "",
      "docstring": "API info",
      "decorators": [],
      "calls": [
        "get",
        "len"
      ],
      "line_number": 544
    },
    "empirica.cli.simple_session_server.__init__": {
      "name": "__init__",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "Path"
      ],
      "line_number": 30
    },
    "empirica.cli.simple_session_server.create": {
      "name": "create",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "ai_id",
        "task",
        "workspace"
      ],
      "returns": "str",
      "docstring": "Create new collaboration session",
      "decorators": [],
      "calls": [
        "isoformat",
        "utcnow",
        "uuid4",
        "str"
      ],
      "line_number": 34
    },
    "empirica.cli.simple_session_server._list_files": {
      "name": "_list_files",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "path"
      ],
      "returns": "dict",
      "docstring": "List files in directory",
      "decorators": [],
      "calls": [
        "iterdir",
        "str",
        "Path",
        "append",
        "is_dir",
        "len",
        "exists",
        "stat",
        "is_file"
      ],
      "line_number": 98
    },
    "empirica.cli.simple_session_server._read_file": {
      "name": "_read_file",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "path"
      ],
      "returns": "dict",
      "docstring": "Read file content",
      "decorators": [],
      "calls": [
        "str",
        "splitlines",
        "Path",
        "append",
        "len",
        "exists",
        "is_file",
        "read_text"
      ],
      "line_number": 127
    },
    "empirica.cli.simple_session_server._move_file": {
      "name": "_move_file",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "from_path",
        "to_path"
      ],
      "returns": "dict",
      "docstring": "Move file",
      "decorators": [],
      "calls": [
        "str",
        "isoformat",
        "mkdir",
        "Path",
        "append",
        "utcnow",
        "rename",
        "exists"
      ],
      "line_number": 149
    },
    "empirica.cli.simple_session_server._run_bash": {
      "name": "_run_bash",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "command"
      ],
      "returns": "dict",
      "docstring": "Run safe bash command",
      "decorators": [],
      "calls": [
        "run",
        "split",
        "str"
      ],
      "line_number": 188
    },
    "empirica.cli.simple_session_server._prompt_assessment": {
      "name": "_prompt_assessment",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "phase",
        "session"
      ],
      "returns": "dict",
      "docstring": "Prompt AI for epistemic self-assessment",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 219
    },
    "empirica.cli.simple_session_server._store_assessment": {
      "name": "_store_assessment",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "assessment"
      ],
      "returns": "dict",
      "docstring": "Store epistemic assessment",
      "decorators": [],
      "calls": [
        "get",
        "utcnow",
        "isoformat"
      ],
      "line_number": 260
    },
    "empirica.cli.simple_session_server._handle_plan_proposal": {
      "name": "_handle_plan_proposal",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session",
        "args"
      ],
      "returns": "dict",
      "docstring": "Handle plan proposal from AI",
      "decorators": [],
      "calls": [
        "get",
        "utcnow",
        "isoformat"
      ],
      "line_number": 287
    },
    "empirica.cli.simple_session_server._get_guidance": {
      "name": "_get_guidance",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session"
      ],
      "returns": "dict",
      "docstring": "Get contextual guidance",
      "decorators": [],
      "calls": [
        "append"
      ],
      "line_number": 303
    },
    "empirica.cli.simple_session_server._dashboard": {
      "name": "_dashboard",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session"
      ],
      "returns": "dict",
      "docstring": "Generate dashboard JSON",
      "decorators": [],
      "calls": [
        "_get_available_actions",
        "len",
        "_get_status_summary",
        "_get_recommended"
      ],
      "line_number": 325
    },
    "empirica.cli.simple_session_server._get_available_actions": {
      "name": "_get_available_actions",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session"
      ],
      "returns": "List[dict]",
      "docstring": "Get phase-appropriate available actions",
      "decorators": [],
      "calls": [
        "append",
        "extend"
      ],
      "line_number": 351
    },
    "empirica.cli.simple_session_server._get_recommended": {
      "name": "_get_recommended",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session"
      ],
      "returns": "dict",
      "docstring": "Get recommended next action",
      "decorators": [],
      "calls": [],
      "line_number": 429
    },
    "empirica.cli.simple_session_server._get_status_summary": {
      "name": "_get_status_summary",
      "module": "empirica.cli.simple_session_server",
      "params": [
        "self",
        "session"
      ],
      "returns": "str",
      "docstring": "Get human-readable status",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 466
    },
    "empirica.cli.mcp_client.session_create": {
      "name": "session_create",
      "module": "empirica.cli.mcp_client",
      "params": [
        "ai_id",
        "bootstrap_level",
        "profile",
        "ai_model",
        "domain"
      ],
      "returns": "",
      "docstring": "Call MCP server session_create tool\n\nArgs:\n    ai_id: AI identifier\n    bootstrap_level: Bootstrap configuration level (standard, minimal, full, etc.)\n    profile: Optional profile for session configu",
      "decorators": [],
      "calls": [
        "time",
        "str",
        "int",
        "__import__"
      ],
      "line_number": 12
    },
    "empirica.cli.mcp_client.call_mcp_tool": {
      "name": "call_mcp_tool",
      "module": "empirica.cli.mcp_client",
      "params": [
        "tool_name",
        "arguments"
      ],
      "returns": "",
      "docstring": "Generic MCP tool caller\n\nArgs:\n    tool_name: Name of the MCP tool to call\n    arguments: Arguments to pass to the tool\n\nReturns:\n    dict: Response from MCP tool",
      "decorators": [],
      "calls": [],
      "line_number": 73
    },
    "empirica.cli.cli_core.create_argument_parser": {
      "name": "create_argument_parser",
      "module": "empirica.cli.cli_core",
      "params": [],
      "returns": "",
      "docstring": "Create and configure the main argument parser",
      "decorators": [],
      "calls": [
        "_add_profile_parsers",
        "_add_component_parsers",
        "_add_session_parsers",
        "add_argument",
        "_add_checkpoint_parsers",
        "_add_performance_parsers",
        "_add_cascade_parsers",
        "_add_investigation_parsers",
        "_add_monitor_parsers",
        "_add_skill_parsers",
        "_add_action_parsers",
        "_add_user_interface_parsers",
        "ArgumentParser",
        "_add_utility_parsers",
        "_add_assessment_parsers",
        "_add_config_parsers",
        "add_subparsers"
      ],
      "line_number": 22
    },
    "empirica.cli.cli_core._add_assessment_parsers": {
      "name": "_add_assessment_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add assessment command parsers",
      "decorators": [],
      "calls": [],
      "line_number": 93
    },
    "empirica.cli.cli_core._add_cascade_parsers": {
      "name": "_add_cascade_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add cascade command parsers (Primary CLI interface for epistemic assessments)\n\nThe CASCADE workflow commands are the primary interface for AI-based epistemic assessments.\nMCP tools provide GUI/IDE integration that maps to these CLI commands:\n- MCP execute-preflight maps to CLI preflight command\n- MCP execute-check maps to CLI check command\n- MCP execute-postflight maps to CLI postflight command",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_mutually_exclusive_group",
        "add_argument"
      ],
      "line_number": 99
    },
    "empirica.cli.cli_core._add_investigation_parsers": {
      "name": "_add_investigation_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add investigation command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 205
    },
    "empirica.cli.cli_core._add_performance_parsers": {
      "name": "_add_performance_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add performance command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 256
    },
    "empirica.cli.cli_core._add_component_parsers": {
      "name": "_add_component_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add component command parsers",
      "decorators": [],
      "calls": [],
      "line_number": 272
    },
    "empirica.cli.cli_core._add_skill_parsers": {
      "name": "_add_skill_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add skill management command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 279
    },
    "empirica.cli.cli_core._add_utility_parsers": {
      "name": "_add_utility_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add utility command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 298
    },
    "empirica.cli.cli_core._add_config_parsers": {
      "name": "_add_config_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add configuration command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 309
    },
    "empirica.cli.cli_core._add_monitor_parsers": {
      "name": "_add_monitor_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add monitoring command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 326
    },
    "empirica.cli.cli_core._add_mcp_parsers": {
      "name": "_add_mcp_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add MCP server command parsers - REMOVED: MCP server lifecycle managed by IDE/CLI",
      "decorators": [],
      "calls": [],
      "line_number": 353
    },
    "empirica.cli.cli_core._add_session_parsers": {
      "name": "_add_session_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add session management command parsers",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 360
    },
    "empirica.cli.cli_core._add_action_parsers": {
      "name": "_add_action_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add action logging command parsers for INVESTIGATE and ACT phases",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 390
    },
    "empirica.cli.cli_core._add_checkpoint_parsers": {
      "name": "_add_checkpoint_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add git checkpoint management command parsers (Phase 2)",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 415
    },
    "empirica.cli.cli_core._add_profile_parsers": {
      "name": "_add_profile_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add profile management command parsers",
      "decorators": [],
      "calls": [],
      "line_number": 854
    },
    "empirica.cli.cli_core._add_user_interface_parsers": {
      "name": "_add_user_interface_parsers",
      "module": "empirica.cli.cli_core",
      "params": [
        "subparsers"
      ],
      "returns": "",
      "docstring": "Add user interface commands for human terminal users",
      "decorators": [],
      "calls": [
        "add_parser",
        "add_argument"
      ],
      "line_number": 862
    },
    "empirica.cli.cli_core.main": {
      "name": "main",
      "module": "empirica.cli.cli_core",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Main CLI entry point",
      "decorators": [],
      "calls": [
        "create_argument_parser",
        "print_help",
        "parse_args",
        "getattr",
        "print",
        "get",
        "handle_cli_error",
        "handler",
        "time"
      ],
      "line_number": 897
    },
    "empirica.cli.asyncio_fix.suppress_asyncio_warnings": {
      "name": "suppress_asyncio_warnings",
      "module": "empirica.cli.asyncio_fix",
      "params": [],
      "returns": "",
      "docstring": "Suppress asyncio event loop closure warnings",
      "decorators": [],
      "calls": [
        "filterwarnings"
      ],
      "line_number": 14
    },
    "empirica.cli.asyncio_fix.patch_asyncio_for_mcp": {
      "name": "patch_asyncio_for_mcp",
      "module": "empirica.cli.asyncio_fix",
      "params": [],
      "returns": "",
      "docstring": "Apply patches to prevent asyncio event loop issues with MCP servers.\n\nThis should be called early in CLI startup before any MCP connections.",
      "decorators": [],
      "calls": [
        "original_del",
        "all_tasks",
        "get_or_create_event_loop",
        "run_until_complete",
        "get_event_loop",
        "gather",
        "new_event_loop",
        "close",
        "suppress_asyncio_warnings",
        "is_closed",
        "set_event_loop",
        "register"
      ],
      "line_number": 30
    },
    "empirica.cli.asyncio_fix.get_or_create_event_loop": {
      "name": "get_or_create_event_loop",
      "module": "empirica.cli.asyncio_fix",
      "params": [],
      "returns": "",
      "docstring": "Get existing event loop or create new one",
      "decorators": [],
      "calls": [
        "get_event_loop",
        "new_event_loop",
        "is_closed",
        "set_event_loop"
      ],
      "line_number": 60
    },
    "empirica.cli.asyncio_fix.cleanup_event_loop": {
      "name": "cleanup_event_loop",
      "module": "empirica.cli.asyncio_fix",
      "params": [],
      "returns": "",
      "docstring": "Safely cleanup event loop at exit",
      "decorators": [],
      "calls": [
        "all_tasks",
        "run_until_complete",
        "get_event_loop",
        "gather",
        "close",
        "is_closed"
      ],
      "line_number": 73
    },
    "empirica.cli.asyncio_fix.safe_del": {
      "name": "safe_del",
      "module": "empirica.cli.asyncio_fix",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "original_del"
      ],
      "line_number": 48
    },
    "empirica.integrations.branch_mapping.get_branch_mapping": {
      "name": "get_branch_mapping",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "repo_root"
      ],
      "returns": "BranchMapping",
      "docstring": "Get branch mapping instance.\n\nArgs:\n    repo_root: Optional git repository root\n    \nReturns:\n    BranchMapping instance",
      "decorators": [],
      "calls": [
        "BranchMapping"
      ],
      "line_number": 158
    },
    "empirica.integrations.branch_mapping.__init__": {
      "name": "__init__",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "repo_root"
      ],
      "returns": "",
      "docstring": "Initialize branch mapping manager.\n\nArgs:\n    repo_root: Git repository root. If None, searches from cwd.",
      "decorators": [],
      "calls": [
        "_load_mappings",
        "_find_repo_root",
        "mkdir",
        "Path"
      ],
      "line_number": 23
    },
    "empirica.integrations.branch_mapping._find_repo_root": {
      "name": "_find_repo_root",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Find git repository root from current directory.",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "exists",
        "cwd",
        "str"
      ],
      "line_number": 43
    },
    "empirica.integrations.branch_mapping._load_mappings": {
      "name": "_load_mappings",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Load mappings from file.",
      "decorators": [],
      "calls": [
        "open",
        "exists",
        "load"
      ],
      "line_number": 52
    },
    "empirica.integrations.branch_mapping._save_mappings": {
      "name": "_save_mappings",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Save mappings to file.",
      "decorators": [],
      "calls": [
        "open",
        "dump"
      ],
      "line_number": 64
    },
    "empirica.integrations.branch_mapping.add_mapping": {
      "name": "add_mapping",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "branch_name",
        "goal_id",
        "beads_issue_id",
        "ai_id",
        "session_id"
      ],
      "returns": "bool",
      "docstring": "Add a branch-to-goal mapping.\n\nArgs:\n    branch_name: Git branch name\n    goal_id: Empirica goal UUID\n    beads_issue_id: Optional BEADS issue ID\n    ai_id: Optional AI identifier\n    session_id: Opti",
      "decorators": [],
      "calls": [
        "_save_mappings",
        "utcnow",
        "isoformat"
      ],
      "line_number": 69
    },
    "empirica.integrations.branch_mapping.get_mapping": {
      "name": "get_mapping",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "branch_name"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get mapping for a branch.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 105
    },
    "empirica.integrations.branch_mapping.get_branch_for_goal": {
      "name": "get_branch_for_goal",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "Optional[str]",
      "docstring": "Find branch associated with a goal.",
      "decorators": [],
      "calls": [
        "items"
      ],
      "line_number": 109
    },
    "empirica.integrations.branch_mapping.remove_mapping": {
      "name": "remove_mapping",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "branch_name",
        "archive"
      ],
      "returns": "bool",
      "docstring": "Remove a branch mapping.\n\nArgs:\n    branch_name: Branch to remove\n    archive: If True, moves to history instead of deleting\n    \nReturns:\n    True if removed, False if not found",
      "decorators": [],
      "calls": [
        "_save_mappings",
        "isoformat",
        "utcnow",
        "append"
      ],
      "line_number": 116
    },
    "empirica.integrations.branch_mapping.list_active_mappings": {
      "name": "list_active_mappings",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self"
      ],
      "returns": "List[Dict]",
      "docstring": "List all active branch mappings.",
      "decorators": [],
      "calls": [
        "items"
      ],
      "line_number": 145
    },
    "empirica.integrations.branch_mapping.get_history": {
      "name": "get_history",
      "module": "empirica.integrations.branch_mapping",
      "params": [
        "self",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "Get branch mapping history.",
      "decorators": [],
      "calls": [],
      "line_number": 153
    },
    "empirica.reasoning.ollama_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "model_name",
        "endpoint",
        "timeout"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 21
    },
    "empirica.reasoning.ollama_adapter._call_ollama": {
      "name": "_call_ollama",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "prompt",
        "format",
        "temperature",
        "max_tokens"
      ],
      "returns": "Dict",
      "docstring": "Low-level Ollama API call\n\nArgs:\n    prompt: Prompt text\n    format: Response format (\"json\" or None)\n    temperature: Sampling temperature (lower = more consistent)\n    max_tokens: Maximum tokens to ",
      "decorators": [],
      "calls": [
        "json",
        "raise_for_status",
        "error",
        "post"
      ],
      "line_number": 31
    },
    "empirica.reasoning.ollama_adapter._build_deprecation_prompt": {
      "name": "_build_deprecation_prompt",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "feature",
        "context"
      ],
      "returns": "str",
      "docstring": "Build prompt for deprecation analysis",
      "decorators": [],
      "calls": [
        "get",
        "join"
      ],
      "line_number": 83
    },
    "empirica.reasoning.ollama_adapter._parse_deprecation_response": {
      "name": "_parse_deprecation_response",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "response"
      ],
      "returns": "DeprecationJudgment",
      "docstring": "Parse Ollama response into DeprecationJudgment",
      "decorators": [],
      "calls": [
        "warning",
        "DeprecationJudgment",
        "str",
        "error",
        "loads",
        "float",
        "max",
        "get",
        "min"
      ],
      "line_number": 126
    },
    "empirica.reasoning.ollama_adapter.analyze_deprecation": {
      "name": "analyze_deprecation",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "feature",
        "context"
      ],
      "returns": "DeprecationJudgment",
      "docstring": "Analyze if feature is deprecated using AI reasoning\n\nArgs:\n    feature: Feature name (command, function, etc.)\n    context: Dict with evidence:\n        - doc_mentions: List of doc locations mentioning",
      "decorators": [],
      "calls": [
        "DeprecationJudgment",
        "str",
        "error",
        "info",
        "_call_ollama",
        "_build_deprecation_prompt",
        "_parse_deprecation_response"
      ],
      "line_number": 182
    },
    "empirica.reasoning.ollama_adapter._build_relationship_prompt": {
      "name": "_build_relationship_prompt",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "doc_section",
        "code_section",
        "context"
      ],
      "returns": "str",
      "docstring": "Build prompt for relationship analysis",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 233
    },
    "empirica.reasoning.ollama_adapter._parse_relationship_response": {
      "name": "_parse_relationship_response",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "response"
      ],
      "returns": "RelationshipAnalysis",
      "docstring": "Parse Ollama response into RelationshipAnalysis",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "RelationshipAnalysis",
        "error",
        "loads",
        "float",
        "max",
        "get",
        "min"
      ],
      "line_number": 276
    },
    "empirica.reasoning.ollama_adapter.analyze_relationship": {
      "name": "analyze_relationship",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "doc_section",
        "code_section",
        "context"
      ],
      "returns": "RelationshipAnalysis",
      "docstring": "Analyze relationship between doc and code sections\n\nArgs:\n    doc_section: Documentation text describing a feature\n    code_section: Code implementation (function, class, etc.)\n    context: Optional d",
      "decorators": [],
      "calls": [
        "_build_relationship_prompt",
        "str",
        "_parse_relationship_response",
        "RelationshipAnalysis",
        "error",
        "info",
        "_call_ollama",
        "get"
      ],
      "line_number": 338
    },
    "empirica.reasoning.ollama_adapter._build_implementation_gap_prompt": {
      "name": "_build_implementation_gap_prompt",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "documented_behavior",
        "actual_implementation",
        "context"
      ],
      "returns": "str",
      "docstring": "Build prompt for implementation gap analysis",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 394
    },
    "empirica.reasoning.ollama_adapter._parse_implementation_gap_response": {
      "name": "_parse_implementation_gap_response",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "response"
      ],
      "returns": "ImplementationGap",
      "docstring": "Parse Ollama response into ImplementationGap",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "error",
        "loads",
        "float",
        "ImplementationGap",
        "max",
        "get",
        "min"
      ],
      "line_number": 441
    },
    "empirica.reasoning.ollama_adapter.analyze_implementation_gap": {
      "name": "analyze_implementation_gap",
      "module": "empirica.reasoning.ollama_adapter",
      "params": [
        "self",
        "documented_behavior",
        "actual_implementation",
        "context"
      ],
      "returns": "ImplementationGap",
      "docstring": "Analyze gaps between documented behavior and actual implementation\n\nArgs:\n    documented_behavior: What the docs say the feature should do\n    actual_implementation: Code implementing the feature\n    ",
      "decorators": [],
      "calls": [
        "str",
        "error",
        "_parse_implementation_gap_response",
        "info",
        "_call_ollama",
        "ImplementationGap",
        "get",
        "_build_implementation_gap_prompt"
      ],
      "line_number": 511
    },
    "empirica.reasoning.epistemic_cascade.create_default_cascade": {
      "name": "create_default_cascade",
      "module": "empirica.reasoning.epistemic_cascade",
      "params": [
        "endpoint"
      ],
      "returns": "EpistemicCascade",
      "docstring": "Create cascade with default configuration\n\nReturns:\n    EpistemicCascade configured for deprecation analysis",
      "decorators": [],
      "calls": [
        "EpistemicCascade"
      ],
      "line_number": 218
    },
    "empirica.reasoning.epistemic_cascade.__init__": {
      "name": "__init__",
      "module": "empirica.reasoning.epistemic_cascade",
      "params": [
        "self",
        "tier1_model",
        "tier2_model",
        "endpoint",
        "tier1_threshold",
        "tier2_threshold"
      ],
      "returns": "",
      "docstring": "Initialize epistemic cascade\n\nArgs:\n    tier1_model: Fast model for initial analysis\n    tier2_model: Powerful model for uncertain cases\n    endpoint: Ollama endpoint\n    tier1_threshold: Confidence t",
      "decorators": [],
      "calls": [
        "OllamaReasoningModel",
        "info"
      ],
      "line_number": 34
    },
    "empirica.reasoning.epistemic_cascade.analyze_with_cascade": {
      "name": "analyze_with_cascade",
      "module": "empirica.reasoning.epistemic_cascade",
      "params": [
        "self",
        "feature",
        "context"
      ],
      "returns": "Dict",
      "docstring": "Analyze with uncertainty-driven escalation\n\nReturns dict with:\n- judgment: Final DeprecationJudgment\n- tier_used: 1, 2, or \"human\"\n- tier1_result: Always present\n- tier2_result: Present if escalated",
      "decorators": [],
      "calls": [
        "analyze_deprecation",
        "warning",
        "_create_human_review_judgment",
        "info"
      ],
      "line_number": 60
    },
    "empirica.reasoning.epistemic_cascade._create_human_review_judgment": {
      "name": "_create_human_review_judgment",
      "module": "empirica.reasoning.epistemic_cascade",
      "params": [
        "self",
        "feature",
        "tier1",
        "tier2"
      ],
      "returns": "DeprecationJudgment",
      "docstring": "Create judgment indicating human review needed",
      "decorators": [],
      "calls": [
        "DeprecationJudgment",
        "max"
      ],
      "line_number": 117
    },
    "empirica.reasoning.epistemic_cascade.analyze_batch_with_cascade": {
      "name": "analyze_batch_with_cascade",
      "module": "empirica.reasoning.epistemic_cascade",
      "params": [
        "self",
        "candidates"
      ],
      "returns": "Dict",
      "docstring": "Analyze batch with cascade, tracking efficiency\n\nArgs:\n    candidates: List of (feature, context) tuples\n    \nReturns:\n    Dict with results and statistics",
      "decorators": [],
      "calls": [
        "append",
        "len",
        "time",
        "analyze_with_cascade"
      ],
      "line_number": 163
    },
    "empirica.reasoning.service.analyze_deprecation": {
      "name": "analyze_deprecation",
      "module": "empirica.reasoning.service",
      "params": [
        "self",
        "feature",
        "context"
      ],
      "returns": "DeprecationJudgment",
      "docstring": "Analyze if a feature is deprecated\n\nArgs:\n    feature: Feature name\n    context: Evidence dictionary\n    \nReturns:\n    DeprecationJudgment with status and reasoning",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 16
    },
    "empirica.reasoning.service.analyze_relationship": {
      "name": "analyze_relationship",
      "module": "empirica.reasoning.service",
      "params": [
        "self",
        "doc_section",
        "code_section"
      ],
      "returns": "RelationshipAnalysis",
      "docstring": "Analyze relationship between doc and code\n\nArgs:\n    doc_section: Documentation text\n    code_section: Code text\n    \nReturns:\n    RelationshipAnalysis",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 34
    },
    "empirica.reasoning.service.analyze_implementation_gap": {
      "name": "analyze_implementation_gap",
      "module": "empirica.reasoning.service",
      "params": [
        "self",
        "documented_behavior",
        "actual_implementation"
      ],
      "returns": "ImplementationGap",
      "docstring": "Analyze if implementation matches documented behavior\n\nArgs:\n    documented_behavior: What docs say\n    actual_implementation: What code does\n    \nReturns:\n    ImplementationGap analysis",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 52
    },
    "empirica.api.app.create_app": {
      "name": "create_app",
      "module": "empirica.api.app",
      "params": [],
      "returns": "Flask",
      "docstring": "Create and configure Flask application",
      "decorators": [],
      "calls": [
        "route",
        "errorhandler",
        "str",
        "error",
        "info",
        "jsonify",
        "register_blueprint",
        "Flask"
      ],
      "line_number": 12
    },
    "empirica.api.app.add_cors_headers": {
      "name": "add_cors_headers",
      "module": "empirica.api.app",
      "params": [
        "response"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 23
    },
    "empirica.api.app.health_check": {
      "name": "health_check",
      "module": "empirica.api.app",
      "params": [],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "route",
        "jsonify"
      ],
      "line_number": 31
    },
    "empirica.api.app.handle_error": {
      "name": "handle_error",
      "module": "empirica.api.app",
      "params": [
        "error"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "jsonify",
        "errorhandler",
        "error",
        "str"
      ],
      "line_number": 45
    },
    "empirica.config.credentials_loader.get_credentials_loader": {
      "name": "get_credentials_loader",
      "module": "empirica.config.credentials_loader",
      "params": [],
      "returns": "CredentialsLoader",
      "docstring": "Get global credentials loader instance",
      "decorators": [],
      "calls": [
        "CredentialsLoader"
      ],
      "line_number": 268
    },
    "empirica.config.credentials_loader.__new__": {
      "name": "__new__",
      "module": "empirica.config.credentials_loader",
      "params": [
        "cls"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "__new__",
        "super"
      ],
      "line_number": 39
    },
    "empirica.config.credentials_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "_load_credentials"
      ],
      "line_number": 44
    },
    "empirica.config.credentials_loader._find_config_file": {
      "name": "_find_config_file",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "Optional[Path]",
      "docstring": "Find credentials config file in order of precedence:\n1. Environment variable EMPIRICA_CREDENTIALS_PATH\n2. .empirica/credentials.yaml (repo root)\n3. .empirica/credentials.json (repo root)\n4. ~/.empiric",
      "decorators": [],
      "calls": [
        "Path",
        "home",
        "exists",
        "getenv"
      ],
      "line_number": 48
    },
    "empirica.config.credentials_loader._load_credentials": {
      "name": "_load_credentials",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Load credentials from config file or fallback to dotfiles",
      "decorators": [],
      "calls": [
        "_load_from_dotfiles",
        "open",
        "warning",
        "error",
        "info",
        "_interpolate_env_vars",
        "len",
        "load",
        "get",
        "_find_config_file",
        "safe_load"
      ],
      "line_number": 81
    },
    "empirica.config.credentials_loader._interpolate_env_vars": {
      "name": "_interpolate_env_vars",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "config"
      ],
      "returns": "Dict",
      "docstring": "Replace ${VAR_NAME} with environment variable values",
      "decorators": [],
      "calls": [
        "getenv",
        "debug",
        "items",
        "replace_vars",
        "sub",
        "group",
        "isinstance"
      ],
      "line_number": 114
    },
    "empirica.config.credentials_loader._load_from_dotfiles": {
      "name": "_load_from_dotfiles",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Fallback: Load from legacy dotfiles",
      "decorators": [],
      "calls": [
        "read",
        "open",
        "warning",
        "str",
        "debug",
        "items",
        "Path",
        "info",
        "strip",
        "exists"
      ],
      "line_number": 139
    },
    "empirica.config.credentials_loader.get_provider_config": {
      "name": "get_provider_config",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get configuration for a specific provider\n\nArgs:\n    provider: Provider name (qwen, minimax, etc.)\n\nReturns:\n    Dict with provider config or None if not found",
      "decorators": [],
      "calls": [
        "get",
        "_load_credentials"
      ],
      "line_number": 181
    },
    "empirica.config.credentials_loader.get_api_key": {
      "name": "get_api_key",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Optional[str]",
      "docstring": "Get API key for provider",
      "decorators": [],
      "calls": [
        "get",
        "get_provider_config"
      ],
      "line_number": 197
    },
    "empirica.config.credentials_loader.get_base_url": {
      "name": "get_base_url",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Optional[str]",
      "docstring": "Get base URL for provider",
      "decorators": [],
      "calls": [
        "get",
        "get_provider_config"
      ],
      "line_number": 202
    },
    "empirica.config.credentials_loader.get_headers": {
      "name": "get_headers",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Dict[str, str]",
      "docstring": "Get HTTP headers for provider\n\nAutomatically interpolates ${api_key} in headers",
      "decorators": [],
      "calls": [
        "items",
        "get_provider_config",
        "replace",
        "isinstance",
        "get"
      ],
      "line_number": 207
    },
    "empirica.config.credentials_loader.get_default_model": {
      "name": "get_default_model",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Optional[str]",
      "docstring": "Get default model for provider",
      "decorators": [],
      "calls": [
        "get",
        "get_provider_config"
      ],
      "line_number": 230
    },
    "empirica.config.credentials_loader.get_available_models": {
      "name": "get_available_models",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "list",
      "docstring": "Get list of available models for provider",
      "decorators": [],
      "calls": [
        "get",
        "get_provider_config"
      ],
      "line_number": 235
    },
    "empirica.config.credentials_loader.validate_model": {
      "name": "validate_model",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider",
        "model"
      ],
      "returns": "bool",
      "docstring": "Check if model is available for provider",
      "decorators": [],
      "calls": [
        "get_available_models"
      ],
      "line_number": 240
    },
    "empirica.config.credentials_loader.get_auth_method": {
      "name": "get_auth_method",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self",
        "provider"
      ],
      "returns": "str",
      "docstring": "Get authentication method (header, query_param, cli)",
      "decorators": [],
      "calls": [
        "get",
        "get_provider_config"
      ],
      "line_number": 247
    },
    "empirica.config.credentials_loader.list_providers": {
      "name": "list_providers",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "list",
      "docstring": "List all configured providers",
      "decorators": [],
      "calls": [
        "list",
        "get",
        "keys",
        "_load_credentials"
      ],
      "line_number": 252
    },
    "empirica.config.credentials_loader.reload": {
      "name": "reload",
      "module": "empirica.config.credentials_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Reload credentials from file",
      "decorators": [],
      "calls": [
        "_load_credentials"
      ],
      "line_number": 258
    },
    "empirica.config.credentials_loader.replace_vars": {
      "name": "replace_vars",
      "module": "empirica.config.credentials_loader",
      "params": [
        "obj"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "getenv",
        "debug",
        "items",
        "replace_vars",
        "sub",
        "group",
        "isinstance"
      ],
      "line_number": 116
    },
    "empirica.config.credentials_loader.replacer": {
      "name": "replacer",
      "module": "empirica.config.credentials_loader",
      "params": [
        "match"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "debug",
        "group",
        "getenv"
      ],
      "line_number": 125
    },
    "empirica.config.path_resolver.get_git_root": {
      "name": "get_git_root",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Optional[Path]",
      "docstring": "Get git repository root directory.\n\nReturns:\n    Path to git root, or None if not in a git repo",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "Path"
      ],
      "line_number": 34
    },
    "empirica.config.path_resolver.load_empirica_config": {
      "name": "load_empirica_config",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Optional[dict]",
      "docstring": "Load .empirica/config.yaml from git root.\n\nReturns:\n    Config dict or None if not found",
      "decorators": [],
      "calls": [
        "get_git_root",
        "open",
        "warning",
        "debug",
        "exists",
        "safe_load"
      ],
      "line_number": 65
    },
    "empirica.config.path_resolver.get_empirica_root": {
      "name": "get_empirica_root",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Path",
      "docstring": "Get Empirica root data directory.\n\nPriority:\n1. EMPIRICA_DATA_DIR environment variable\n2. .empirica/config.yaml -> root\n3. <git-root>/.empirica (if in git repo)\n4. <cwd>/.empirica (fallback)\n\nReturns:",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "get_git_root",
        "getenv",
        "debug",
        "cwd",
        "Path",
        "resolve",
        "expanduser"
      ],
      "line_number": 90
    },
    "empirica.config.path_resolver.get_session_db_path": {
      "name": "get_session_db_path",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Path",
      "docstring": "Get full path to sessions database.\n\nPriority:\n1. EMPIRICA_SESSION_DB environment variable\n2. .empirica/config.yaml -> paths.sessions\n3. <empirica_root>/sessions/sessions.db (default)\n\nReturns:\n    Pa",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "getenv",
        "debug",
        "get_empirica_root",
        "Path",
        "resolve",
        "expanduser"
      ],
      "line_number": 129
    },
    "empirica.config.path_resolver.get_identity_dir": {
      "name": "get_identity_dir",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Path",
      "docstring": "Get identity keys directory.",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "get_empirica_root"
      ],
      "line_number": 162
    },
    "empirica.config.path_resolver.get_metrics_dir": {
      "name": "get_metrics_dir",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Path",
      "docstring": "Get metrics directory.",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "get_empirica_root"
      ],
      "line_number": 172
    },
    "empirica.config.path_resolver.get_messages_dir": {
      "name": "get_messages_dir",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "Path",
      "docstring": "Get messages directory.",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "get_empirica_root"
      ],
      "line_number": 182
    },
    "empirica.config.path_resolver.ensure_empirica_structure": {
      "name": "ensure_empirica_structure",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "None",
      "docstring": "Ensure .empirica directory structure exists.\nCreates directories if they don't exist.",
      "decorators": [],
      "calls": [
        "debug",
        "get_empirica_root",
        "mkdir"
      ],
      "line_number": 192
    },
    "empirica.config.path_resolver.create_default_config": {
      "name": "create_default_config",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "None",
      "docstring": "Create default .empirica/config.yaml if it doesn't exist.\nOnly creates in git repos.",
      "decorators": [],
      "calls": [
        "get_git_root",
        "open",
        "str",
        "debug",
        "mkdir",
        "dump",
        "info",
        "exists"
      ],
      "line_number": 209
    },
    "empirica.config.path_resolver.debug_paths": {
      "name": "debug_paths",
      "module": "empirica.config.path_resolver",
      "params": [],
      "returns": "dict",
      "docstring": "Get all resolved paths for debugging.\n\nReturns:\n    Dict with all path information",
      "decorators": [],
      "calls": [
        "load_empirica_config",
        "get_git_root",
        "get_messages_dir",
        "str",
        "get_identity_dir",
        "getenv",
        "get_session_db_path",
        "get_empirica_root",
        "get_metrics_dir"
      ],
      "line_number": 255
    },
    "empirica.config.project_config_loader.load_project_config": {
      "name": "load_project_config",
      "module": "empirica.config.project_config_loader",
      "params": [
        "project_root"
      ],
      "returns": "Optional[ProjectConfig]",
      "docstring": "Load project configuration from .empirica/project.yaml\n\nArgs:\n    project_root: Root directory of project (defaults to current directory)\n    \nReturns:\n    ProjectConfig if found, None otherwise",
      "decorators": [],
      "calls": [
        "open",
        "debug",
        "error",
        "cwd",
        "info",
        "exists",
        "get",
        "ProjectConfig",
        "safe_load"
      ],
      "line_number": 69
    },
    "empirica.config.project_config_loader.get_current_subject": {
      "name": "get_current_subject",
      "module": "empirica.config.project_config_loader",
      "params": [
        "project_config",
        "current_path"
      ],
      "returns": "Optional[str]",
      "docstring": "Get current subject based on working directory.\n\nArgs:\n    project_config: Project configuration (loads if None)\n    current_path: Current working directory (uses cwd if None)\n    \nReturns:\n    subjec",
      "decorators": [],
      "calls": [
        "load_project_config",
        "get_subject_for_path",
        "cwd",
        "str"
      ],
      "line_number": 100
    },
    "empirica.config.project_config_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.project_config_loader",
      "params": [
        "self",
        "config_data"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 19
    },
    "empirica.config.project_config_loader.get_subject_for_path": {
      "name": "get_subject_for_path",
      "module": "empirica.config.project_config_loader",
      "params": [
        "self",
        "current_path"
      ],
      "returns": "Optional[str]",
      "docstring": "Detect subject from current working directory.\n\nArgs:\n    current_path: Current working directory\n    \nReturns:\n    subject_id if matched, None otherwise",
      "decorators": [],
      "calls": [
        "debug",
        "items",
        "Path",
        "info",
        "relative_to",
        "resolve",
        "get"
      ],
      "line_number": 27
    },
    "empirica.config.project_config_loader.get_subject_info": {
      "name": "get_subject_info",
      "module": "empirica.config.project_config_loader",
      "params": [
        "self",
        "subject_id"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get subject configuration",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 60
    },
    "empirica.config.project_config_loader.list_subjects": {
      "name": "list_subjects",
      "module": "empirica.config.project_config_loader",
      "params": [
        "self"
      ],
      "returns": "List[str]",
      "docstring": "List all subject IDs",
      "decorators": [],
      "calls": [
        "list",
        "keys"
      ],
      "line_number": 64
    },
    "empirica.config.memory_gap_policy_loader.get_policy_loader": {
      "name": "get_policy_loader",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [],
      "returns": "MemoryGapPolicyLoader",
      "docstring": "Get global MemoryGapPolicyLoader instance (singleton pattern).\n\nReturns:\n    MemoryGapPolicyLoader instance",
      "decorators": [],
      "calls": [
        "MemoryGapPolicyLoader"
      ],
      "line_number": 277
    },
    "empirica.config.memory_gap_policy_loader.get_memory_gap_policy": {
      "name": "get_memory_gap_policy",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "mode",
        "gap_type"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get memory gap policy configuration.\n\nConvenience function that uses global MemoryGapPolicyLoader.\n\nArgs:\n    mode: Enforcement mode ('inform', 'warn', 'strict', 'block')\n    gap_type: Optional specif",
      "decorators": [],
      "calls": [
        "get_policy",
        "get_policy_loader"
      ],
      "line_number": 290
    },
    "empirica.config.memory_gap_policy_loader.get_enforcement_for_gap": {
      "name": "get_enforcement_for_gap",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self",
        "gap_type",
        "gap_score",
        "gap_count",
        "default_mode"
      ],
      "returns": "str",
      "docstring": "Get recommended enforcement mode for a specific gap.\n\nArgs:\n    gap_type: Type of memory gap\n    gap_score: Gap score (0.0-1.0) or count\n    gap_count: Optional count for count-based gaps\n    default_",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 197
    },
    "empirica.config.memory_gap_policy_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize memory gap policy loader.\n\nArgs:\n    config_path: Optional path to epistemic_conduct.yaml",
      "decorators": [],
      "calls": [
        "_load_configurations",
        "Path"
      ],
      "line_number": 52
    },
    "empirica.config.memory_gap_policy_loader._load_configurations": {
      "name": "_load_configurations",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Load memory gap policies from YAML",
      "decorators": [],
      "calls": [
        "_load_hardcoded_defaults",
        "open",
        "warning",
        "error",
        "info",
        "len",
        "exists",
        "get",
        "safe_load"
      ],
      "line_number": 70
    },
    "empirica.config.memory_gap_policy_loader._load_hardcoded_defaults": {
      "name": "_load_hardcoded_defaults",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Fallback hardcoded policies if YAML loading fails",
      "decorators": [],
      "calls": [
        "warning"
      ],
      "line_number": 104
    },
    "empirica.config.memory_gap_policy_loader.get_policy": {
      "name": "get_policy",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self",
        "mode",
        "gap_type"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get memory gap policy configuration.\n\nArgs:\n    mode: Enforcement mode ('inform', 'warn', 'strict', 'block')\n    gap_type: Optional specific gap type for per-category policy\n\nReturns:\n    Policy dicti",
      "decorators": [],
      "calls": [
        "get",
        "items",
        "keys",
        "warning"
      ],
      "line_number": 137
    },
    "empirica.config.memory_gap_policy_loader.list_enforcement_modes": {
      "name": "list_enforcement_modes",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, str]",
      "docstring": "List all available enforcement modes",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 255
    },
    "empirica.config.memory_gap_policy_loader.list_scope_policies": {
      "name": "list_scope_policies",
      "module": "empirica.config.memory_gap_policy_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "List all scope-specific policies",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 262
    },
    "empirica.config.goal_scope_loader.get_scope_recommendations": {
      "name": "get_scope_recommendations",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "epistemic_vectors",
        "context"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get scope recommendations based on epistemic vector pattern.\n\nArgs:\n    epistemic_vectors: Current epistemic assessment (13 vectors)\n    context: Additional context (task type, user priority, etc.)\n  ",
      "decorators": [],
      "calls": [
        "_calculate_pattern_match",
        "_apply_context_adjustments",
        "debug",
        "items",
        "info",
        "_get_conservative_defaults",
        "get"
      ],
      "line_number": 122
    },
    "empirica.config.goal_scope_loader.validate_scope_coherence": {
      "name": "validate_scope_coherence",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "scope_vector"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Validate scope vector coherence and provide warnings.\n\nArgs:\n    scope_vector: {'breadth': float, 'duration': float, 'coordination': float}\n    \nReturns:\n    Validation results with warnings and sugge",
      "decorators": [],
      "calls": [
        "get",
        "items",
        "len",
        "append"
      ],
      "line_number": 292
    },
    "empirica.config.goal_scope_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize goal scope loader.\n\nArgs:\n    config_path: Optional path to goal_scopes.yaml\n\nNote: Use get_instance() for singleton pattern",
      "decorators": [],
      "calls": [
        "_load_configurations",
        "Path"
      ],
      "line_number": 59
    },
    "empirica.config.goal_scope_loader._load_configurations": {
      "name": "_load_configurations",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Load all configurations from YAML",
      "decorators": [],
      "calls": [
        "_load_hardcoded_defaults",
        "open",
        "warning",
        "error",
        "info",
        "len",
        "exists",
        "get",
        "safe_load"
      ],
      "line_number": 79
    },
    "empirica.config.goal_scope_loader._load_hardcoded_defaults": {
      "name": "_load_hardcoded_defaults",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Fallback hardcoded recommendations if YAML loading fails",
      "decorators": [],
      "calls": [
        "warning"
      ],
      "line_number": 105
    },
    "empirica.config.goal_scope_loader._calculate_pattern_match": {
      "name": "_calculate_pattern_match",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "epistemic_vectors",
        "pattern"
      ],
      "returns": "float",
      "docstring": "Calculate how well current epistemic state matches a pattern.\n\nArgs:\n    epistemic_vectors: Current epistemic values\n    pattern: Pattern definition with min/max constraints\n    \nReturns:\n    Match sc",
      "decorators": [],
      "calls": [
        "items",
        "max"
      ],
      "line_number": 189
    },
    "empirica.config.goal_scope_loader._apply_context_adjustments": {
      "name": "_apply_context_adjustments",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "recommendation",
        "context"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Apply context-based adjustments to scope recommendation",
      "decorators": [],
      "calls": [
        "get",
        "min",
        "deepcopy",
        "max"
      ],
      "line_number": 231
    },
    "empirica.config.goal_scope_loader._get_conservative_defaults": {
      "name": "_get_conservative_defaults",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self",
        "epistemic_vectors"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get conservative scope defaults when no pattern matches well",
      "decorators": [],
      "calls": [
        "get",
        "min",
        "max"
      ],
      "line_number": 257
    },
    "empirica.config.goal_scope_loader.list_available_patterns": {
      "name": "list_available_patterns",
      "module": "empirica.config.goal_scope_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, str]",
      "docstring": "List all available scope recommendation patterns",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 346
    },
    "empirica.config.profile_loader.get_profile_loader": {
      "name": "get_profile_loader",
      "module": "empirica.config.profile_loader",
      "params": [],
      "returns": "ProfileLoader",
      "docstring": "Get singleton profile loader instance",
      "decorators": [],
      "calls": [
        "ProfileLoader"
      ],
      "line_number": 367
    },
    "empirica.config.profile_loader.load_profile": {
      "name": "load_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "profile_name"
      ],
      "returns": "InvestigationProfile",
      "docstring": "Load a profile by name (convenience function)",
      "decorators": [],
      "calls": [
        "get_profile",
        "ValueError",
        "get_profile_loader"
      ],
      "line_number": 375
    },
    "empirica.config.profile_loader.select_profile": {
      "name": "select_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "ai_model",
        "domain",
        "explicit_profile"
      ],
      "returns": "InvestigationProfile",
      "docstring": "Select appropriate profile based on context\n\nArgs:\n    ai_model: AI model identifier (e.g., \"claude-sonnet\")\n    domain: Domain identifier (e.g., \"medical\", \"research\")\n    explicit_profile: Explicitl",
      "decorators": [],
      "calls": [
        "list",
        "items",
        "values",
        "any",
        "get",
        "lower"
      ],
      "line_number": 275
    },
    "empirica.config.profile_loader.to_dict": {
      "name": "to_dict",
      "module": "empirica.config.profile_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to dictionary",
      "decorators": [],
      "calls": [],
      "line_number": 102
    },
    "empirica.config.profile_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize profile loader\n\nArgs:\n    config_path: Path to investigation_profiles.yaml (default: auto-detect)",
      "decorators": [],
      "calls": [
        "load_config",
        "exists",
        "Path"
      ],
      "line_number": 160
    },
    "empirica.config.profile_loader.load_config": {
      "name": "load_config",
      "module": "empirica.config.profile_loader",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Load configuration from YAML file",
      "decorators": [],
      "calls": [
        "_parse_profile",
        "open",
        "items",
        "get",
        "safe_load",
        "UniversalConstraints"
      ],
      "line_number": 178
    },
    "empirica.config.profile_loader._parse_profile": {
      "name": "_parse_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "name",
        "data"
      ],
      "returns": "InvestigationProfile",
      "docstring": "Parse profile from config data",
      "decorators": [],
      "calls": [
        "InvestigationConstraints",
        "LearningConfig",
        "PostflightMode",
        "DomainDetection",
        "InvestigationProfile",
        "TuningParameters",
        "ActionThresholds",
        "ToolSuggestionMode",
        "isinstance",
        "get",
        "StrategyConfig"
      ],
      "line_number": 201
    },
    "empirica.config.profile_loader.get_profile": {
      "name": "get_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "profile_name"
      ],
      "returns": "Optional[InvestigationProfile]",
      "docstring": "Get profile by name",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 271
    },
    "empirica.config.profile_loader.list_profiles": {
      "name": "list_profiles",
      "module": "empirica.config.profile_loader",
      "params": [
        "self"
      ],
      "returns": "List[str]",
      "docstring": "List available profile names",
      "decorators": [],
      "calls": [
        "list",
        "keys"
      ],
      "line_number": 318
    },
    "empirica.config.profile_loader.validate_constraints": {
      "name": "validate_constraints",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "profile"
      ],
      "returns": "List[str]",
      "docstring": "Validate profile constraints against universal constraints\n\nReturns:\n    List of validation errors (empty if valid)",
      "decorators": [],
      "calls": [],
      "line_number": 322
    },
    "empirica.config.profile_loader.export_profile": {
      "name": "export_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "profile_name",
        "output_path"
      ],
      "returns": "None",
      "docstring": "Export profile to YAML file",
      "decorators": [],
      "calls": [
        "open",
        "to_dict",
        "dump",
        "ValueError",
        "get_profile"
      ],
      "line_number": 345
    },
    "empirica.config.profile_loader.import_profile": {
      "name": "import_profile",
      "module": "empirica.config.profile_loader",
      "params": [
        "self",
        "input_path",
        "profile_name"
      ],
      "returns": "None",
      "docstring": "Import profile from YAML file",
      "decorators": [],
      "calls": [
        "get",
        "_parse_profile",
        "open",
        "safe_load"
      ],
      "line_number": 354
    },
    "empirica.config.threshold_loader.get_threshold_config": {
      "name": "get_threshold_config",
      "module": "empirica.config.threshold_loader",
      "params": [],
      "returns": "ThresholdLoader",
      "docstring": "Get global ThresholdLoader instance.\n\nReturns:\n    Singleton ThresholdLoader instance\n\nUsage:\n    >>> from empirica.config.threshold_loader import get_threshold_config\n    >>> config = get_threshold_c",
      "decorators": [],
      "calls": [
        "get_instance"
      ],
      "line_number": 398
    },
    "empirica.config.threshold_loader.load_profile": {
      "name": "load_profile",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "profile_name"
      ],
      "returns": "bool",
      "docstring": "Load a specific profile by name.\n\nArgs:\n    profile_name: Name of profile (default, exploratory, rigorous, rapid, expert, novice)\n\nReturns:\n    True if profile loaded successfully, False otherwise",
      "decorators": [],
      "calls": [
        "list",
        "keys",
        "error",
        "info",
        "get"
      ],
      "line_number": 202
    },
    "empirica.config.threshold_loader.get_threshold": {
      "name": "get_threshold",
      "module": "empirica.config.threshold_loader",
      "params": [
        "key_path",
        "default"
      ],
      "returns": "Any",
      "docstring": "Get a threshold value (convenience function)",
      "decorators": [],
      "calls": [
        "get",
        "get_threshold_config"
      ],
      "line_number": 419
    },
    "empirica.config.threshold_loader.override_threshold": {
      "name": "override_threshold",
      "module": "empirica.config.threshold_loader",
      "params": [
        "key_path",
        "value"
      ],
      "returns": "",
      "docstring": "Override a threshold value (convenience function)",
      "decorators": [],
      "calls": [
        "get_threshold_config",
        "override"
      ],
      "line_number": 424
    },
    "empirica.config.threshold_loader.__init__": {
      "name": "__init__",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize threshold loader.\n\nArgs:\n    config_path: Optional path to cascade_styles.yaml (defaults to mco/cascade_styles.yaml)\n\nNote: Use get_instance() instead of direct instantiation for singleton ",
      "decorators": [],
      "calls": [
        "_load_profiles",
        "Path"
      ],
      "line_number": 57
    },
    "empirica.config.threshold_loader.get_instance": {
      "name": "get_instance",
      "module": "empirica.config.threshold_loader",
      "params": [
        "cls",
        "config_path"
      ],
      "returns": "'ThresholdLoader'",
      "docstring": "Get singleton instance of ThresholdLoader.\n\nArgs:\n    config_path: Optional path to cascade_styles.yaml (only used on first call)\n\nReturns:\n    Singleton ThresholdLoader instance",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "cls"
      ],
      "line_number": 80
    },
    "empirica.config.threshold_loader.reset_instance": {
      "name": "reset_instance",
      "module": "empirica.config.threshold_loader",
      "params": [
        "cls"
      ],
      "returns": "",
      "docstring": "Reset singleton instance (for testing)",
      "decorators": [
        "classmethod"
      ],
      "calls": [],
      "line_number": 96
    },
    "empirica.config.threshold_loader._load_profiles": {
      "name": "_load_profiles",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Load all profiles from YAML configuration file",
      "decorators": [],
      "calls": [
        "_load_hardcoded_defaults",
        "open",
        "warning",
        "error",
        "info",
        "len",
        "exists",
        "get",
        "safe_load"
      ],
      "line_number": 101
    },
    "empirica.config.threshold_loader._load_hardcoded_defaults": {
      "name": "_load_hardcoded_defaults",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Fallback to hardcoded defaults if YAML loading fails.\n\nThis ensures backwards compatibility - if cascade_styles.yaml is missing,\nwe fall back to the original hardcoded values from thresholds.py.",
      "decorators": [],
      "calls": [
        "error",
        "warning",
        "info"
      ],
      "line_number": 137
    },
    "empirica.config.threshold_loader.get": {
      "name": "get",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "key_path",
        "default"
      ],
      "returns": "Any",
      "docstring": "Get threshold value by dot-notation path.\n\nArgs:\n    key_path: Dot-separated path (e.g., 'engagement_threshold', 'critical.coherence_min')\n    default: Default value if key not found\n\nReturns:\n    Thr",
      "decorators": [],
      "calls": [
        "isinstance",
        "split"
      ],
      "line_number": 225
    },
    "empirica.config.threshold_loader.override": {
      "name": "override",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "key_path",
        "value"
      ],
      "returns": "",
      "docstring": "Override a specific threshold value for current session.\n\nArgs:\n    key_path: Dot-separated path to threshold\n    value: New value to set\n\nNote: Overrides are cleared when switching profiles\n\nExamples",
      "decorators": [],
      "calls": [
        "info"
      ],
      "line_number": 262
    },
    "empirica.config.threshold_loader.clear_overrides": {
      "name": "clear_overrides",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Clear all threshold overrides",
      "decorators": [],
      "calls": [
        "len",
        "info"
      ],
      "line_number": 279
    },
    "empirica.config.threshold_loader.create_custom_profile": {
      "name": "create_custom_profile",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "name",
        "base",
        "overrides"
      ],
      "returns": "bool",
      "docstring": "Create a custom profile based on existing profile with overrides.\n\nThis is the primary method for Sentinel to create task-specific or\nAI-specific threshold profiles.\n\nArgs:\n    name: Name for custom p",
      "decorators": [],
      "calls": [
        "items",
        "error",
        "_set_nested_value",
        "deepcopy",
        "info",
        "len"
      ],
      "line_number": 285
    },
    "empirica.config.threshold_loader._set_nested_value": {
      "name": "_set_nested_value",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self",
        "d",
        "key_path",
        "value"
      ],
      "returns": "",
      "docstring": "Set value in nested dictionary using dot notation",
      "decorators": [],
      "calls": [
        "setdefault",
        "split"
      ],
      "line_number": 332
    },
    "empirica.config.threshold_loader.get_profile_info": {
      "name": "get_profile_info",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get current profile metadata.\n\nReturns:\n    Dictionary with profile name, description, and active overrides",
      "decorators": [],
      "calls": [
        "get",
        "len"
      ],
      "line_number": 339
    },
    "empirica.config.threshold_loader.list_profiles": {
      "name": "list_profiles",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, str]",
      "docstring": "List all available profiles with descriptions.\n\nReturns:\n    Dictionary mapping profile names to descriptions",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 353
    },
    "empirica.config.threshold_loader.get_all_thresholds": {
      "name": "get_all_thresholds",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get all thresholds from current profile (including overrides).\n\nReturns:\n    Dictionary of all threshold values",
      "decorators": [],
      "calls": [
        "items",
        "deepcopy",
        "_set_nested_value"
      ],
      "line_number": 365
    },
    "empirica.config.threshold_loader.export_for_handoff": {
      "name": "export_for_handoff",
      "module": "empirica.config.threshold_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Export threshold configuration for epistemic handoff.\n\nReturns profile name and overrides (not full profile data) so that\nreceiving AI can reload appropriate thresholds for its capabilities.\n\nReturns:",
      "decorators": [],
      "calls": [],
      "line_number": 381
    },
    "empirica.dashboard.cascade_monitor.main": {
      "name": "main",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [],
      "returns": "",
      "docstring": "Main entry point",
      "decorators": [],
      "calls": [
        "CascadeMonitor",
        "mkdir",
        "print",
        "watch_for_updates"
      ],
      "line_number": 384
    },
    "empirica.dashboard.cascade_monitor.__init__": {
      "name": "__init__",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "SessionDatabase"
      ],
      "line_number": 33
    },
    "empirica.dashboard.cascade_monitor.get_active_cascade": {
      "name": "get_active_cascade",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get most recent active cascade (not yet completed)",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "dict"
      ],
      "line_number": 38
    },
    "empirica.dashboard.cascade_monitor.get_latest_cascade": {
      "name": "get_latest_cascade",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get most recent cascade (even if completed) - fallback for display",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "dict"
      ],
      "line_number": 53
    },
    "empirica.dashboard.cascade_monitor.get_assessments": {
      "name": "get_assessments",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self",
        "cascade_id"
      ],
      "returns": "Tuple[Optional[Dict], Optional[Dict]]",
      "docstring": "Get PREFLIGHT and POSTFLIGHT assessments for cascade",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "dict"
      ],
      "line_number": 67
    },
    "empirica.dashboard.cascade_monitor.format_vector_state": {
      "name": "format_vector_state",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self",
        "vector_name",
        "state",
        "prefix"
      ],
      "returns": "str",
      "docstring": "Format single vector with UVL indicators",
      "decorators": [],
      "calls": [
        "get",
        "get_confidence_color",
        "upper"
      ],
      "line_number": 93
    },
    "empirica.dashboard.cascade_monitor.format_phase_progress": {
      "name": "format_phase_progress",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self",
        "cascade"
      ],
      "returns": "str",
      "docstring": "Format CASCADE phase progress indicator",
      "decorators": [],
      "calls": [
        "get",
        "join",
        "append"
      ],
      "line_number": 111
    },
    "empirica.dashboard.cascade_monitor.calculate_delta": {
      "name": "calculate_delta",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self",
        "preflight",
        "postflight"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate epistemic delta (proof of learning)",
      "decorators": [],
      "calls": [
        "get",
        "keys",
        "loads"
      ],
      "line_number": 137
    },
    "empirica.dashboard.cascade_monitor.format_delta_indicator": {
      "name": "format_delta_indicator",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self",
        "delta"
      ],
      "returns": "str",
      "docstring": "Format delta with visual indicator",
      "decorators": [],
      "calls": [
        "abs"
      ],
      "line_number": 157
    },
    "empirica.dashboard.cascade_monitor.render_markdown": {
      "name": "render_markdown",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Generate markdown output for glow rendering",
      "decorators": [],
      "calls": [
        "get_confidence_color",
        "strftime",
        "get_latest_cascade",
        "get_active_cascade",
        "items",
        "len",
        "upper",
        "get",
        "list",
        "fromkeys",
        "calculate_delta",
        "get_assessments",
        "append",
        "format_delta_indicator",
        "format_vector_state",
        "abs",
        "join",
        "loads",
        "format_phase_progress"
      ],
      "line_number": 167
    },
    "empirica.dashboard.cascade_monitor.render_with_glow": {
      "name": "render_with_glow",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Render markdown with glow for pretty display",
      "decorators": [],
      "calls": [
        "render_markdown",
        "run"
      ],
      "line_number": 311
    },
    "empirica.dashboard.cascade_monitor.display": {
      "name": "display",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Display the dashboard (clear screen and render)",
      "decorators": [],
      "calls": [
        "render_with_glow",
        "print"
      ],
      "line_number": 334
    },
    "empirica.dashboard.cascade_monitor.watch_for_updates": {
      "name": "watch_for_updates",
      "module": "empirica.dashboard.cascade_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Watch for action hook updates and refresh display",
      "decorators": [],
      "calls": [
        "sleep",
        "display",
        "get_active_cascade",
        "exists",
        "stat",
        "print"
      ],
      "line_number": 343
    },
    "empirica.dashboard.snapshot_monitor.launch_dashboard": {
      "name": "launch_dashboard",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "Launch the snapshot monitoring dashboard\n\nArgs:\n    session_id: Session ID to monitor (uses current session if None)",
      "decorators": [],
      "calls": [
        "SnapshotMonitor",
        "print_exc",
        "wrapper",
        "print"
      ],
      "line_number": 475
    },
    "empirica.dashboard.snapshot_monitor.__init__": {
      "name": "__init__",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "",
      "docstring": "Initialize snapshot monitor\n\nArgs:\n    session_id: Session to monitor (uses current if None)",
      "decorators": [],
      "calls": [
        "get_instance",
        "time",
        "EpistemicSnapshotProvider"
      ],
      "line_number": 49
    },
    "empirica.dashboard.snapshot_monitor.get_color_for_reliability": {
      "name": "get_color_for_reliability",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "score"
      ],
      "returns": "int",
      "docstring": "Get curses color pair for reliability score",
      "decorators": [],
      "calls": [],
      "line_number": 75
    },
    "empirica.dashboard.snapshot_monitor.get_status_label": {
      "name": "get_status_label",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "score"
      ],
      "returns": "str",
      "docstring": "Get status label for reliability score",
      "decorators": [],
      "calls": [],
      "line_number": 88
    },
    "empirica.dashboard.snapshot_monitor.format_bar": {
      "name": "format_bar",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "score",
        "width"
      ],
      "returns": "str",
      "docstring": "Format a progress bar for a score",
      "decorators": [],
      "calls": [
        "int"
      ],
      "line_number": 101
    },
    "empirica.dashboard.snapshot_monitor.draw_header": {
      "name": "draw_header",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr",
        "snapshot"
      ],
      "returns": "",
      "docstring": "Draw dashboard header",
      "decorators": [],
      "calls": [
        "len",
        "getmaxyx",
        "addstr"
      ],
      "line_number": 107
    },
    "empirica.dashboard.snapshot_monitor.draw_compression_status": {
      "name": "draw_compression_status",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr",
        "snapshot",
        "y_offset"
      ],
      "returns": "",
      "docstring": "Draw compression status section",
      "decorators": [],
      "calls": [
        "estimate_memory_reliability",
        "format_bar",
        "len",
        "getmaxyx",
        "addstr",
        "get_status_label"
      ],
      "line_number": 136
    },
    "empirica.dashboard.snapshot_monitor.draw_snapshot_timeline": {
      "name": "draw_snapshot_timeline",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr",
        "snapshots",
        "y_offset"
      ],
      "returns": "",
      "docstring": "Draw snapshot timeline section",
      "decorators": [],
      "calls": [
        "abs",
        "estimate_memory_reliability",
        "items",
        "enumerate",
        "strftime",
        "join",
        "append",
        "len",
        "color_pair",
        "getmaxyx",
        "addstr",
        "get",
        "upper",
        "fromisoformat"
      ],
      "line_number": 214
    },
    "empirica.dashboard.snapshot_monitor.draw_commands": {
      "name": "draw_commands",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr",
        "y_offset"
      ],
      "returns": "",
      "docstring": "Draw command bar at bottom",
      "decorators": [],
      "calls": [
        "getmaxyx",
        "addstr"
      ],
      "line_number": 297
    },
    "empirica.dashboard.snapshot_monitor.draw_details": {
      "name": "draw_details",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr",
        "snapshot"
      ],
      "returns": "",
      "docstring": "Draw detailed metrics view",
      "decorators": [],
      "calls": [
        "draw_commands",
        "clear",
        "draw_header",
        "format_bar",
        "getmaxyx",
        "addstr",
        "get",
        "upper"
      ],
      "line_number": 322
    },
    "empirica.dashboard.snapshot_monitor.export_snapshot": {
      "name": "export_snapshot",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "snapshot"
      ],
      "returns": "",
      "docstring": "Export snapshot to JSON file",
      "decorators": [],
      "calls": [
        "absolute",
        "open",
        "str",
        "int",
        "to_json",
        "Path",
        "write",
        "time"
      ],
      "line_number": 373
    },
    "empirica.dashboard.snapshot_monitor.main_loop": {
      "name": "main_loop",
      "module": "empirica.dashboard.snapshot_monitor",
      "params": [
        "self",
        "stdscr"
      ],
      "returns": "",
      "docstring": "Main curses loop",
      "decorators": [],
      "calls": [
        "sleep",
        "draw_compression_status",
        "get_latest_snapshot",
        "nodelay",
        "ord",
        "draw_commands",
        "getch",
        "refresh",
        "clear",
        "timeout",
        "init_pair",
        "start_color",
        "getmaxyx",
        "time",
        "draw_snapshot_timeline",
        "draw_header",
        "str",
        "addstr",
        "curs_set",
        "export_snapshot",
        "color_pair",
        "draw_details",
        "get_snapshot_history"
      ],
      "line_number": 386
    },
    "empirica.core.epistemic_bus.get_global_bus": {
      "name": "get_global_bus",
      "module": "empirica.core.epistemic_bus",
      "params": [],
      "returns": "EpistemicBus",
      "docstring": "Get or create the global epistemic bus",
      "decorators": [],
      "calls": [
        "EpistemicBus"
      ],
      "line_number": 230
    },
    "empirica.core.epistemic_bus.set_global_bus": {
      "name": "set_global_bus",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "bus"
      ],
      "returns": "None",
      "docstring": "Set the global epistemic bus (useful for testing)",
      "decorators": [],
      "calls": [],
      "line_number": 238
    },
    "empirica.core.epistemic_bus.__init__": {
      "name": "__init__",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self",
        "callback"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 218
    },
    "empirica.core.epistemic_bus.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Serialize to dict for logging/transmission",
      "decorators": [],
      "calls": [],
      "line_number": 42
    },
    "empirica.core.epistemic_bus.__repr__": {
      "name": "__repr__",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 52
    },
    "empirica.core.epistemic_bus.handle_event": {
      "name": "handle_event",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self",
        "event"
      ],
      "returns": "None",
      "docstring": "Call the callback",
      "decorators": [],
      "calls": [
        "callback"
      ],
      "line_number": 221
    },
    "empirica.core.epistemic_bus.subscribe": {
      "name": "subscribe",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self",
        "observer"
      ],
      "returns": "None",
      "docstring": "Register an observer to receive epistemic events\n\nArgs:\n    observer: Observer instance implementing EpistemicObserver interface",
      "decorators": [],
      "calls": [
        "type",
        "info",
        "append",
        "isinstance",
        "TypeError"
      ],
      "line_number": 101
    },
    "empirica.core.epistemic_bus.unsubscribe": {
      "name": "unsubscribe",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self",
        "observer"
      ],
      "returns": "None",
      "docstring": "Remove an observer",
      "decorators": [],
      "calls": [
        "remove",
        "info"
      ],
      "line_number": 114
    },
    "empirica.core.epistemic_bus.publish": {
      "name": "publish",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self",
        "event"
      ],
      "returns": "None",
      "docstring": "Publish an epistemic event to all observers\n\nArgs:\n    event: The epistemic event to publish\n    \nNote: Observer errors are caught and logged but don't block other observers",
      "decorators": [],
      "calls": [
        "debug",
        "error",
        "handle_event"
      ],
      "line_number": 120
    },
    "empirica.core.epistemic_bus.get_observer_count": {
      "name": "get_observer_count",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self"
      ],
      "returns": "int",
      "docstring": "Get number of registered observers",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 145
    },
    "empirica.core.epistemic_bus.get_event_count": {
      "name": "get_event_count",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self"
      ],
      "returns": "int",
      "docstring": "Get total number of events published",
      "decorators": [],
      "calls": [],
      "line_number": 149
    },
    "empirica.core.epistemic_bus.clear_observers": {
      "name": "clear_observers",
      "module": "empirica.core.epistemic_bus",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Remove all observers (useful for testing)",
      "decorators": [],
      "calls": [
        "info",
        "clear"
      ],
      "line_number": 153
    },
    "empirica.core.thresholds._get_config": {
      "name": "_get_config",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "",
      "docstring": "Lazy-load threshold configuration",
      "decorators": [],
      "calls": [
        "get_threshold_config",
        "warning"
      ],
      "line_number": 33
    },
    "empirica.core.thresholds._get_threshold": {
      "name": "_get_threshold",
      "module": "empirica.core.thresholds",
      "params": [
        "key_path",
        "hardcoded_default"
      ],
      "returns": "Any",
      "docstring": "Get threshold value from dynamic config, fallback to hardcoded default.\n\nThis provides backwards compatibility - existing code importing constants\nwill get values from the current active profile.",
      "decorators": [],
      "calls": [
        "get",
        "_get_config"
      ],
      "line_number": 46
    },
    "empirica.core.thresholds.get_engagement_threshold": {
      "name": "get_engagement_threshold",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "float",
      "docstring": "Get current engagement threshold from active profile",
      "decorators": [],
      "calls": [
        "_get_threshold"
      ],
      "line_number": 107
    },
    "empirica.core.thresholds.get_critical_thresholds": {
      "name": "get_critical_thresholds",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "dict",
      "docstring": "Get current critical thresholds from active profile",
      "decorators": [],
      "calls": [
        "_get_threshold"
      ],
      "line_number": 112
    },
    "empirica.core.thresholds.get_cascade_max_rounds": {
      "name": "get_cascade_max_rounds",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "int",
      "docstring": "Get maximum investigation rounds from active profile",
      "decorators": [],
      "calls": [
        "_get_threshold"
      ],
      "line_number": 121
    },
    "empirica.core.thresholds.get_check_confidence_threshold": {
      "name": "get_check_confidence_threshold",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "float",
      "docstring": "Get CHECK phase confidence gate from active profile",
      "decorators": [],
      "calls": [
        "_get_threshold"
      ],
      "line_number": 126
    },
    "empirica.core.thresholds.reload_thresholds": {
      "name": "reload_thresholds",
      "module": "empirica.core.thresholds",
      "params": [],
      "returns": "",
      "docstring": "Reload thresholds from configuration.\n\nCall this after switching profiles to update module-level constants.\nNote: This only affects NEW imports. Already-imported constants won't change.",
      "decorators": [],
      "calls": [
        "get_critical_thresholds",
        "_get_threshold",
        "info"
      ],
      "line_number": 131
    },
    "empirica.core.memory_gap_detector.get_policy_loader": {
      "name": "get_policy_loader",
      "module": "empirica.core.memory_gap_detector",
      "params": [],
      "returns": "",
      "docstring": "Lazy load policy loader to avoid circular imports",
      "decorators": [],
      "calls": [
        "_get_loader",
        "warning"
      ],
      "line_number": 24
    },
    "empirica.core.memory_gap_detector.__init__": {
      "name": "__init__",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "policy"
      ],
      "returns": "",
      "docstring": "Initialize detector with policy.\n\nArgs:\n    policy: Enforcement policy configuration (optional)\n        If not provided, loads from memory_gap_policy_loader\n        {\n            'enforcement': 'infor",
      "decorators": [],
      "calls": [
        "warning",
        "get_policy",
        "info",
        "get",
        "get_policy_loader"
      ],
      "line_number": 74
    },
    "empirica.core.memory_gap_detector.detect_gaps": {
      "name": "detect_gaps",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "current_vectors",
        "breadcrumbs",
        "session_context"
      ],
      "returns": "MemoryGapReport",
      "docstring": "Detect all memory gaps between claimed and realistic knowledge.\n\nArgs:\n    current_vectors: Current epistemic vector values\n    breadcrumbs: Project breadcrumbs from project-bootstrap\n    session_cont",
      "decorators": [],
      "calls": [
        "_determine_enforcement",
        "MemoryGapReport",
        "_check_file_awareness",
        "MemoryGap",
        "_suggest_actions",
        "_check_compaction",
        "append",
        "len",
        "isinstance",
        "_calculate_expected_knowledge",
        "max",
        "get",
        "_check_findings",
        "_check_unknowns"
      ],
      "line_number": 117
    },
    "empirica.core.memory_gap_detector._check_findings": {
      "name": "_check_findings",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "findings",
        "session_context"
      ],
      "returns": "Optional[MemoryGap]",
      "docstring": "Check if findings are unreferenced.",
      "decorators": [],
      "calls": [
        "_referenced_in_session",
        "str",
        "MemoryGap",
        "get_finding_text",
        "append",
        "len",
        "isinstance",
        "get",
        "min"
      ],
      "line_number": 214
    },
    "empirica.core.memory_gap_detector._check_unknowns": {
      "name": "_check_unknowns",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "unknowns",
        "session_context"
      ],
      "returns": "Optional[MemoryGap]",
      "docstring": "Check if resolved unknowns are unincorporated.",
      "decorators": [],
      "calls": [
        "str",
        "MemoryGap",
        "append",
        "get_unknown_text",
        "len",
        "isinstance",
        "_incorporated_in_session",
        "get",
        "min"
      ],
      "line_number": 262
    },
    "empirica.core.memory_gap_detector._check_file_awareness": {
      "name": "_check_file_awareness",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "file_changes",
        "session_context"
      ],
      "returns": "Optional[MemoryGap]",
      "docstring": "Check if file changes are acknowledged.",
      "decorators": [],
      "calls": [
        "MemoryGap",
        "_mentioned_in_session",
        "append",
        "len",
        "get",
        "min"
      ],
      "line_number": 313
    },
    "empirica.core.memory_gap_detector._check_compaction": {
      "name": "_check_compaction",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "compaction_events",
        "current_vectors"
      ],
      "returns": "Optional[MemoryGap]",
      "docstring": "Check impact of memory compaction.",
      "decorators": [],
      "calls": [
        "get",
        "MemoryGap",
        "len",
        "sum"
      ],
      "line_number": 351
    },
    "empirica.core.memory_gap_detector._calculate_expected_knowledge": {
      "name": "_calculate_expected_knowledge",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "breadcrumbs",
        "session_context"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Calculate realistic knowledge baseline from breadcrumbs.\n\nUses multiple signals:\n1. Historical baseline (last session)\n2. Artifact count (findings, unknowns)\n3. Git freshness (file changes)\n4. Referen",
      "decorators": [],
      "calls": [
        "_calculate_signal_confidence",
        "len",
        "isinstance",
        "max",
        "get",
        "min"
      ],
      "line_number": 384
    },
    "empirica.core.memory_gap_detector._calculate_signal_confidence": {
      "name": "_calculate_signal_confidence",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "signals"
      ],
      "returns": "float",
      "docstring": "Calculate confidence in expected knowledge estimate.",
      "decorators": [],
      "calls": [
        "items",
        "min",
        "sum"
      ],
      "line_number": 459
    },
    "empirica.core.memory_gap_detector._determine_enforcement": {
      "name": "_determine_enforcement",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "gaps"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Determine enforcement level per gap based on policy.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 466
    },
    "empirica.core.memory_gap_detector._suggest_actions": {
      "name": "_suggest_actions",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "gaps",
        "enforcement"
      ],
      "returns": "List[str]",
      "docstring": "Suggest actions to resolve gaps.",
      "decorators": [],
      "calls": [
        "get",
        "append"
      ],
      "line_number": 489
    },
    "empirica.core.memory_gap_detector.apply_enforcement": {
      "name": "apply_enforcement",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "gap_report",
        "vectors"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Apply enforcement policy to vectors and responses.\n\nReturns:\n    {\n        'ok': bool,\n        'vectors': dict (possibly adjusted),\n        'warnings': list,\n        'corrections': dict,\n        'requ",
      "decorators": [],
      "calls": [
        "copy",
        "warning",
        "info",
        "append",
        "get"
      ],
      "line_number": 510
    },
    "empirica.core.memory_gap_detector._referenced_in_session": {
      "name": "_referenced_in_session",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "finding_id",
        "session_context"
      ],
      "returns": "bool",
      "docstring": "Check if finding was referenced in current session.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 585
    },
    "empirica.core.memory_gap_detector._incorporated_in_session": {
      "name": "_incorporated_in_session",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "unknown",
        "session_context"
      ],
      "returns": "bool",
      "docstring": "Check if resolved unknown was incorporated.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 592
    },
    "empirica.core.memory_gap_detector._mentioned_in_session": {
      "name": "_mentioned_in_session",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "self",
        "file_path",
        "session_context"
      ],
      "returns": "bool",
      "docstring": "Check if file was mentioned in session.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 599
    },
    "empirica.core.memory_gap_detector.get_finding_text": {
      "name": "get_finding_text",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "f"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "isinstance",
        "str"
      ],
      "line_number": 241
    },
    "empirica.core.memory_gap_detector.get_unknown_text": {
      "name": "get_unknown_text",
      "module": "empirica.core.memory_gap_detector",
      "params": [
        "u"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "isinstance",
        "str"
      ],
      "line_number": 291
    },
    "empirica.core.context_load_balancer.__init__": {
      "name": "__init__",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Initialize the context load balancer.",
      "decorators": [],
      "calls": [],
      "line_number": 43
    },
    "empirica.core.context_load_balancer.calculate_context_budget": {
      "name": "calculate_context_budget",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "task",
        "epistemic_state"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Calculate optimal context budget based on task and epistemic state.\n\nArgs:\n    task: Task description for keyword matching\n    epistemic_state: Dict with keys: know, do, uncertainty, context, etc.\n\nRe",
      "decorators": [],
      "calls": [
        "get",
        "_match_skills_to_task",
        "_select_mco_configs",
        "_calculate_dynamic_budget"
      ],
      "line_number": 68
    },
    "empirica.core.context_load_balancer._calculate_dynamic_budget": {
      "name": "_calculate_dynamic_budget",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "uncertainty"
      ],
      "returns": "Dict[str, int]",
      "docstring": "Calculate dynamic context budget based on uncertainty level.\n\nArgs:\n    uncertainty: Uncertainty score 0.0-1.0\n\nReturns:\n    Dict with token allocations for each component",
      "decorators": [],
      "calls": [],
      "line_number": 131
    },
    "empirica.core.context_load_balancer._select_mco_configs": {
      "name": "_select_mco_configs",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "task",
        "epistemic_state"
      ],
      "returns": "Dict[str, int]",
      "docstring": "Select MCO configs based on task keywords and epistemic state.\n\nRules:\n- \"investigate\" in task \u2192 ask_before_investigate.yaml\n- uncertainty > 0.65 \u2192 cascade_styles.yaml\n- \"multi-agent\" OR \"coordinate\" ",
      "decorators": [],
      "calls": [
        "get",
        "lower"
      ],
      "line_number": 181
    },
    "empirica.core.context_load_balancer._match_skills_to_task": {
      "name": "_match_skills_to_task",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "task"
      ],
      "returns": "List[str]",
      "docstring": "Match available skills to task via tag similarity.\n\nRules (keyword matching):\n- \"astro\" \u2192 astro-web-dev\n- \"tailwind\" OR \"css\" \u2192 tailwind-css-basics\n- \"python\" \u2192 python-basics (if exists)\n- \"security\" ",
      "decorators": [],
      "calls": [
        "append",
        "lower"
      ],
      "line_number": 237
    },
    "empirica.core.context_load_balancer.estimate_tokens": {
      "name": "estimate_tokens",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "content"
      ],
      "returns": "int",
      "docstring": "Estimate token count for content.\n\nUses simple heuristic: words * 1.3\n(Average English word is ~1.3 tokens)\n\nArgs:\n    content: Text content\n\nReturns:\n    Estimated token count",
      "decorators": [],
      "calls": [
        "len",
        "split",
        "int"
      ],
      "line_number": 279
    },
    "empirica.core.context_load_balancer.validate_budget": {
      "name": "validate_budget",
      "module": "empirica.core.context_load_balancer",
      "params": [
        "self",
        "budget",
        "max_budget"
      ],
      "returns": "bool",
      "docstring": "Validate that budget doesn't exceed maximum.\n\nArgs:\n    budget: Budget dict from calculate_context_budget()\n    max_budget: Maximum allowed tokens (default: 10k)\n\nReturns:\n    True if budget is valid,",
      "decorators": [],
      "calls": [
        "get",
        "warning"
      ],
      "line_number": 296
    },
    "empirica.core.checkpoint_signer.__init__": {
      "name": "__init__",
      "module": "empirica.core.checkpoint_signer",
      "params": [
        "self",
        "ai_id",
        "git_repo_path",
        "identity_dir"
      ],
      "returns": "",
      "docstring": "Initialize checkpoint signer\n\nArgs:\n    ai_id: AI identifier (must have identity keypair)\n    git_repo_path: Path to git repository (default: current dir)\n    identity_dir: Custom identity directory",
      "decorators": [],
      "calls": [
        "warning",
        "load_keypair",
        "cwd",
        "info",
        "AIIdentity"
      ],
      "line_number": 58
    },
    "empirica.core.checkpoint_signer.sign_checkpoint": {
      "name": "sign_checkpoint",
      "module": "empirica.core.checkpoint_signer",
      "params": [
        "self",
        "session_id",
        "phase",
        "round_num"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Sign a git checkpoint note\n\nProcess:\n1. Get checkpoint git note SHA\n2. Sign SHA with AI identity\n3. Store signature in parallel git notes namespace\n\nArgs:\n    session_id: Session UUID\n    phase: Workf",
      "decorators": [],
      "calls": [
        "str",
        "hex",
        "sign",
        "run",
        "public_key_hex",
        "isoformat",
        "info",
        "now",
        "strip",
        "encode",
        "dumps"
      ],
      "line_number": 84
    },
    "empirica.core.checkpoint_signer.verify_checkpoint": {
      "name": "verify_checkpoint",
      "module": "empirica.core.checkpoint_signer",
      "params": [
        "self",
        "session_id",
        "phase",
        "round_num",
        "public_key_hex"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Verify a signed checkpoint\n\nProcess:\n1. Load checkpoint git note SHA\n2. Load signature from git notes\n3. Verify signature with public key\n\nArgs:\n    session_id: Session UUID\n    phase: Workflow phase\n",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "run",
        "verify",
        "loads",
        "info",
        "strip",
        "get",
        "encode",
        "fromhex"
      ],
      "line_number": 197
    },
    "empirica.core.checkpoint_signer.list_signed_checkpoints": {
      "name": "list_signed_checkpoints",
      "module": "empirica.core.checkpoint_signer",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "list[Dict[str, Any]]",
      "docstring": "List all signed checkpoints\n\nArgs:\n    session_id: Filter by session (optional)\n\nReturns:\n    List of signed checkpoint info dicts",
      "decorators": [],
      "calls": [
        "int",
        "run",
        "sorted",
        "split",
        "error",
        "loads",
        "append",
        "strip",
        "len",
        "get"
      ],
      "line_number": 356
    },
    "empirica.utils.doc_code_integrity.analyze_project_integrity": {
      "name": "analyze_project_integrity",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "project_root"
      ],
      "returns": "Dict",
      "docstring": "Convenience function to run full integrity analysis\n\nReturns:\n    Dict with integrity analysis results",
      "decorators": [],
      "calls": [
        "DocCodeIntegrityAnalyzer",
        "get_detailed_gaps"
      ],
      "line_number": 199
    },
    "empirica.utils.doc_code_integrity.analyze_complete_integrity": {
      "name": "analyze_complete_integrity",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "project_root"
      ],
      "returns": "Dict",
      "docstring": "Run complete integrity analysis including deprecation and superfluity\n\nReturns comprehensive integrity report",
      "decorators": [],
      "calls": [
        "DocCodeIntegrityAnalyzer",
        "get_detailed_gaps"
      ],
      "line_number": 210
    },
    "empirica.utils.doc_code_integrity.__init__": {
      "name": "__init__",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self",
        "project_root"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "cwd",
        "Path"
      ],
      "line_number": 24
    },
    "empirica.utils.doc_code_integrity.analyze_cli_commands": {
      "name": "analyze_cli_commands",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Phase 1: Analyze CLI command integrity\n\nReturns dict with:\n- commands_in_docs: Commands mentioned in documentation\n- commands_in_code: Commands actually implemented\n- missing_code: Documented but not ",
      "decorators": [],
      "calls": [
        "list",
        "sorted",
        "_get_actual_cli_commands",
        "len",
        "_calculate_integrity_score",
        "_get_documented_cli_commands"
      ],
      "line_number": 28
    },
    "empirica.utils.doc_code_integrity._get_actual_cli_commands": {
      "name": "_get_actual_cli_commands",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self"
      ],
      "returns": "Set[str]",
      "docstring": "Get list of actually implemented CLI commands",
      "decorators": [],
      "calls": [
        "add",
        "match",
        "startswith",
        "warning",
        "run",
        "search",
        "split",
        "group",
        "strip",
        "set"
      ],
      "line_number": 58
    },
    "empirica.utils.doc_code_integrity._get_documented_cli_commands": {
      "name": "_get_documented_cli_commands",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self"
      ],
      "returns": "Set[str]",
      "docstring": "Extract CLI commands mentioned in documentation",
      "decorators": [],
      "calls": [
        "findall",
        "debug",
        "update",
        "exists",
        "compile",
        "read_text",
        "rglob",
        "set"
      ],
      "line_number": 105
    },
    "empirica.utils.doc_code_integrity._calculate_integrity_score": {
      "name": "_calculate_integrity_score",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self",
        "actual",
        "documented"
      ],
      "returns": "float",
      "docstring": "Calculate integrity score (0.0-1.0)\n\nPerfect score (1.0): All actual commands documented, no phantom commands",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 126
    },
    "empirica.utils.doc_code_integrity.get_detailed_gaps": {
      "name": "get_detailed_gaps",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Get detailed information about integrity gaps\n\nReturns structured report with file locations and context",
      "decorators": [],
      "calls": [
        "_find_command_mentions",
        "analyze_cli_commands",
        "len",
        "append"
      ],
      "line_number": 143
    },
    "empirica.utils.doc_code_integrity._find_command_mentions": {
      "name": "_find_command_mentions",
      "module": "empirica.utils.doc_code_integrity",
      "params": [
        "self",
        "command"
      ],
      "returns": "List[Dict]",
      "docstring": "Find where a command is mentioned in docs with context",
      "decorators": [],
      "calls": [
        "escape",
        "match",
        "str",
        "enumerate",
        "split",
        "append",
        "strip",
        "exists",
        "relative_to",
        "compile",
        "read_text",
        "rglob"
      ],
      "line_number": 175
    },
    "empirica.utils.deprecation_detector.analyze_deprecation": {
      "name": "analyze_deprecation",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "project_root"
      ],
      "returns": "Dict",
      "docstring": "Convenience function to run deprecation analysis\n\nReturns deprecation report",
      "decorators": [],
      "calls": [
        "generate_deprecation_report",
        "DeprecationDetector"
      ],
      "line_number": 242
    },
    "empirica.utils.deprecation_detector.__init__": {
      "name": "__init__",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self",
        "project_root"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "cwd",
        "Path"
      ],
      "line_number": 19
    },
    "empirica.utils.deprecation_detector.detect_explicit_deprecation": {
      "name": "detect_explicit_deprecation",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self"
      ],
      "returns": "List[Dict]",
      "docstring": "Phase 1: Find features with explicit deprecation markers\n\nReturns list of explicitly deprecated features with evidence",
      "decorators": [],
      "calls": [
        "str",
        "search",
        "_extract_feature_from_context",
        "split",
        "enumerate",
        "append",
        "strip",
        "exists",
        "relative_to",
        "read_text",
        "rglob"
      ],
      "line_number": 23
    },
    "empirica.utils.deprecation_detector._extract_feature_from_context": {
      "name": "_extract_feature_from_context",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self",
        "line"
      ],
      "returns": "Optional[str]",
      "docstring": "Extract feature/command name from line context",
      "decorators": [],
      "calls": [
        "search",
        "group"
      ],
      "line_number": 69
    },
    "empirica.utils.deprecation_detector.detect_unused_features": {
      "name": "detect_unused_features",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self",
        "lookback_sessions"
      ],
      "returns": "List[Dict]",
      "docstring": "Phase 2: Find features with no recent usage in artifacts\n\nRequires database access to check artifacts",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "add",
        "format",
        "str",
        "split",
        "close",
        "loads",
        "append",
        "print",
        "replace",
        "SessionDatabase",
        "_is_core_feature",
        "execute",
        "DocCodeIntegrityAnalyzer",
        "set",
        "_get_documented_cli_commands"
      ],
      "line_number": 88
    },
    "empirica.utils.deprecation_detector._is_core_feature": {
      "name": "_is_core_feature",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self",
        "feature"
      ],
      "returns": "bool",
      "docstring": "Check if feature is core (should never be flagged)",
      "decorators": [],
      "calls": [],
      "line_number": 147
    },
    "empirica.utils.deprecation_detector.detect_stale_code": {
      "name": "detect_stale_code",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self",
        "months_threshold"
      ],
      "returns": "List[Dict]",
      "docstring": "Phase 3: Find code/docs with no git activity in X months\n\nUses git log to check last modification time",
      "decorators": [],
      "calls": [
        "list",
        "glob",
        "str",
        "int",
        "run",
        "strftime",
        "append",
        "now",
        "strip",
        "relative_to",
        "timedelta",
        "fromtimestamp",
        "min",
        "print"
      ],
      "line_number": 156
    },
    "empirica.utils.deprecation_detector.generate_deprecation_report": {
      "name": "generate_deprecation_report",
      "module": "empirica.utils.deprecation_detector",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Generate comprehensive deprecation report with all signals\n\nReturns structured report for human review",
      "decorators": [],
      "calls": [
        "detect_explicit_deprecation",
        "detect_stale_code",
        "len",
        "detect_unused_features"
      ],
      "line_number": 207
    },
    "empirica.utils.session_resolver.resolve_session_id": {
      "name": "resolve_session_id",
      "module": "empirica.utils.session_resolver",
      "params": [
        "session_id_or_alias",
        "ai_id"
      ],
      "returns": "str",
      "docstring": "Resolve session ID from alias or return original UUID.\n\nArgs:\n    session_id_or_alias: UUID (full or partial), \"latest\", \"last\", or compound alias\n    ai_id: Optional AI identifier for scoped resoluti",
      "decorators": [],
      "calls": [
        "cursor",
        "startswith",
        "warning",
        "debug",
        "error",
        "split",
        "close",
        "append",
        "info",
        "fetchone",
        "SessionDatabase",
        "_resolve_partial_uuid",
        "ValueError",
        "execute"
      ],
      "line_number": 25
    },
    "empirica.utils.session_resolver._resolve_partial_uuid": {
      "name": "_resolve_partial_uuid",
      "module": "empirica.utils.session_resolver",
      "params": [
        "partial_or_full_uuid"
      ],
      "returns": "str",
      "docstring": "Resolve partial UUID (8 chars) to full UUID, or validate full UUID.\n\nArgs:\n    partial_or_full_uuid: Partial (8+ chars) or full UUID string\n\nReturns:\n    Full UUID\n\nRaises:\n    ValueError: If UUID not",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "warning",
        "debug",
        "error",
        "close",
        "len",
        "SessionDatabase",
        "ValueError",
        "execute"
      ],
      "line_number": 135
    },
    "empirica.utils.session_resolver.get_latest_session_id": {
      "name": "get_latest_session_id",
      "module": "empirica.utils.session_resolver",
      "params": [
        "ai_id",
        "active_only"
      ],
      "returns": "str",
      "docstring": "Get the most recent session ID.\n\nConvenience function equivalent to resolve_session_id(\"latest:...\").\n\nArgs:\n    ai_id: Optional AI identifier to filter by\n    active_only: If True, only return active",
      "decorators": [],
      "calls": [
        "append",
        "resolve_session_id",
        "join"
      ],
      "line_number": 188
    },
    "empirica.utils.session_resolver.is_session_alias": {
      "name": "is_session_alias",
      "module": "empirica.utils.session_resolver",
      "params": [
        "session_id_or_alias"
      ],
      "returns": "bool",
      "docstring": "Check if string is a session alias (not a UUID).\n\nArgs:\n    session_id_or_alias: String to check\n\nReturns:\n    True if it's an alias, False if it's a UUID\n\nExamples:\n    >>> is_session_alias(\"latest\")",
      "decorators": [],
      "calls": [
        "startswith"
      ],
      "line_number": 228
    },
    "empirica.utils.finding_refs.get_current_git_commit": {
      "name": "get_current_git_commit",
      "module": "empirica.utils.finding_refs",
      "params": [
        "repo_path"
      ],
      "returns": "Optional[str]",
      "docstring": "Get current git commit SHA",
      "decorators": [],
      "calls": [
        "run",
        "strip"
      ],
      "line_number": 13
    },
    "empirica.utils.finding_refs.parse_file_references": {
      "name": "parse_file_references",
      "module": "empirica.utils.finding_refs",
      "params": [
        "text"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Extract structured file references from finding text.\n\nPatterns recognized:\n- file.py:45 -> {\"file\": \"file.py\", \"line\": 45}\n- file.py:45-52 -> {\"file\": \"file.py\", \"lines\": [45, 52]}\n- path/to/file.py:",
      "decorators": [],
      "calls": [
        "append",
        "group",
        "int",
        "finditer"
      ],
      "line_number": 28
    },
    "empirica.utils.finding_refs.parse_doc_references": {
      "name": "parse_doc_references",
      "module": "empirica.utils.finding_refs",
      "params": [
        "text"
      ],
      "returns": "List[Dict[str, str]]",
      "docstring": "Extract documentation references.\n\nPatterns:\n- docs/guide.md -> {\"doc\": \"docs/guide.md\"}\n- README.md#section -> {\"doc\": \"README.md\", \"section\": \"#section\"}",
      "decorators": [],
      "calls": [
        "append",
        "group",
        "finditer"
      ],
      "line_number": 66
    },
    "empirica.utils.finding_refs.parse_url_references": {
      "name": "parse_url_references",
      "module": "empirica.utils.finding_refs",
      "params": [
        "text"
      ],
      "returns": "List[str]",
      "docstring": "Extract URLs from text",
      "decorators": [],
      "calls": [
        "list",
        "set",
        "findall"
      ],
      "line_number": 92
    },
    "empirica.utils.finding_refs.structure_finding": {
      "name": "structure_finding",
      "module": "empirica.utils.finding_refs",
      "params": [
        "finding_text",
        "commit_sha",
        "session_id",
        "check_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert plain text finding into structured format.\n\nArgs:\n    finding_text: The finding text\n    commit_sha: Git commit SHA (auto-detected if None)\n    session_id: Session ID\n    check_id: CHECK asses",
      "decorators": [],
      "calls": [
        "parse_doc_references",
        "parse_url_references",
        "get_current_git_commit",
        "parse_file_references"
      ],
      "line_number": 99
    },
    "empirica.utils.finding_refs.structure_findings_list": {
      "name": "structure_findings_list",
      "module": "empirica.utils.finding_refs",
      "params": [
        "findings",
        "commit_sha",
        "session_id",
        "check_id"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Structure a list of findings",
      "decorators": [],
      "calls": [
        "structure_finding",
        "get_current_git_commit"
      ],
      "line_number": 138
    },
    "empirica.utils.finding_refs.filter_findings_by_file": {
      "name": "filter_findings_by_file",
      "module": "empirica.utils.finding_refs",
      "params": [
        "findings",
        "filename"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Filter structured findings by filename",
      "decorators": [],
      "calls": [
        "get",
        "any"
      ],
      "line_number": 156
    },
    "empirica.utils.finding_refs.filter_findings_by_commit": {
      "name": "filter_findings_by_commit",
      "module": "empirica.utils.finding_refs",
      "params": [
        "findings",
        "commit_sha"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Filter findings by git commit",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 168
    },
    "empirica.utils.finding_refs.get_file_refs_from_findings": {
      "name": "get_file_refs_from_findings",
      "module": "empirica.utils.finding_refs",
      "params": [
        "findings"
      ],
      "returns": "List[str]",
      "docstring": "Extract all unique file references from findings",
      "decorators": [],
      "calls": [
        "list",
        "add",
        "sorted",
        "get",
        "set"
      ],
      "line_number": 176
    },
    "empirica.plugins.dashboard_spawner.get_spawner": {
      "name": "get_spawner",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [],
      "returns": "DashboardSpawner",
      "docstring": "Get singleton DashboardSpawner instance",
      "decorators": [],
      "calls": [
        "DashboardSpawner"
      ],
      "line_number": 265
    },
    "empirica.plugins.dashboard_spawner.spawn_dashboard_if_possible": {
      "name": "spawn_dashboard_if_possible",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [],
      "returns": "bool",
      "docstring": "AI-friendly: Spawn dashboard if tmux available, silent otherwise\n\nReturns:\n    True if spawned, False otherwise (not an error!)\n\nUsage (AI):\n    # At start of orchestration, give user visibility\n    s",
      "decorators": [],
      "calls": [
        "debug",
        "info",
        "get_spawner",
        "get",
        "spawn_dashboard"
      ],
      "line_number": 274
    },
    "empirica.plugins.dashboard_spawner.check_dashboard_status": {
      "name": "check_dashboard_status",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [],
      "returns": "Dict[str, Any]",
      "docstring": "Check if dashboard is running\n\nReturns:\n    Status dict",
      "decorators": [],
      "calls": [
        "get_dashboard_status",
        "get_spawner"
      ],
      "line_number": 299
    },
    "empirica.plugins.dashboard_spawner.spawn_dashboard": {
      "name": "spawn_dashboard",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self",
        "force"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Spawn dashboard in tmux (if available)\n\nArgs:\n    force: Force spawn even if dashboard already running\n\nReturns:\n    Dict with spawn status",
      "decorators": [],
      "calls": [
        "_get_current_session_name",
        "warning",
        "select_pane",
        "is_tmux_available",
        "sleep",
        "send_keys",
        "str",
        "get_dashboard_status",
        "find_where",
        "split_window",
        "error",
        "len",
        "Server",
        "get",
        "is_libtmux_available"
      ],
      "line_number": 150
    },
    "empirica.plugins.dashboard_spawner._auto_spawn_on_import": {
      "name": "_auto_spawn_on_import",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [],
      "returns": "",
      "docstring": "Auto-spawn dashboard when this module is imported by an AI\n\nPhilosophy:\n- If AI imports dashboard_spawner, it wants visibility\n- Spawn silently if possible\n- Don't fail if not possible",
      "decorators": [],
      "calls": [
        "is_tmux_available",
        "get_dashboard_status",
        "get_spawner",
        "info",
        "get",
        "spawn_dashboard",
        "is_libtmux_available"
      ],
      "line_number": 325
    },
    "empirica.plugins.dashboard_spawner.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "_find_empirica_root"
      ],
      "line_number": 48
    },
    "empirica.plugins.dashboard_spawner._find_empirica_root": {
      "name": "_find_empirica_root",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "Path",
      "docstring": "Find Empirica root directory",
      "decorators": [],
      "calls": [
        "exists",
        "cwd",
        "resolve",
        "Path"
      ],
      "line_number": 53
    },
    "empirica.plugins.dashboard_spawner.is_tmux_available": {
      "name": "is_tmux_available",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if running in tmux",
      "decorators": [],
      "calls": [
        "get",
        "bool"
      ],
      "line_number": 73
    },
    "empirica.plugins.dashboard_spawner.is_libtmux_available": {
      "name": "is_libtmux_available",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if libtmux is available",
      "decorators": [],
      "calls": [],
      "line_number": 77
    },
    "empirica.plugins.dashboard_spawner.get_dashboard_status": {
      "name": "get_dashboard_status",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get current dashboard status",
      "decorators": [],
      "calls": [
        "str",
        "is_tmux_available",
        "debug",
        "Server",
        "get",
        "is_libtmux_available"
      ],
      "line_number": 81
    },
    "empirica.plugins.dashboard_spawner._get_current_session_name": {
      "name": "_get_current_session_name",
      "module": "empirica.plugins.dashboard_spawner",
      "params": [
        "self"
      ],
      "returns": "Optional[str]",
      "docstring": "Get current tmux session name from environment or display-message",
      "decorators": [],
      "calls": [
        "get",
        "strip",
        "debug",
        "run"
      ],
      "line_number": 123
    },
    "empirica.plugins.base_plugin.initialize": {
      "name": "initialize",
      "module": "empirica.plugins.base_plugin",
      "params": [
        "self",
        "config"
      ],
      "returns": "bool",
      "docstring": "Initialize the plugin with optional configuration.\n\nArgs:\n    config: Optional plugin configuration\n    \nReturns:\n    True if initialization successful",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 15
    },
    "empirica.plugins.base_plugin.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.base_plugin",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if the plugin is healthy and operational.\n\nReturns:\n    True if healthy",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 28
    },
    "empirica.plugins.base_plugin.get_metadata": {
      "name": "get_metadata",
      "module": "empirica.plugins.base_plugin",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get plugin metadata (name, version, description, etc).\n\nReturns:\n    Metadata dictionary",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 38
    },
    "empirica.plugins.base_plugin.cleanup": {
      "name": "cleanup",
      "module": "empirica.plugins.base_plugin",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Clean up plugin resources.",
      "decorators": [
        "abstractmethod"
      ],
      "calls": [],
      "line_number": 48
    },
    "empirica.investigation.investigation_plugin.create_jira_plugin": {
      "name": "create_jira_plugin",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: JIRA integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 184
    },
    "empirica.investigation.investigation_plugin.create_confluence_plugin": {
      "name": "create_confluence_plugin",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Confluence integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 200
    },
    "empirica.investigation.investigation_plugin.create_slack_plugin": {
      "name": "create_slack_plugin",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Slack integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 215
    },
    "empirica.investigation.investigation_plugin.create_github_plugin": {
      "name": "create_github_plugin",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: GitHub integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 231
    },
    "empirica.investigation.investigation_plugin.create_database_query_plugin": {
      "name": "create_database_query_plugin",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Database query plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 247
    },
    "empirica.investigation.investigation_plugin.create_common_plugins": {
      "name": "create_common_plugins",
      "module": "empirica.investigation.investigation_plugin",
      "params": [],
      "returns": "Dict[str, InvestigationPlugin]",
      "docstring": "Create a set of commonly useful plugins",
      "decorators": [],
      "calls": [
        "create_slack_plugin",
        "create_jira_plugin",
        "create_github_plugin",
        "create_confluence_plugin"
      ],
      "line_number": 263
    },
    "empirica.investigation.investigation_plugin.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Validate plugin configuration",
      "decorators": [],
      "calls": [
        "ValueError"
      ],
      "line_number": 51
    },
    "empirica.investigation.investigation_plugin.to_capability_dict": {
      "name": "to_capability_dict",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert plugin to capability dictionary for tool mapping\n\nReturns dictionary compatible with Empirica's tool capability format",
      "decorators": [],
      "calls": [],
      "line_number": 78
    },
    "empirica.investigation.investigation_plugin.__repr__": {
      "name": "__repr__",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 178
    },
    "empirica.investigation.investigation_plugin.__init__": {
      "name": "__init__",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 136
    },
    "empirica.investigation.investigation_plugin.register": {
      "name": "register",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self",
        "plugin"
      ],
      "returns": "None",
      "docstring": "Register a plugin",
      "decorators": [],
      "calls": [
        "ValueError",
        "info"
      ],
      "line_number": 139
    },
    "empirica.investigation.investigation_plugin.unregister": {
      "name": "unregister",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self",
        "plugin_name"
      ],
      "returns": "None",
      "docstring": "Unregister a plugin",
      "decorators": [],
      "calls": [
        "info"
      ],
      "line_number": 147
    },
    "empirica.investigation.investigation_plugin.get": {
      "name": "get",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self",
        "plugin_name"
      ],
      "returns": "Optional[InvestigationPlugin]",
      "docstring": "Get a plugin by name",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 153
    },
    "empirica.investigation.investigation_plugin.list_plugins": {
      "name": "list_plugins",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "List[str]",
      "docstring": "List all registered plugin names",
      "decorators": [],
      "calls": [
        "list",
        "keys"
      ],
      "line_number": 157
    },
    "empirica.investigation.investigation_plugin.get_all_capabilities": {
      "name": "get_all_capabilities",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "Get capability dictionary for all plugins",
      "decorators": [],
      "calls": [
        "items",
        "to_capability_dict"
      ],
      "line_number": 161
    },
    "empirica.investigation.investigation_plugin.find_by_vector": {
      "name": "find_by_vector",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self",
        "vector"
      ],
      "returns": "List[InvestigationPlugin]",
      "docstring": "Find all plugins that improve a specific vector",
      "decorators": [],
      "calls": [
        "values"
      ],
      "line_number": 168
    },
    "empirica.investigation.investigation_plugin.__len__": {
      "name": "__len__",
      "module": "empirica.investigation.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 175
    },
    "empirica.metrics.token_efficiency.__init__": {
      "name": "__init__",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "session_id",
        "storage_dir"
      ],
      "returns": "",
      "docstring": "Initialize token efficiency tracker.\n\nArgs:\n    session_id: Session identifier\n    storage_dir: Directory for storing metrics",
      "decorators": [],
      "calls": [
        "mkdir",
        "Path"
      ],
      "line_number": 61
    },
    "empirica.metrics.token_efficiency.measure_context_load": {
      "name": "measure_context_load",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "phase",
        "method",
        "content",
        "content_type",
        "metadata"
      ],
      "returns": "TokenMeasurement",
      "docstring": "Measure token usage for context loading operation.\n\nArgs:\n    phase: Workflow phase (PREFLIGHT, CHECK, ACT, POSTFLIGHT)\n    method: Loading method (\"git\" or \"prompt\")\n    content: Actual content being",
      "decorators": [],
      "calls": [
        "isoformat",
        "TokenMeasurement",
        "append",
        "info",
        "_count_tokens",
        "now"
      ],
      "line_number": 95
    },
    "empirica.metrics.token_efficiency._count_tokens": {
      "name": "_count_tokens",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "text"
      ],
      "returns": "int",
      "docstring": "Estimate token count from text.\n\nUses simple approximation: len(text.split()) * 1.3\n\nNote: Phase 1.5 uses this approximation. Production will use tiktoken\nfor accurate OpenAI token counting.\n\nArgs:\n  ",
      "decorators": [],
      "calls": [
        "len",
        "split",
        "int"
      ],
      "line_number": 136
    },
    "empirica.metrics.token_efficiency.get_phase_total": {
      "name": "get_phase_total",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "phase",
        "method"
      ],
      "returns": "int",
      "docstring": "Get total tokens for a specific phase.\n\nArgs:\n    phase: Phase to sum (PREFLIGHT, CHECK, ACT, POSTFLIGHT)\n    method: Filter by method (optional)\n\nReturns:\n    Total token count for phase",
      "decorators": [],
      "calls": [
        "sum"
      ],
      "line_number": 157
    },
    "empirica.metrics.token_efficiency.get_session_total": {
      "name": "get_session_total",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "method"
      ],
      "returns": "int",
      "docstring": "Get total tokens for entire session.\n\nArgs:\n    method: Filter by method (optional)\n\nReturns:\n    Total token count",
      "decorators": [],
      "calls": [
        "sum"
      ],
      "line_number": 175
    },
    "empirica.metrics.token_efficiency.calculate_reduction": {
      "name": "calculate_reduction",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "baseline_tokens",
        "actual_tokens"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Calculate token reduction metrics.\n\nArgs:\n    baseline_tokens: Baseline (prompt-based) token count\n    actual_tokens: Actual (git-based) token count\n\nReturns:\n    Reduction metrics dictionary",
      "decorators": [],
      "calls": [
        "round"
      ],
      "line_number": 192
    },
    "empirica.metrics.token_efficiency.compare_efficiency": {
      "name": "compare_efficiency",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "baseline_session_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Compare current session efficiency against baseline.\n\nArgs:\n    baseline_session_id: Session ID for baseline comparison (optional)\n                        If not provided, uses theoretical baseline va",
      "decorators": [],
      "calls": [
        "isoformat",
        "values",
        "get_session_total",
        "now",
        "calculate_reduction",
        "get",
        "get_phase_total",
        "sum"
      ],
      "line_number": 222
    },
    "empirica.metrics.token_efficiency.export_report": {
      "name": "export_report",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "format",
        "output_path"
      ],
      "returns": "str",
      "docstring": "Export efficiency report.\n\nArgs:\n    format: Export format (\"json\", \"csv\", \"markdown\")\n    output_path: Output file path (optional, prints to stdout if None)\n\nReturns:\n    Report content as string",
      "decorators": [],
      "calls": [
        "open",
        "_format_csv_report",
        "mkdir",
        "info",
        "Path",
        "compare_efficiency",
        "_format_markdown_report",
        "ValueError",
        "write",
        "dumps"
      ],
      "line_number": 269
    },
    "empirica.metrics.token_efficiency._format_markdown_report": {
      "name": "_format_markdown_report",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "report"
      ],
      "returns": "str",
      "docstring": "Format report as Markdown.",
      "decorators": [],
      "calls": [
        "items",
        "enumerate",
        "join",
        "append",
        "len",
        "extend"
      ],
      "line_number": 310
    },
    "empirica.metrics.token_efficiency._format_csv_report": {
      "name": "_format_csv_report",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self",
        "report"
      ],
      "returns": "str",
      "docstring": "Format report as CSV.",
      "decorators": [],
      "calls": [
        "append",
        "items",
        "join"
      ],
      "line_number": 361
    },
    "empirica.metrics.token_efficiency.save_measurements": {
      "name": "save_measurements",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Save measurements to disk for persistence.",
      "decorators": [],
      "calls": [
        "open",
        "isoformat",
        "dump",
        "info",
        "now",
        "asdict"
      ],
      "line_number": 384
    },
    "empirica.metrics.token_efficiency.load_measurements": {
      "name": "load_measurements",
      "module": "empirica.metrics.token_efficiency",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Load measurements from disk.\n\nReturns:\n    True if loaded successfully, False otherwise",
      "decorators": [],
      "calls": [
        "open",
        "error",
        "TokenMeasurement",
        "info",
        "len",
        "exists",
        "load"
      ],
      "line_number": 399
    },
    "empirica.integration.empirica_action_hooks.track_component_usage": {
      "name": "track_component_usage",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "component_name"
      ],
      "returns": "",
      "docstring": "Decorator to track when Empirica components are used",
      "decorators": [],
      "calls": [
        "func",
        "update_chain_of_thought",
        "EmpiricaActionHooks",
        "update_12d_monitor",
        "wraps",
        "isinstance",
        "get"
      ],
      "line_number": 236
    },
    "empirica.integration.empirica_action_hooks.track_cascade_phase": {
      "name": "track_cascade_phase",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "phase",
        "goal"
      ],
      "returns": "",
      "docstring": "Decorator to track metacognitive cascade phases",
      "decorators": [],
      "calls": [
        "func",
        "update_chain_of_thought",
        "update_cascade_status",
        "EmpiricaActionHooks",
        "wraps",
        "get"
      ],
      "line_number": 263
    },
    "empirica.integration.empirica_action_hooks.log_cascade_phase": {
      "name": "log_cascade_phase",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "phase",
        "goal",
        "context"
      ],
      "returns": "",
      "docstring": "Directly log a cascade phase",
      "decorators": [],
      "calls": [
        "update_cascade_status",
        "EmpiricaActionHooks"
      ],
      "line_number": 296
    },
    "empirica.integration.empirica_action_hooks.log_12d_state": {
      "name": "log_12d_state",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "state"
      ],
      "returns": "",
      "docstring": "Directly log 12D monitor state",
      "decorators": [],
      "calls": [
        "update_12d_monitor",
        "EmpiricaActionHooks"
      ],
      "line_number": 301
    },
    "empirica.integration.empirica_action_hooks.log_thought": {
      "name": "log_thought",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "thought",
        "phase",
        "goal"
      ],
      "returns": "",
      "docstring": "Directly log a thought to chain",
      "decorators": [],
      "calls": [
        "update_chain_of_thought",
        "EmpiricaActionHooks"
      ],
      "line_number": 306
    },
    "empirica.integration.empirica_action_hooks.log_statusline": {
      "name": "log_statusline",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "session_id",
        "ai_id",
        "phase",
        "vectors"
      ],
      "returns": "",
      "docstring": "Directly update statusline cache for audit trail.\n\nUse this after CASCADE phase transitions to trigger statusline updates\nduring action replay.",
      "decorators": [],
      "calls": [
        "update_statusline_cache",
        "EmpiricaActionHooks"
      ],
      "line_number": 311
    },
    "empirica.integration.empirica_action_hooks.initialize_tmux_dashboard": {
      "name": "initialize_tmux_dashboard",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [],
      "returns": "",
      "docstring": "Initialize tmux dashboard for real-time monitoring",
      "decorators": [],
      "calls": [
        "create_session",
        "session_exists",
        "TMuxDashboardManager",
        "create_dashboard_window",
        "start_dashboard_monitoring",
        "print"
      ],
      "line_number": 321
    },
    "empirica.integration.empirica_action_hooks.trigger_pane_update": {
      "name": "trigger_pane_update",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "pane_name"
      ],
      "returns": "",
      "docstring": "Trigger immediate tmux pane update after JSON file change",
      "decorators": [],
      "calls": [
        "get",
        "run"
      ],
      "line_number": 354
    },
    "empirica.integration.empirica_action_hooks.update_12d_monitor": {
      "name": "update_12d_monitor",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "state"
      ],
      "returns": "",
      "docstring": "Update 12D epistemic monitor JSON feed",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "open",
        "dump",
        "print",
        "isinstance",
        "trigger_pane_update",
        "upper",
        "get",
        "lower",
        "time"
      ],
      "line_number": 31
    },
    "empirica.integration.empirica_action_hooks.update_cascade_status": {
      "name": "update_cascade_status",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "phase",
        "goal",
        "context"
      ],
      "returns": "",
      "docstring": "Update metacognitive cascade status with all 5 phases",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "open",
        "time",
        "dump",
        "trigger_pane_update",
        "get",
        "print"
      ],
      "line_number": 89
    },
    "empirica.integration.empirica_action_hooks.update_chain_of_thought": {
      "name": "update_chain_of_thought",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "thought",
        "phase",
        "goal"
      ],
      "returns": "",
      "docstring": "Update chain of thought with user-facing reasoning step",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "open",
        "dump",
        "print",
        "exists",
        "trigger_pane_update",
        "load",
        "get",
        "time"
      ],
      "line_number": 137
    },
    "empirica.integration.empirica_action_hooks.update_snapshot_status": {
      "name": "update_snapshot_status",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "snapshot"
      ],
      "returns": "",
      "docstring": "Update snapshot monitor JSON feed",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "open",
        "dump",
        "print",
        "trigger_pane_update",
        "get",
        "time"
      ],
      "line_number": 172
    },
    "empirica.integration.empirica_action_hooks.update_statusline_cache": {
      "name": "update_statusline_cache",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "session_id",
        "ai_id",
        "phase",
        "vectors"
      ],
      "returns": "",
      "docstring": "Update statusline cache for fast rendering during action replay.\n\nThis allows statusline to be triggered/refreshed automatically when\nCASCADE phases change, providing real-time audit trail.",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "open",
        "getenv",
        "dump",
        "print",
        "trigger_pane_update",
        "time"
      ],
      "line_number": 210
    },
    "empirica.integration.empirica_action_hooks.decorator": {
      "name": "decorator",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "func"
      ],
      "returns": "Callable",
      "docstring": "",
      "decorators": [],
      "calls": [
        "func",
        "update_chain_of_thought",
        "update_cascade_status",
        "EmpiricaActionHooks",
        "wraps",
        "get"
      ],
      "line_number": 265
    },
    "empirica.integration.empirica_action_hooks.wrapper": {
      "name": "wrapper",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [],
      "returns": "",
      "docstring": "",
      "decorators": [
        "wraps"
      ],
      "calls": [
        "func",
        "update_chain_of_thought",
        "update_cascade_status",
        "EmpiricaActionHooks",
        "wraps",
        "get"
      ],
      "line_number": 267
    },
    "empirica.integration.empirica_action_hooks.get_nested_value": {
      "name": "get_nested_value",
      "module": "empirica.integration.empirica_action_hooks",
      "params": [
        "data",
        "path",
        "fallback"
      ],
      "returns": "",
      "docstring": "Get nested dict value with multiple key variations",
      "decorators": [],
      "calls": [
        "get",
        "lower",
        "isinstance",
        "upper"
      ],
      "line_number": 35
    },
    "empirica.data.session_json_handler.__init__": {
      "name": "__init__",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "export_dir"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "info",
        "mkdir",
        "Path"
      ],
      "line_number": 27
    },
    "empirica.data.session_json_handler.export_session": {
      "name": "export_session",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "db",
        "session_id"
      ],
      "returns": "Path",
      "docstring": "Export complete session to JSON file",
      "decorators": [],
      "calls": [
        "get_session",
        "open",
        "get_session_cascades",
        "dump",
        "info",
        "append",
        "loads",
        "ValueError",
        "_get_cascade_assessments_summary",
        "get",
        "bool"
      ],
      "line_number": 38
    },
    "empirica.data.session_json_handler.export_cascade_graph": {
      "name": "export_cascade_graph",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "db",
        "cascade_id"
      ],
      "returns": "Path",
      "docstring": "Export cascade as graph JSON for visualization",
      "decorators": [],
      "calls": [
        "cursor",
        "open",
        "dict",
        "dump",
        "info",
        "get_cascade_assessments",
        "append",
        "next",
        "range",
        "fetchone",
        "ValueError",
        "get",
        "execute",
        "bool"
      ],
      "line_number": 105
    },
    "empirica.data.session_json_handler.load_session_context": {
      "name": "load_session_context",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Load session JSON for AI reading (session continuity)",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "exists",
        "load"
      ],
      "line_number": 248
    },
    "empirica.data.session_json_handler.read_synthesis_history": {
      "name": "read_synthesis_history",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Read synthesis history for a session from database\n\nSynthesis history tracks:\n- User inputs (expectations, requirements)\n- AI responses (interpretations, solutions)\n- Alignment scores (how well AI und",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "_extract_reasoning_summary",
        "get_session_cascades",
        "close",
        "append",
        "SessionDatabase",
        "execute"
      ],
      "line_number": 262
    },
    "empirica.data.session_json_handler._extract_reasoning_summary": {
      "name": "_extract_reasoning_summary",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "str",
      "docstring": "Extract a concise reasoning summary from assessment data\nUsed to populate ai_response field in synthesis events",
      "decorators": [],
      "calls": [
        "get",
        "len",
        "values",
        "sum"
      ],
      "line_number": 339
    },
    "empirica.data.session_json_handler.create_compact_summary": {
      "name": "create_compact_summary",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "db",
        "session_id"
      ],
      "returns": "Dict",
      "docstring": "Create compact summary for previous session context",
      "decorators": [],
      "calls": [
        "cursor",
        "get_session",
        "dict",
        "get_session_cascades",
        "len",
        "fetchone",
        "execute",
        "bool"
      ],
      "line_number": 371
    },
    "empirica.data.session_json_handler._get_cascade_assessments_summary": {
      "name": "_get_cascade_assessments_summary",
      "module": "empirica.data.session_json_handler",
      "params": [
        "self",
        "db",
        "cascade_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get summary of assessments for a cascade",
      "decorators": [],
      "calls": [
        "get_cascade_assessments",
        "append"
      ],
      "line_number": 418
    },
    "empirica.data.session_database.__init__": {
      "name": "__init__",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "db_path"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "GoalRepository",
        "ProjectRepository",
        "str",
        "get_session_db_path",
        "mkdir",
        "_create_tables",
        "Path",
        "BreadcrumbRepository",
        "info",
        "connect",
        "BranchRepository"
      ],
      "line_number": 53
    },
    "empirica.data.session_database._validate_session_id": {
      "name": "_validate_session_id",
      "module": "empirica.data.session_database",
      "params": [
        "session_id"
      ],
      "returns": "None",
      "docstring": "Validate session_id is a proper UUID format.\n\nThis ensures:\n- Session IDs are globally unique\n- Git notes refs are valid paths\n- Session aliases work correctly\n- Multi-AI coordination is safe\n\nArgs:\n ",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "UUID",
        "ValueError"
      ],
      "line_number": 77
    },
    "empirica.data.session_database._create_tables": {
      "name": "_create_tables",
      "module": "empirica.data.session_database",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create all database tables",
      "decorators": [],
      "calls": [
        "cursor",
        "commit",
        "fetchone",
        "execute",
        "_migrate_legacy_tables_to_reflexes"
      ],
      "line_number": 101
    },
    "empirica.data.session_database._migrate_legacy_tables_to_reflexes": {
      "name": "_migrate_legacy_tables_to_reflexes",
      "module": "empirica.data.session_database",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Migrate data from deprecated tables to reflexes table, then drop old tables.\n\nThis runs automatically on database initialization. It's idempotent - safe to run multiple times.\n\nMigration mapping:\n- pr",
      "decorators": [],
      "calls": [
        "cursor",
        "debug",
        "error",
        "info",
        "commit",
        "fetchone",
        "execute"
      ],
      "line_number": 796
    },
    "empirica.data.session_database.create_session": {
      "name": "create_session",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "ai_id",
        "bootstrap_level",
        "components_loaded",
        "user_id",
        "subject"
      ],
      "returns": "str",
      "docstring": "Create new session, return session_id.\n\nArgs:\n    ai_id: AI identifier (required)\n    bootstrap_level: Bootstrap level (0-4 or minimal/standard/complete) - default 0\n    components_loaded: Number of c",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "now",
        "execute",
        "uuid4"
      ],
      "line_number": 907
    },
    "empirica.data.session_database.end_session": {
      "name": "end_session",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "avg_confidence",
        "drift_detected",
        "notes"
      ],
      "returns": "",
      "docstring": "Mark session as ended",
      "decorators": [],
      "calls": [
        "cursor",
        "commit",
        "now",
        "_validate_session_id",
        "execute"
      ],
      "line_number": 934
    },
    "empirica.data.session_database.create_cascade": {
      "name": "create_cascade",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "task",
        "context",
        "goal_id",
        "goal"
      ],
      "returns": "str",
      "docstring": "Create cascade record, return cascade_id\n\nArgs:\n    session_id: Session identifier\n    task: Task description\n    context: Context dictionary\n    goal_id: Optional goal identifier\n    goal: Optional f",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "now",
        "_validate_session_id",
        "execute",
        "uuid4",
        "dumps"
      ],
      "line_number": 948
    },
    "empirica.data.session_database.update_cascade_phase": {
      "name": "update_cascade_phase",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "phase",
        "completed"
      ],
      "returns": "",
      "docstring": "Mark cascade phase as completed",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "commit",
        "ValueError"
      ],
      "line_number": 980
    },
    "empirica.data.session_database.complete_cascade": {
      "name": "complete_cascade",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "final_action",
        "final_confidence",
        "investigation_rounds",
        "duration_ms",
        "engagement_gate_passed",
        "bayesian_active",
        "drift_monitored"
      ],
      "returns": "",
      "docstring": "Mark cascade as completed with final results",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "now",
        "commit"
      ],
      "line_number": 994
    },
    "empirica.data.session_database.log_epistemic_assessment": {
      "name": "log_epistemic_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "assessment",
        "phase"
      ],
      "returns": "",
      "docstring": "DEPRECATED: Use store_vectors() instead.\n\nThis method is kept for backward compatibility with canonical structures.",
      "decorators": [],
      "calls": [
        "cursor",
        "store_vectors",
        "warning",
        "error",
        "fetchone",
        "upper",
        "execute"
      ],
      "line_number": 1017
    },
    "empirica.data.session_database.log_divergence": {
      "name": "log_divergence",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "turn_number",
        "delegate",
        "trustee",
        "divergence_score",
        "divergence_reason",
        "synthesis_needed",
        "synthesis_data"
      ],
      "returns": "",
      "docstring": "Track delegate vs trustee divergence",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "get",
        "execute",
        "uuid4",
        "dumps"
      ],
      "line_number": 1075
    },
    "empirica.data.session_database.log_bayesian_belief": {
      "name": "log_bayesian_belief",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "vector_name",
        "mean",
        "variance",
        "evidence_count",
        "prior_mean",
        "prior_variance"
      ],
      "returns": "",
      "docstring": "Track Bayesian belief updates",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "now",
        "execute",
        "uuid4"
      ],
      "line_number": 1103
    },
    "empirica.data.session_database.log_tool_execution": {
      "name": "log_tool_execution",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "round_number",
        "tool_name",
        "tool_purpose",
        "target_vector",
        "success",
        "confidence_gain",
        "information",
        "duration_ms"
      ],
      "returns": "",
      "docstring": "Track investigation tool usage",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "execute",
        "uuid4",
        "dumps"
      ],
      "line_number": 1124
    },
    "empirica.data.session_database.get_session": {
      "name": "get_session",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get session data",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "dict"
      ],
      "line_number": 1146
    },
    "empirica.data.session_database.get_session_cascades": {
      "name": "get_session_cascades",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all cascades for a session",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "dict",
        "fetchall"
      ],
      "line_number": 1153
    },
    "empirica.data.session_database.get_cascade_assessments": {
      "name": "get_cascade_assessments",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id"
      ],
      "returns": "List[Dict]",
      "docstring": "DEPRECATED: Use reflexes table queries instead.\n\nGet all assessments for a cascade from reflexes table.",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "dict",
        "fetchall"
      ],
      "line_number": 1161
    },
    "empirica.data.session_database.log_preflight_assessment": {
      "name": "log_preflight_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cascade_id",
        "prompt_summary",
        "vectors",
        "uncertainty_notes"
      ],
      "returns": "str",
      "docstring": "DEPRECATED: Use store_vectors() instead.\n\nThis method redirects to store_vectors() for backward compatibility.",
      "decorators": [],
      "calls": [
        "store_vectors"
      ],
      "line_number": 1173
    },
    "empirica.data.session_database.log_check_phase_assessment": {
      "name": "log_check_phase_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cascade_id",
        "investigation_cycle",
        "confidence",
        "decision",
        "gaps",
        "next_targets",
        "notes",
        "vectors",
        "findings",
        "remaining_unknowns"
      ],
      "returns": "str",
      "docstring": "DEPRECATED: Use store_vectors() instead.\n\nThis method redirects to store_vectors() for backward compatibility.",
      "decorators": [],
      "calls": [
        "store_vectors"
      ],
      "line_number": 1196
    },
    "empirica.data.session_database.log_postflight_assessment": {
      "name": "log_postflight_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cascade_id",
        "task_summary",
        "vectors",
        "postflight_confidence",
        "calibration_accuracy",
        "learning_notes"
      ],
      "returns": "str",
      "docstring": "DEPRECATED: Use store_vectors() instead.\n\nThis method redirects to store_vectors() for backward compatibility.",
      "decorators": [],
      "calls": [
        "store_vectors"
      ],
      "line_number": 1233
    },
    "empirica.data.session_database.log_investigation_round": {
      "name": "log_investigation_round",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cascade_id",
        "round_number",
        "tools_mentioned",
        "findings",
        "confidence_before",
        "confidence_after",
        "summary"
      ],
      "returns": "str",
      "docstring": "Log investigation round for transparency",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "execute",
        "uuid4",
        "_export_to_reflex_logs"
      ],
      "line_number": 1259
    },
    "empirica.data.session_database.log_act_phase": {
      "name": "log_act_phase",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cascade_id",
        "action_type",
        "action_rationale",
        "final_confidence",
        "goal_id"
      ],
      "returns": "str",
      "docstring": "Log ACT phase decision for transparency and audit trail",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "commit",
        "execute",
        "uuid4",
        "_export_to_reflex_logs"
      ],
      "line_number": 1307
    },
    "empirica.data.session_database._export_to_reflex_logs": {
      "name": "_export_to_reflex_logs",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase",
        "assessment_data",
        "log_dir"
      ],
      "returns": "Optional[Path]",
      "docstring": "Export assessment to reflex log format for dashboard visualization",
      "decorators": [],
      "calls": [
        "date",
        "open",
        "isoformat",
        "mkdir",
        "strftime",
        "dump",
        "Path",
        "utcnow",
        "exists",
        "get",
        "locals",
        "safe_load",
        "_determine_action"
      ],
      "line_number": 1351
    },
    "empirica.data.session_database._determine_action": {
      "name": "_determine_action",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "vectors"
      ],
      "returns": "str",
      "docstring": "Determine recommended action based on vectors",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 1541
    },
    "empirica.data.session_database.get_preflight_assessment": {
      "name": "get_preflight_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "DEPRECATED: Use get_latest_vectors(session_id, phase='PREFLIGHT') instead.\n\nThis method redirects to reflexes table for backward compatibility.",
      "decorators": [],
      "calls": [
        "get_latest_vectors"
      ],
      "line_number": 1553
    },
    "empirica.data.session_database.get_check_phase_assessments": {
      "name": "get_check_phase_assessments",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "DEPRECATED: Use get_vectors_by_phase(session_id, phase='CHECK') instead.\n\nThis method redirects to reflexes table for backward compatibility.",
      "decorators": [],
      "calls": [
        "get_vectors_by_phase"
      ],
      "line_number": 1561
    },
    "empirica.data.session_database.get_postflight_assessment": {
      "name": "get_postflight_assessment",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "DEPRECATED: Use get_latest_vectors(session_id, phase='POSTFLIGHT') instead.\n\nThis method redirects to reflexes table for backward compatibility.",
      "decorators": [],
      "calls": [
        "get_latest_vectors"
      ],
      "line_number": 1569
    },
    "empirica.data.session_database.get_preflight_vectors": {
      "name": "get_preflight_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get latest PREFLIGHT vectors for session (convenience method)",
      "decorators": [],
      "calls": [
        "get_latest_vectors"
      ],
      "line_number": 1577
    },
    "empirica.data.session_database.get_check_vectors": {
      "name": "get_check_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "cycle"
      ],
      "returns": "List[Dict]",
      "docstring": "Get CHECK phase vectors, optionally filtered by cycle",
      "decorators": [],
      "calls": [
        "get",
        "get_vectors_by_phase"
      ],
      "line_number": 1581
    },
    "empirica.data.session_database.get_postflight_vectors": {
      "name": "get_postflight_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get latest POSTFLIGHT vectors for session (convenience method)",
      "decorators": [],
      "calls": [
        "get_latest_vectors"
      ],
      "line_number": 1588
    },
    "empirica.data.session_database.get_vectors_by_phase": {
      "name": "get_vectors_by_phase",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all vectors for a specific phase",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "dict",
        "items",
        "loads",
        "append",
        "get",
        "execute"
      ],
      "line_number": 1592
    },
    "empirica.data.session_database.store_epistemic_delta": {
      "name": "store_epistemic_delta",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "cascade_id",
        "delta"
      ],
      "returns": "",
      "docstring": "Store epistemic delta (PREFLIGHT vs POSTFLIGHT) for calibration tracking\n\nArgs:\n    cascade_id: Cascade identifier\n    delta: Dictionary of epistemic changes (e.g., {'know': +0.15, 'uncertainty': -0.2",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "commit",
        "dumps"
      ],
      "line_number": 1638
    },
    "empirica.data.session_database.get_last_session_by_ai": {
      "name": "get_last_session_by_ai",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "ai_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get most recent session for an AI agent",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "dict"
      ],
      "line_number": 1657
    },
    "empirica.data.session_database.get_session_snapshot": {
      "name": "get_session_snapshot",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get git-native session snapshot showing where you left off\n\nArgs:\n    session_id: Session identifier\n    \nReturns:\n    Dictionary with git state, epistemic trajectory, learning delta, goals, sources",
      "decorators": [],
      "calls": [
        "get_session",
        "round",
        "run",
        "split",
        "append",
        "get_goal_tree",
        "strip",
        "get_epistemic_sources",
        "get_vectors_by_phase",
        "get",
        "get_latest_vectors"
      ],
      "line_number": 1669
    },
    "empirica.data.session_database.get_session_summary": {
      "name": "get_session_summary",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "detail_level"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Generate comprehensive session summary for resume/handoff\n\nArgs:\n    session_id: Session to summarize\n    detail_level: 'summary', 'detailed', or 'full'\n\nReturns:\n    Dictionary with session metadata,",
      "decorators": [],
      "calls": [
        "cursor",
        "get_session",
        "fetchall",
        "get_session_cascades",
        "loads",
        "len",
        "fetchone",
        "get",
        "execute",
        "lower"
      ],
      "line_number": 1772
    },
    "empirica.data.session_database.get_git_checkpoint": {
      "name": "get_git_checkpoint",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Retrieve checkpoint from git notes with SQLite fallback (Phase 2).\n\nPriority:\n1. Try git notes first (via GitEnhancedReflexLogger)\n2. Fall back to SQLite reflexes if git unavailable\n\nArgs:\n    session",
      "decorators": [],
      "calls": [
        "debug",
        "GitEnhancedReflexLogger",
        "_get_checkpoint_from_reflexes",
        "get_last_checkpoint"
      ],
      "line_number": 1853
    },
    "empirica.data.session_database.list_git_checkpoints": {
      "name": "list_git_checkpoints",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "limit",
        "phase"
      ],
      "returns": "List[Dict]",
      "docstring": "List all checkpoints for session from git notes (Phase 2).\n\nArgs:\n    session_id: Session identifier\n    limit: Maximum number of checkpoints to return\n    phase: Optional phase filter\n\nReturns:\n    L",
      "decorators": [],
      "calls": [
        "warning",
        "list_checkpoints",
        "debug",
        "GitEnhancedReflexLogger",
        "len"
      ],
      "line_number": 1884
    },
    "empirica.data.session_database.get_checkpoint_diff": {
      "name": "get_checkpoint_diff",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "threshold"
      ],
      "returns": "Dict",
      "docstring": "Calculate vector differences between current state and last checkpoint (Phase 2).\n\nArgs:\n    session_id: Session identifier\n    threshold: Significance threshold for reporting changes\n\nReturns:\n    Di",
      "decorators": [],
      "calls": [
        "abs",
        "keys",
        "GitEnhancedReflexLogger",
        "_get_latest_vectors",
        "append",
        "get",
        "get_last_checkpoint"
      ],
      "line_number": 1911
    },
    "empirica.data.session_database._get_checkpoint_from_reflexes": {
      "name": "_get_checkpoint_from_reflexes",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase"
      ],
      "returns": "Optional[Dict]",
      "docstring": "SQLite fallback for checkpoint retrieval (Phase 2)",
      "decorators": [],
      "calls": [
        "cursor",
        "loads",
        "fetchone",
        "execute",
        "lower"
      ],
      "line_number": 1970
    },
    "empirica.data.session_database._get_latest_vectors": {
      "name": "_get_latest_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict[str, float]]",
      "docstring": "Get latest epistemic vectors for session (Phase 2)",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "fetchone",
        "loads"
      ],
      "line_number": 2016
    },
    "empirica.data.session_database.store_vectors": {
      "name": "store_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase",
        "vectors",
        "cascade_id",
        "round_num",
        "metadata",
        "reasoning"
      ],
      "returns": "",
      "docstring": "Store epistemic vectors in the reflexes table\n\nArgs:\n    session_id: Session identifier\n    phase: Current phase (PREFLIGHT, CHECK, ACT, POSTFLIGHT)\n    vectors: Dictionary of 13 epistemic vectors\n   ",
      "decorators": [],
      "calls": [
        "cursor",
        "dumps",
        "update",
        "commit",
        "append",
        "isinstance",
        "get",
        "execute",
        "time"
      ],
      "line_number": 2050
    },
    "empirica.data.session_database.get_latest_vectors": {
      "name": "get_latest_vectors",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "phase"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get the latest epistemic vectors for a session from the reflexes table\n\nArgs:\n    session_id: Session identifier\n    phase: Optional phase filter\n\nReturns:\n    Dictionary with vectors, metadata, times",
      "decorators": [],
      "calls": [
        "cursor",
        "dict",
        "loads",
        "append",
        "float",
        "fetchone",
        "get",
        "execute"
      ],
      "line_number": 2105
    },
    "empirica.data.session_database.get_findings_by_file": {
      "name": "get_findings_by_file",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "filename",
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all findings mentioning a specific file",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "loads",
        "append",
        "isinstance",
        "get",
        "execute"
      ],
      "line_number": 2161
    },
    "empirica.data.session_database.get_findings_by_commit": {
      "name": "get_findings_by_commit",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "commit_sha"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all findings from a specific git commit",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "startswith",
        "loads",
        "append",
        "get",
        "execute"
      ],
      "line_number": 2204
    },
    "empirica.data.session_database.create_goal": {
      "name": "create_goal",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "objective",
        "scope_breadth",
        "scope_duration",
        "scope_coordination"
      ],
      "returns": "str",
      "docstring": "Create a new goal for this session (delegates to GoalRepository)\n\nArgs:\n    session_id: Session UUID\n    objective: What are you trying to accomplish?\n    scope_breadth: 0.0-1.0 (0=single file, 1=enti",
      "decorators": [],
      "calls": [
        "create_goal"
      ],
      "line_number": 2232
    },
    "empirica.data.session_database.create_subtask": {
      "name": "create_subtask",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "goal_id",
        "description",
        "importance"
      ],
      "returns": "str",
      "docstring": "Create a subtask within a goal (delegates to GoalRepository)\n\nArgs:\n    goal_id: Parent goal UUID\n    description: What are you investigating/implementing?\n    importance: 'critical' | 'high' | 'mediu",
      "decorators": [],
      "calls": [
        "create_subtask"
      ],
      "line_number": 2249
    },
    "empirica.data.session_database.update_subtask_findings": {
      "name": "update_subtask_findings",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "subtask_id",
        "findings"
      ],
      "returns": "",
      "docstring": "Update findings for a subtask (delegates to GoalRepository)\n\nArgs:\n    subtask_id: Subtask UUID\n    findings: List of finding strings",
      "decorators": [],
      "calls": [
        "update_subtask_findings"
      ],
      "line_number": 2262
    },
    "empirica.data.session_database.update_subtask_unknowns": {
      "name": "update_subtask_unknowns",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "subtask_id",
        "unknowns"
      ],
      "returns": "",
      "docstring": "Update unknowns for a subtask (delegates to GoalRepository)\n\nArgs:\n    subtask_id: Subtask UUID\n    unknowns: List of unknown strings",
      "decorators": [],
      "calls": [
        "update_subtask_unknowns"
      ],
      "line_number": 2271
    },
    "empirica.data.session_database.update_subtask_dead_ends": {
      "name": "update_subtask_dead_ends",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "subtask_id",
        "dead_ends"
      ],
      "returns": "",
      "docstring": "Update dead ends for a subtask (delegates to GoalRepository)\n\nArgs:\n    subtask_id: Subtask UUID\n    dead_ends: List of dead end strings (e.g., \"Attempted X - blocked by Y\")",
      "decorators": [],
      "calls": [
        "update_subtask_dead_ends"
      ],
      "line_number": 2280
    },
    "empirica.data.session_database.complete_subtask": {
      "name": "complete_subtask",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "subtask_id",
        "evidence"
      ],
      "returns": "",
      "docstring": "Mark subtask as completed with evidence (delegates to GoalRepository)\n\nArgs:\n    subtask_id: Subtask UUID\n    evidence: Evidence of completion (e.g., \"Documented in design doc\", \"PR merged\")",
      "decorators": [],
      "calls": [
        "complete_subtask"
      ],
      "line_number": 2289
    },
    "empirica.data.session_database.get_all_sessions": {
      "name": "get_all_sessions",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "ai_id",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "List all sessions, optionally filtered by ai_id\n\nArgs:\n    ai_id: Optional AI identifier to filter by\n    limit: Maximum number of sessions to return (default 50)\n\nReturns:\n    List of session diction",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "dict",
        "fetchall"
      ],
      "line_number": 2298
    },
    "empirica.data.session_database.get_goal_tree": {
      "name": "get_goal_tree",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get complete goal tree for a session (delegates to GoalRepository)\n\nReturns list of goals with nested subtasks\n\nArgs:\n    session_id: Session UUID\n\nReturns:\n    List of goal dicts, each with 'subtasks",
      "decorators": [],
      "calls": [
        "get_goal_tree"
      ],
      "line_number": 2326
    },
    "empirica.data.session_database.query_unknowns_summary": {
      "name": "query_unknowns_summary",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Dict",
      "docstring": "Get summary of all unknowns in a session (delegates to GoalRepository)\n\nArgs:\n    session_id: Session UUID\n\nReturns:\n    Dict with total_unknowns count and breakdown by goal",
      "decorators": [],
      "calls": [
        "query_unknowns_summary"
      ],
      "line_number": 2339
    },
    "empirica.data.session_database.create_branch": {
      "name": "create_branch",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "branch_name",
        "investigation_path",
        "git_branch_name",
        "preflight_vectors"
      ],
      "returns": "str",
      "docstring": "Create a new investigation branch (delegates to BranchRepository)\n\nArgs:\n    session_id: Session UUID\n    branch_name: Human-readable branch name\n    investigation_path: What is being investigated (e.",
      "decorators": [],
      "calls": [
        "create_branch"
      ],
      "line_number": 2352
    },
    "empirica.data.session_database.checkpoint_branch": {
      "name": "checkpoint_branch",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "branch_id",
        "postflight_vectors",
        "tokens_spent",
        "time_spent_minutes"
      ],
      "returns": "bool",
      "docstring": "Checkpoint a branch after investigation (delegates to BranchRepository)\n\nArgs:\n    branch_id: Branch ID\n    postflight_vectors: Epistemic vectors after investigation\n    tokens_spent: Tokens used in i",
      "decorators": [],
      "calls": [
        "checkpoint_branch"
      ],
      "line_number": 2369
    },
    "empirica.data.session_database.calculate_branch_merge_score": {
      "name": "calculate_branch_merge_score",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "branch_id"
      ],
      "returns": "Dict",
      "docstring": "Calculate epistemic merge score for a branch (delegates to BranchRepository)\n\nScore = (learning_delta \u00d7 quality \u00d7 confidence) / cost_penalty\nWhere: confidence = 1 - uncertainty (uncertainty is a DAMPE",
      "decorators": [],
      "calls": [
        "calculate_branch_merge_score"
      ],
      "line_number": 2385
    },
    "empirica.data.session_database.merge_branches": {
      "name": "merge_branches",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "investigation_round"
      ],
      "returns": "Dict",
      "docstring": "Auto-merge best branch based on epistemic scores (delegates to BranchRepository)\n\nReturns:\n    Dict with winning_branch_id, merge_decision_id, rationale",
      "decorators": [],
      "calls": [
        "merge_branches"
      ],
      "line_number": 2396
    },
    "empirica.data.session_database.create_project": {
      "name": "create_project",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "name",
        "description",
        "repos"
      ],
      "returns": "str",
      "docstring": "Create a new project (delegates to ProjectRepository)\n\nArgs:\n    name: Project name (e.g., \"Empirica Core\")\n    description: Project description\n    repos: List of repository names (e.g., [\"empirica\",",
      "decorators": [],
      "calls": [
        "create_project"
      ],
      "line_number": 2404
    },
    "empirica.data.session_database.get_project": {
      "name": "get_project",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get project data (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "get_project"
      ],
      "line_number": 2422
    },
    "empirica.data.session_database.resolve_project_id": {
      "name": "resolve_project_id",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id_or_name"
      ],
      "returns": "Optional[str]",
      "docstring": "Resolve project name or UUID to UUID (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "resolve_project_id"
      ],
      "line_number": 2426
    },
    "empirica.data.session_database.link_session_to_project": {
      "name": "link_session_to_project",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "project_id"
      ],
      "returns": "",
      "docstring": "Link a session to a project (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "link_session_to_project",
        "_validate_session_id"
      ],
      "line_number": 2430
    },
    "empirica.data.session_database.get_project_sessions": {
      "name": "get_project_sessions",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all sessions for a project (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "get_project_sessions"
      ],
      "line_number": 2435
    },
    "empirica.data.session_database.aggregate_project_learning_deltas": {
      "name": "aggregate_project_learning_deltas",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Compute total epistemic learning across all project sessions (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "aggregate_project_learning_deltas"
      ],
      "line_number": 2439
    },
    "empirica.data.session_database.create_project_handoff": {
      "name": "create_project_handoff",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "project_summary",
        "key_decisions",
        "patterns_discovered",
        "remaining_work"
      ],
      "returns": "str",
      "docstring": "Create project-level handoff report (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "create_project_handoff"
      ],
      "line_number": 2443
    },
    "empirica.data.session_database.get_latest_project_handoff": {
      "name": "get_latest_project_handoff",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get the most recent project handoff (delegates to ProjectRepository)",
      "decorators": [],
      "calls": [
        "get_latest_project_handoff"
      ],
      "line_number": 2456
    },
    "empirica.data.session_database.bootstrap_project_breadcrumbs": {
      "name": "bootstrap_project_breadcrumbs",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "mode",
        "project_root",
        "check_integrity",
        "task_description",
        "epistemic_state",
        "context_to_inject",
        "subject"
      ],
      "returns": "Dict",
      "docstring": "Generate epistemic breadcrumbs for starting a new session on existing project.\n\nArgs:\n    project_id: Project identifier (UUID or project name)\n    mode: \"session_start\" (fast, recent items) or \"live\"",
      "decorators": [],
      "calls": [
        "getcwd",
        "ContextLoadBalancer",
        "execute",
        "_generate_context_markdown",
        "fetchall",
        "get_project_unknowns",
        "open",
        "calculate_context_budget",
        "dict",
        "get_session_snapshot",
        "items",
        "len",
        "get_epistemic_sources",
        "get_project_reference_docs",
        "get",
        "DocCodeIntegrityAnalyzer",
        "list",
        "get_project_dead_ends",
        "resolve_project_id",
        "get_project",
        "get_latest_project_handoff",
        "append",
        "replace",
        "endswith",
        "cursor",
        "listdir",
        "str",
        "get_detailed_gaps",
        "join",
        "loads",
        "get_project_findings",
        "exists",
        "bool",
        "safe_load"
      ],
      "line_number": 2460
    },
    "empirica.data.session_database._generate_context_markdown": {
      "name": "_generate_context_markdown",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "breadcrumbs"
      ],
      "returns": "str",
      "docstring": "Generate markdown-formatted context for injection into AI prompts.\n\nArgs:\n    breadcrumbs: Dictionary from bootstrap_project_breadcrumbs()\n\nReturns:\n    Markdown string formatted for context injection",
      "decorators": [],
      "calls": [
        "get",
        "join",
        "append"
      ],
      "line_number": 2777
    },
    "empirica.data.session_database.log_finding": {
      "name": "log_finding",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "session_id",
        "finding",
        "goal_id",
        "subtask_id",
        "subject"
      ],
      "returns": "str",
      "docstring": "Log a project finding (what was learned/discovered)",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "info",
        "commit",
        "dumps",
        "execute",
        "uuid4",
        "time"
      ],
      "line_number": 2907
    },
    "empirica.data.session_database.log_unknown": {
      "name": "log_unknown",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "session_id",
        "unknown",
        "goal_id",
        "subtask_id",
        "subject"
      ],
      "returns": "str",
      "docstring": "Log a project unknown (what's still unclear)",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "info",
        "commit",
        "dumps",
        "execute",
        "uuid4",
        "time"
      ],
      "line_number": 2941
    },
    "empirica.data.session_database.resolve_unknown": {
      "name": "resolve_unknown",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "unknown_id",
        "resolved_by"
      ],
      "returns": "",
      "docstring": "Mark an unknown as resolved (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "resolve_unknown"
      ],
      "line_number": 2975
    },
    "empirica.data.session_database.log_dead_end": {
      "name": "log_dead_end",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "session_id",
        "approach",
        "why_failed",
        "goal_id",
        "subtask_id",
        "subject"
      ],
      "returns": "str",
      "docstring": "Log a project dead end (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "log_dead_end"
      ],
      "line_number": 2979
    },
    "empirica.data.session_database.add_reference_doc": {
      "name": "add_reference_doc",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "doc_path",
        "doc_type",
        "description"
      ],
      "returns": "str",
      "docstring": "Add a reference document to project (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "add_reference_doc"
      ],
      "line_number": 2993
    },
    "empirica.data.session_database.get_project_findings": {
      "name": "get_project_findings",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "limit",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all findings for a project (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "get_project_findings"
      ],
      "line_number": 3003
    },
    "empirica.data.session_database.get_project_unknowns": {
      "name": "get_project_unknowns",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "resolved",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get unknowns for a project (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "get_project_unknowns"
      ],
      "line_number": 3007
    },
    "empirica.data.session_database.get_project_dead_ends": {
      "name": "get_project_dead_ends",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "limit",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all dead ends for a project (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "get_project_dead_ends"
      ],
      "line_number": 3011
    },
    "empirica.data.session_database.get_project_reference_docs": {
      "name": "get_project_reference_docs",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all reference docs for a project (delegates to BreadcrumbRepository)",
      "decorators": [],
      "calls": [
        "get_project_reference_docs"
      ],
      "line_number": 3015
    },
    "empirica.data.session_database.add_epistemic_source": {
      "name": "add_epistemic_source",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "source_type",
        "title",
        "session_id",
        "source_url",
        "description",
        "confidence",
        "epistemic_layer",
        "supports_vectors",
        "related_findings",
        "discovered_by_ai",
        "source_metadata"
      ],
      "returns": "str",
      "docstring": "Add an epistemic source to ground project knowledge\n\nArgs:\n    project_id: Project identifier\n    source_type: Type of source ('url', 'doc', 'code_ref', 'paper', 'api_doc', 'git_commit', 'chat_transcr",
      "decorators": [],
      "calls": [
        "cursor",
        "str",
        "info",
        "commit",
        "now",
        "execute",
        "uuid4",
        "dumps"
      ],
      "line_number": 3019
    },
    "empirica.data.session_database.get_epistemic_sources": {
      "name": "get_epistemic_sources",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "project_id",
        "session_id",
        "source_type",
        "min_confidence",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "Get epistemic sources for a project\n\nArgs:\n    project_id: Project identifier\n    session_id: Optional filter by session\n    source_type: Optional filter by type\n    min_confidence: Minimum confidence",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "dict",
        "loads",
        "append",
        "get",
        "execute"
      ],
      "line_number": 3080
    },
    "empirica.data.session_database.log_mistake": {
      "name": "log_mistake",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "mistake",
        "why_wrong",
        "cost_estimate",
        "root_cause_vector",
        "prevention",
        "goal_id"
      ],
      "returns": "str",
      "docstring": "Log a mistake for learning (delegates to BreadcrumbRepository)\n\nArgs:\n    session_id: Session identifier\n    mistake: What was done wrong\n    why_wrong: Explanation of why it was wrong\n    cost_estima",
      "decorators": [],
      "calls": [
        "log_mistake"
      ],
      "line_number": 3138
    },
    "empirica.data.session_database.get_mistakes": {
      "name": "get_mistakes",
      "module": "empirica.data.session_database",
      "params": [
        "self",
        "session_id",
        "goal_id",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "Retrieve logged mistakes (delegates to BreadcrumbRepository)\n\nArgs:\n    session_id: Optional filter by session\n    goal_id: Optional filter by goal\n    limit: Maximum number of results\n\nReturns:\n    L",
      "decorators": [],
      "calls": [
        "get_mistakes"
      ],
      "line_number": 3165
    },
    "empirica.data.session_database.close": {
      "name": "close",
      "module": "empirica.data.session_database",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Close database connection",
      "decorators": [],
      "calls": [
        "close"
      ],
      "line_number": 3183
    },
    "empirica.data.repositories.goals.create_goal": {
      "name": "create_goal",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "session_id",
        "objective",
        "scope_breadth",
        "scope_duration",
        "scope_coordination",
        "beads_issue_id"
      ],
      "returns": "str",
      "docstring": "Create a new goal for this session\n\nArgs:\n    session_id: Session UUID\n    objective: What are you trying to accomplish?\n    scope_breadth: 0.0-1.0 (0=single file, 1=entire codebase)\n    scope_duratio",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 19
    },
    "empirica.data.repositories.goals.create_subtask": {
      "name": "create_subtask",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "goal_id",
        "description",
        "importance"
      ],
      "returns": "str",
      "docstring": "Create a subtask within a goal\n\nArgs:\n    goal_id: Parent goal UUID\n    description: What are you investigating/implementing?\n    importance: 'critical' | 'high' | 'medium' | 'low'\n\nReturns:\n    subta",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 52
    },
    "empirica.data.repositories.goals.update_subtask_findings": {
      "name": "update_subtask_findings",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "subtask_id",
        "findings"
      ],
      "returns": "",
      "docstring": "Update findings for a subtask\n\nArgs:\n    subtask_id: Subtask UUID\n    findings: List of finding strings",
      "decorators": [],
      "calls": [
        "loads",
        "commit",
        "fetchone",
        "ValueError",
        "dumps",
        "_execute"
      ],
      "line_number": 80
    },
    "empirica.data.repositories.goals.update_subtask_unknowns": {
      "name": "update_subtask_unknowns",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "subtask_id",
        "unknowns"
      ],
      "returns": "",
      "docstring": "Update unknowns for a subtask\n\nArgs:\n    subtask_id: Subtask UUID\n    unknowns: List of unknown strings",
      "decorators": [],
      "calls": [
        "loads",
        "commit",
        "fetchone",
        "ValueError",
        "dumps",
        "_execute"
      ],
      "line_number": 102
    },
    "empirica.data.repositories.goals.update_subtask_dead_ends": {
      "name": "update_subtask_dead_ends",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "subtask_id",
        "dead_ends"
      ],
      "returns": "",
      "docstring": "Update dead ends for a subtask\n\nArgs:\n    subtask_id: Subtask UUID\n    dead_ends: List of dead end strings (e.g., \"Attempted X - blocked by Y\")",
      "decorators": [],
      "calls": [
        "loads",
        "commit",
        "fetchone",
        "ValueError",
        "dumps",
        "_execute"
      ],
      "line_number": 124
    },
    "empirica.data.repositories.goals.complete_subtask": {
      "name": "complete_subtask",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "subtask_id",
        "evidence"
      ],
      "returns": "",
      "docstring": "Mark subtask as completed with evidence\n\nArgs:\n    subtask_id: Subtask UUID\n    evidence: Evidence of completion (e.g., \"Documented in design doc\", \"PR merged\")",
      "decorators": [],
      "calls": [
        "commit",
        "time",
        "_execute"
      ],
      "line_number": 146
    },
    "empirica.data.repositories.goals.get_goal_tree": {
      "name": "get_goal_tree",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get complete goal tree for a session\n\nReturns list of goals with nested subtasks\n\nArgs:\n    session_id: Session UUID\n\nReturns:\n    List of goal dicts, each with 'subtasks' list",
      "decorators": [],
      "calls": [
        "fetchall",
        "loads",
        "append",
        "get",
        "_execute"
      ],
      "line_number": 163
    },
    "empirica.data.repositories.goals.query_unknowns_summary": {
      "name": "query_unknowns_summary",
      "module": "empirica.data.repositories.goals",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Dict",
      "docstring": "Get summary of all unknowns in a session (for CHECK decisions)\n\nArgs:\n    session_id: Session UUID\n\nReturns:\n    Dict with total_unknowns count and breakdown by goal",
      "decorators": [],
      "calls": [
        "fetchall",
        "list",
        "values",
        "loads",
        "len",
        "get",
        "_execute"
      ],
      "line_number": 216
    },
    "empirica.data.repositories.branches.create_branch": {
      "name": "create_branch",
      "module": "empirica.data.repositories.branches",
      "params": [
        "self",
        "session_id",
        "branch_name",
        "investigation_path",
        "git_branch_name",
        "preflight_vectors"
      ],
      "returns": "str",
      "docstring": "Create a new investigation branch\n\nArgs:\n    session_id: Session UUID\n    branch_name: Human-readable branch name\n    investigation_path: What is being investigated (e.g., 'oauth2')\n    git_branch_nam",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 19
    },
    "empirica.data.repositories.branches.checkpoint_branch": {
      "name": "checkpoint_branch",
      "module": "empirica.data.repositories.branches",
      "params": [
        "self",
        "branch_id",
        "postflight_vectors",
        "tokens_spent",
        "time_spent_minutes"
      ],
      "returns": "bool",
      "docstring": "Checkpoint a branch after investigation\n\nArgs:\n    branch_id: Branch ID\n    postflight_vectors: Epistemic vectors after investigation\n    tokens_spent: Tokens used in investigation\n    time_spent_minu",
      "decorators": [],
      "calls": [
        "commit",
        "_execute",
        "time",
        "dumps"
      ],
      "line_number": 47
    },
    "empirica.data.repositories.branches.calculate_branch_merge_score": {
      "name": "calculate_branch_merge_score",
      "module": "empirica.data.repositories.branches",
      "params": [
        "self",
        "branch_id"
      ],
      "returns": "Dict",
      "docstring": "Calculate epistemic merge score for a branch\n\nScore = (learning_delta \u00d7 quality \u00d7 confidence) / cost_penalty\nWhere: confidence = 1 - uncertainty (uncertainty is a DAMPENER)\n\nReturns:\n    Dict with mer",
      "decorators": [],
      "calls": [
        "round",
        "loads",
        "append",
        "len",
        "fetchone",
        "max",
        "get",
        "_execute",
        "sum"
      ],
      "line_number": 72
    },
    "empirica.data.repositories.branches.merge_branches": {
      "name": "merge_branches",
      "module": "empirica.data.repositories.branches",
      "params": [
        "self",
        "session_id",
        "investigation_round"
      ],
      "returns": "Dict",
      "docstring": "Auto-merge best branch based on epistemic scores\n\nReturns:\n    Dict with winning_branch_id, merge_decision_id, rationale",
      "decorators": [],
      "calls": [
        "fetchall",
        "dumps",
        "str",
        "round",
        "calculate_branch_merge_score",
        "time",
        "commit",
        "append",
        "len",
        "max",
        "get",
        "uuid4",
        "_execute"
      ],
      "line_number": 127
    },
    "empirica.data.repositories.base.__init__": {
      "name": "__init__",
      "module": "empirica.data.repositories.base",
      "params": [
        "self",
        "conn"
      ],
      "returns": "",
      "docstring": "Initialize repository with shared SQLite connection.\n\nArgs:\n    conn: SQLite connection (shared across all repositories)",
      "decorators": [],
      "calls": [],
      "line_number": 20
    },
    "empirica.data.repositories.base._execute": {
      "name": "_execute",
      "module": "empirica.data.repositories.base",
      "params": [
        "self",
        "query",
        "params"
      ],
      "returns": "sqlite3.Cursor",
      "docstring": "Execute a SQL query with optional parameters.\n\nArgs:\n    query: SQL query string\n    params: Optional tuple of query parameters\n\nReturns:\n    Cursor object with results",
      "decorators": [],
      "calls": [
        "cursor",
        "execute"
      ],
      "line_number": 30
    },
    "empirica.data.repositories.base._execute_many": {
      "name": "_execute_many",
      "module": "empirica.data.repositories.base",
      "params": [
        "self",
        "query",
        "params_list"
      ],
      "returns": "sqlite3.Cursor",
      "docstring": "Execute a SQL query multiple times with different parameters.\n\nArgs:\n    query: SQL query string\n    params_list: List of parameter tuples\n\nReturns:\n    Cursor object",
      "decorators": [],
      "calls": [
        "cursor",
        "executemany"
      ],
      "line_number": 48
    },
    "empirica.data.repositories.base.commit": {
      "name": "commit",
      "module": "empirica.data.repositories.base",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Commit the current transaction",
      "decorators": [],
      "calls": [
        "commit"
      ],
      "line_number": 63
    },
    "empirica.data.repositories.base.rollback": {
      "name": "rollback",
      "module": "empirica.data.repositories.base",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Rollback the current transaction",
      "decorators": [],
      "calls": [
        "rollback"
      ],
      "line_number": 67
    },
    "empirica.data.repositories.breadcrumbs.log_finding": {
      "name": "log_finding",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "session_id",
        "finding",
        "goal_id",
        "subtask_id"
      ],
      "returns": "str",
      "docstring": "Log a project finding (what was learned/discovered)",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 22
    },
    "empirica.data.repositories.breadcrumbs.log_unknown": {
      "name": "log_unknown",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "session_id",
        "unknown",
        "goal_id",
        "subtask_id"
      ],
      "returns": "str",
      "docstring": "Log a project unknown (what's still unclear)",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 54
    },
    "empirica.data.repositories.breadcrumbs.resolve_unknown": {
      "name": "resolve_unknown",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "unknown_id",
        "resolved_by"
      ],
      "returns": "",
      "docstring": "Mark an unknown as resolved",
      "decorators": [],
      "calls": [
        "commit",
        "time",
        "_execute",
        "info"
      ],
      "line_number": 86
    },
    "empirica.data.repositories.breadcrumbs.log_dead_end": {
      "name": "log_dead_end",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "session_id",
        "approach",
        "why_failed",
        "goal_id",
        "subtask_id",
        "subject"
      ],
      "returns": "str",
      "docstring": "Log a project dead end (what didn't work)",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 97
    },
    "empirica.data.repositories.breadcrumbs.add_reference_doc": {
      "name": "add_reference_doc",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "doc_path",
        "doc_type",
        "description"
      ],
      "returns": "str",
      "docstring": "Add a reference document to project",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 132
    },
    "empirica.data.repositories.breadcrumbs.get_project_findings": {
      "name": "get_project_findings",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "limit",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all findings for a project, optionally filtered by subject",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 163
    },
    "empirica.data.repositories.breadcrumbs.get_project_unknowns": {
      "name": "get_project_unknowns",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "resolved",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get unknowns for a project (optionally filter by resolved status and subject)",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 176
    },
    "empirica.data.repositories.breadcrumbs.get_project_dead_ends": {
      "name": "get_project_dead_ends",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id",
        "limit",
        "subject"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all dead ends for a project, optionally filtered by subject",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 206
    },
    "empirica.data.repositories.breadcrumbs.get_project_reference_docs": {
      "name": "get_project_reference_docs",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all reference docs for a project",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 219
    },
    "empirica.data.repositories.breadcrumbs.log_mistake": {
      "name": "log_mistake",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "session_id",
        "mistake",
        "why_wrong",
        "cost_estimate",
        "root_cause_vector",
        "prevention",
        "goal_id"
      ],
      "returns": "str",
      "docstring": "Log a mistake for learning and future prevention.\n\nArgs:\n    session_id: Session identifier\n    mistake: What was done wrong\n    why_wrong: Explanation of why it was wrong\n    cost_estimate: Estimated",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 228
    },
    "empirica.data.repositories.breadcrumbs.get_mistakes": {
      "name": "get_mistakes",
      "module": "empirica.data.repositories.breadcrumbs",
      "params": [
        "self",
        "session_id",
        "goal_id",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "Retrieve logged mistakes.\n\nArgs:\n    session_id: Optional filter by session\n    goal_id: Optional filter by goal\n    limit: Maximum number of results\n\nReturns:\n    List of mistake dictionaries",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 281
    },
    "empirica.data.repositories.projects.create_project": {
      "name": "create_project",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "name",
        "description",
        "repos"
      ],
      "returns": "str",
      "docstring": "Create a new project for multi-repo/multi-session tracking.\n\nArgs:\n    name: Project name (e.g., \"Empirica Core\")\n    description: Project description\n    repos: List of repository names (e.g., [\"empi",
      "decorators": [],
      "calls": [
        "str",
        "time",
        "info",
        "commit",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 24
    },
    "empirica.data.repositories.projects.get_project": {
      "name": "get_project",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get project data",
      "decorators": [],
      "calls": [
        "dict",
        "_execute",
        "fetchone"
      ],
      "line_number": 64
    },
    "empirica.data.repositories.projects.get_project_by_name": {
      "name": "get_project_by_name",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "name"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get project data by name (case-insensitive)",
      "decorators": [],
      "calls": [
        "dict",
        "_execute",
        "fetchone"
      ],
      "line_number": 70
    },
    "empirica.data.repositories.projects.resolve_project_id": {
      "name": "resolve_project_id",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id_or_name"
      ],
      "returns": "Optional[str]",
      "docstring": "Resolve project identifier to UUID.\nAccepts either UUID or project name.\n\nArgs:\n    project_id_or_name: UUID or project name\n    \nReturns:\n    Project UUID if found, None otherwise",
      "decorators": [],
      "calls": [
        "get_project_by_name",
        "get_project"
      ],
      "line_number": 76
    },
    "empirica.data.repositories.projects.link_session_to_project": {
      "name": "link_session_to_project",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "session_id",
        "project_id"
      ],
      "returns": "",
      "docstring": "Link a session to a project",
      "decorators": [],
      "calls": [
        "commit",
        "time",
        "_execute",
        "info"
      ],
      "line_number": 99
    },
    "empirica.data.repositories.projects.get_project_sessions": {
      "name": "get_project_sessions",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Get all sessions for a project",
      "decorators": [],
      "calls": [
        "fetchall",
        "_execute",
        "dict"
      ],
      "line_number": 116
    },
    "empirica.data.repositories.projects.aggregate_project_learning_deltas": {
      "name": "aggregate_project_learning_deltas",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Compute total epistemic learning across all project sessions.\n\nQueries PREFLIGHT and POSTFLIGHT reflexes for each session,\ncomputes deltas, and aggregates.",
      "decorators": [],
      "calls": [
        "fetchall",
        "enumerate",
        "_execute",
        "fetchone"
      ],
      "line_number": 123
    },
    "empirica.data.repositories.projects.create_project_handoff": {
      "name": "create_project_handoff",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id",
        "project_summary",
        "key_decisions",
        "patterns_discovered",
        "remaining_work"
      ],
      "returns": "str",
      "docstring": "Create project-level handoff report by aggregating session handoffs.\n\nArgs:\n    project_id: Project identifier\n    project_summary: High-level summary of project state\n    key_decisions: List of major",
      "decorators": [],
      "calls": [
        "fetchall",
        "str",
        "dict",
        "get_project",
        "time",
        "info",
        "commit",
        "append",
        "loads",
        "get_project_sessions",
        "aggregate_project_learning_deltas",
        "dumps",
        "uuid4",
        "_execute"
      ],
      "line_number": 179
    },
    "empirica.data.repositories.projects.get_latest_project_handoff": {
      "name": "get_latest_project_handoff",
      "module": "empirica.data.repositories.projects",
      "params": [
        "self",
        "project_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get the most recent project handoff",
      "decorators": [],
      "calls": [
        "dict",
        "_execute",
        "fetchone"
      ],
      "line_number": 269
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.__init__": {
      "name": "__init__",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 555
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.initiate_investigation": {
      "name": "initiate_investigation",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id",
        "target",
        "protocol_id",
        "parameters"
      ],
      "returns": "bool",
      "docstring": "Initiate a new investigation",
      "decorators": [],
      "calls": [
        "get",
        "submit",
        "now",
        "print"
      ],
      "line_number": 88
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.collect_evidence": {
      "name": "collect_evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id",
        "evidence"
      ],
      "returns": "bool",
      "docstring": "Collect evidence for investigation",
      "decorators": [],
      "calls": [
        "append",
        "_analyze_evidence_correlations",
        "print"
      ],
      "line_number": 128
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.get_investigation_status": {
      "name": "get_investigation_status",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get current investigation status",
      "decorators": [],
      "calls": [
        "get",
        "now",
        "len",
        "str"
      ],
      "line_number": 151
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.get_investigation_report": {
      "name": "get_investigation_report",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Generate comprehensive investigation report",
      "decorators": [],
      "calls": [
        "_generate_recommendations",
        "str",
        "isoformat",
        "append",
        "now",
        "_generate_investigation_summary",
        "get"
      ],
      "line_number": 167
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._execute_investigation": {
      "name": "_execute_investigation",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Execute investigation protocol",
      "decorators": [],
      "calls": [
        "_perform_final_analysis",
        "str",
        "_execute_investigation_step",
        "enumerate",
        "now",
        "len",
        "print"
      ],
      "line_number": 203
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._execute_investigation_step": {
      "name": "_execute_investigation_step",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id",
        "step"
      ],
      "returns": "",
      "docstring": "Execute individual investigation step",
      "decorators": [],
      "calls": [
        "_analyze_performance_evidence",
        "_collect_behavioral_evidence",
        "_generate_findings",
        "_correlate_all_evidence"
      ],
      "line_number": 236
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._collect_behavioral_evidence": {
      "name": "_collect_behavioral_evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Collect behavioral evidence",
      "decorators": [],
      "calls": [
        "timestamp",
        "now",
        "Evidence",
        "collect_evidence"
      ],
      "line_number": 248
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._analyze_performance_evidence": {
      "name": "_analyze_performance_evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Analyze performance evidence",
      "decorators": [],
      "calls": [
        "timestamp",
        "now",
        "Evidence",
        "collect_evidence"
      ],
      "line_number": 261
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._analyze_evidence_correlations": {
      "name": "_analyze_evidence_correlations",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id",
        "new_evidence"
      ],
      "returns": "",
      "docstring": "Analyze correlations with new evidence",
      "decorators": [],
      "calls": [
        "extend",
        "find_correlations"
      ],
      "line_number": 274
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._correlate_all_evidence": {
      "name": "_correlate_all_evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Perform comprehensive evidence correlation",
      "decorators": [],
      "calls": [
        "correlate_evidence_set",
        "extend"
      ],
      "line_number": 287
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_findings": {
      "name": "_generate_findings",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Generate investigation findings",
      "decorators": [],
      "calls": [
        "generate_findings",
        "extend"
      ],
      "line_number": 295
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._perform_final_analysis": {
      "name": "_perform_final_analysis",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id"
      ],
      "returns": "",
      "docstring": "Perform final comprehensive analysis",
      "decorators": [],
      "calls": [
        "_assess_investigation_quality",
        "_generate_findings",
        "_correlate_all_evidence"
      ],
      "line_number": 308
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._assess_investigation_quality": {
      "name": "_assess_investigation_quality",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation"
      ],
      "returns": "float",
      "docstring": "Assess investigation quality",
      "decorators": [],
      "calls": [
        "min",
        "len"
      ],
      "line_number": 321
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_investigation_summary": {
      "name": "_generate_investigation_summary",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation"
      ],
      "returns": "str",
      "docstring": "Generate investigation summary",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 331
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_recommendations": {
      "name": "_generate_recommendations",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation"
      ],
      "returns": "List[str]",
      "docstring": "Generate recommendations based on investigation",
      "decorators": [],
      "calls": [
        "append",
        "len"
      ],
      "line_number": 338
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._initialize_default_protocols": {
      "name": "_initialize_default_protocols",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Initialize default investigation protocols",
      "decorators": [],
      "calls": [
        "InvestigationProtocol"
      ],
      "line_number": 350
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.find_correlations": {
      "name": "find_correlations",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "evidence",
        "existing_evidence"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Find correlations between evidence",
      "decorators": [],
      "calls": [
        "append",
        "_calculate_correlation",
        "abs",
        "total_seconds"
      ],
      "line_number": 373
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.correlate_evidence_set": {
      "name": "correlate_evidence_set",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "evidence_set"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Correlate entire set of evidence",
      "decorators": [],
      "calls": [
        "append",
        "_calculate_correlation",
        "enumerate"
      ],
      "line_number": 389
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._calculate_correlation": {
      "name": "_calculate_correlation",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "evidence1",
        "evidence2"
      ],
      "returns": "float",
      "docstring": "Calculate correlation strength between two pieces of evidence",
      "decorators": [],
      "calls": [
        "abs",
        "min",
        "total_seconds"
      ],
      "line_number": 406
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.generate_findings": {
      "name": "generate_findings",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "evidence_ids",
        "correlations",
        "evidence_store"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Generate findings from evidence and correlations",
      "decorators": [],
      "calls": [
        "items",
        "append",
        "len",
        "get",
        "sum"
      ],
      "line_number": 432
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.register_source": {
      "name": "register_source",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "source_id",
        "source_type",
        "handler"
      ],
      "returns": "bool",
      "docstring": "Register a data source",
      "decorators": [],
      "calls": [
        "print"
      ],
      "line_number": 493
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.analyze_multi_source_data": {
      "name": "analyze_multi_source_data",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "investigation_id",
        "source_data"
      ],
      "returns": "List[Evidence]",
      "docstring": "Analyze data from multiple sources",
      "decorators": [],
      "calls": [
        "_convert_source_data_to_evidence",
        "items",
        "append"
      ],
      "line_number": 506
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._convert_source_data_to_evidence": {
      "name": "_convert_source_data_to_evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "source_id",
        "source_type",
        "data",
        "investigation_id"
      ],
      "returns": "Optional[Evidence]",
      "docstring": "Convert source data to evidence",
      "decorators": [],
      "calls": [
        "Evidence",
        "timestamp",
        "now",
        "get",
        "print"
      ],
      "line_number": 522
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.add_correlation_rule": {
      "name": "add_correlation_rule",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "rule_id",
        "source_types",
        "correlation_function"
      ],
      "returns": "bool",
      "docstring": "Add correlation rule for specific source types",
      "decorators": [],
      "calls": [
        "print"
      ],
      "line_number": 558
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.correlate_sources": {
      "name": "correlate_sources",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "evidence_list"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Apply correlation rules to evidence from different sources",
      "decorators": [],
      "calls": [
        "_apply_correlation_rule",
        "items",
        "extend"
      ],
      "line_number": 571
    },
    "empirica.investigation.advanced_investigation.advanced_investigation._apply_correlation_rule": {
      "name": "_apply_correlation_rule",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "params": [
        "self",
        "rule",
        "evidence_list"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Apply specific correlation rule",
      "decorators": [],
      "calls": [
        "extend",
        "len",
        "any",
        "get",
        "print"
      ],
      "line_number": 581
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.generate_self_assessment_prompt": {
      "name": "generate_self_assessment_prompt",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "task",
        "response",
        "thinking_blocks",
        "assessment_type",
        "use_13_vectors"
      ],
      "returns": "str",
      "docstring": "Generate a prompt asking AI to self-assess its epistemic state.\n\nThis returns a prompt to send to the AI, NOT heuristics!\n\nArgs:\n    task: The user's query/task\n    response: The AI's response (for po",
      "decorators": [],
      "calls": [
        "_format_vector_keys",
        "strip",
        "_format_vector_definitions"
      ],
      "line_number": 46
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment._format_vector_definitions": {
      "name": "_format_vector_definitions",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "vectors"
      ],
      "returns": "str",
      "docstring": "Format vector definitions for prompt",
      "decorators": [],
      "calls": [
        "get",
        "join",
        "append"
      ],
      "line_number": 146
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment._format_vector_keys": {
      "name": "_format_vector_keys",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "vectors"
      ],
      "returns": "str",
      "docstring": "Format vector keys for JSON template",
      "decorators": [],
      "calls": [
        "append",
        "join",
        "len",
        "enumerate"
      ],
      "line_number": 179
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.parse_ai_self_assessment": {
      "name": "parse_ai_self_assessment",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "response_text"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Parse AI's self-assessment from response.\n\nLooks for JSON block in response containing epistemic_assessment.\n\nArgs:\n    response_text: AI's response containing self-assessment\n\nReturns:\n    Dict with ",
      "decorators": [],
      "calls": [
        "warning",
        "findall",
        "loads"
      ],
      "line_number": 189
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.prompt_for_self_assessment": {
      "name": "prompt_for_self_assessment",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "ai_response_function",
        "task",
        "response",
        "thinking_blocks",
        "assessment_type"
      ],
      "returns": "Optional[Dict[str, float]]",
      "docstring": "Actually ask the AI to self-assess (no heuristics).\n\nThis sends a prompt to the AI asking for genuine self-assessment.\n\nArgs:\n    ai_response_function: Function that takes prompt and returns AI respon",
      "decorators": [],
      "calls": [
        "warning",
        "parse_ai_self_assessment",
        "ai_response_function",
        "generate_self_assessment_prompt",
        "error",
        "info",
        "get"
      ],
      "line_number": 225
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.integrate_with_adapter": {
      "name": "integrate_with_adapter",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "adapter_class",
        "enable_self_assessment",
        "use_onboarding"
      ],
      "returns": "",
      "docstring": "Decorator to integrate genuine self-assessment into an adapter.\n\nUsage:\n    @integrate_with_adapter(enable_self_assessment=True)\n    class MinimaxAdapter:\n        ...\n\nThis modifies the adapter to:\n1.",
      "decorators": [],
      "calls": [
        "hasattr",
        "info",
        "generate_self_assessment_prompt",
        "original_transform"
      ],
      "line_number": 278
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.wrapper": {
      "name": "wrapper",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "cls"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "hasattr",
        "info",
        "generate_self_assessment_prompt",
        "original_transform"
      ],
      "line_number": 295
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.new_transform": {
      "name": "new_transform",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "params": [
        "self",
        "response_text",
        "usage",
        "thinking",
        "payload"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "hasattr",
        "info",
        "generate_self_assessment_prompt",
        "original_transform"
      ],
      "line_number": 298
    },
    "empirica.plugins.modality_switcher.domain_vectors.initialize_registry": {
      "name": "initialize_registry",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [],
      "returns": "",
      "docstring": "Initialize registry with built-in domains",
      "decorators": [],
      "calls": [
        "copy",
        "len",
        "info"
      ],
      "line_number": 110
    },
    "empirica.plugins.modality_switcher.domain_vectors.register_domain_vectors": {
      "name": "register_domain_vectors",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [
        "domain",
        "description",
        "vectors",
        "weights"
      ],
      "returns": "bool",
      "docstring": "Register custom domain vectors\n\nArgs:\n    domain: Domain name (e.g., \"chemistry_research\")\n    description: Domain description\n    vectors: Dict of {vector_name: description}\n    weights: Optional dic",
      "decorators": [],
      "calls": [
        "keys",
        "warning",
        "info",
        "len",
        "max",
        "min"
      ],
      "line_number": 117
    },
    "empirica.plugins.modality_switcher.domain_vectors.get_domain_vectors": {
      "name": "get_domain_vectors",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [
        "domain"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Get vector definitions for a domain\n\nArgs:\n    domain: Domain name\n    \nReturns:\n    Dict with {description, vectors, weights} or None if not found",
      "decorators": [],
      "calls": [
        "get",
        "initialize_registry"
      ],
      "line_number": 175
    },
    "empirica.plugins.modality_switcher.domain_vectors.list_domains": {
      "name": "list_domains",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [],
      "returns": "List[str]",
      "docstring": "List all registered domains\n\nReturns:\n    List of domain names",
      "decorators": [],
      "calls": [
        "list",
        "keys",
        "initialize_registry"
      ],
      "line_number": 191
    },
    "empirica.plugins.modality_switcher.domain_vectors.calculate_domain_confidence": {
      "name": "calculate_domain_confidence",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [
        "domain",
        "vector_scores"
      ],
      "returns": "float",
      "docstring": "Calculate weighted confidence score for a domain\n\nArgs:\n    domain: Domain name\n    vector_scores: Dict of {vector_name: score} (0.0-1.0)\n    \nReturns:\n    Weighted confidence score (0.0-1.0)\n    \nExa",
      "decorators": [],
      "calls": [
        "items",
        "warning",
        "get_domain_vectors"
      ],
      "line_number": 204
    },
    "empirica.plugins.modality_switcher.domain_vectors.auto_discover_custom_domains": {
      "name": "auto_discover_custom_domains",
      "module": "empirica.plugins.modality_switcher.domain_vectors",
      "params": [
        "custom_dir"
      ],
      "returns": "",
      "docstring": "Auto-discover custom domain definitions from Python files\n\nLooks for .py files in custom_dir that define:\n- DOMAIN_NAME: str\n- DOMAIN_DESCRIPTION: str\n- DOMAIN_VECTORS: Dict[str, str]\n- DOMAIN_WEIGHTS",
      "decorators": [],
      "calls": [
        "startswith",
        "glob",
        "warning",
        "hasattr",
        "getattr",
        "register_domain_vectors",
        "Path",
        "info",
        "exists",
        "spec_from_file_location",
        "module_from_spec",
        "exec_module"
      ],
      "line_number": 248
    },
    "empirica.plugins.modality_switcher.auth_manager.get_token": {
      "name": "get_token",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self",
        "provider",
        "scopes",
        "reason",
        "force_refresh"
      ],
      "returns": "TokenResponse",
      "docstring": "Get authentication token for a provider.\n\nArgs:\n    provider: Provider identifier (e.g., \"openai\", \"anthropic\")\n    scopes: Required scopes (e.g., [\"chat\", \"embeddings\"])\n    reason: Human-readable re",
      "decorators": [],
      "calls": [
        "_request_from_sentinel",
        "is_expired",
        "_request_from_env",
        "debug",
        "sorted",
        "join",
        "error",
        "AuthenticationError"
      ],
      "line_number": 103
    },
    "empirica.plugins.modality_switcher.auth_manager.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 47
    },
    "empirica.plugins.modality_switcher.auth_manager.is_expired": {
      "name": "is_expired",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if token is expired",
      "decorators": [],
      "calls": [
        "time"
      ],
      "line_number": 51
    },
    "empirica.plugins.modality_switcher.auth_manager.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self",
        "sentinel_url",
        "fallback_mode"
      ],
      "returns": "",
      "docstring": "Initialize AuthManager.\n\nArgs:\n    sentinel_url: URL of Sentinel service (default: http://localhost:8765)\n    fallback_mode: Fallback when Sentinel unavailable (\"env\" or \"error\")",
      "decorators": [],
      "calls": [
        "getenv",
        "_check_sentinel_availability"
      ],
      "line_number": 66
    },
    "empirica.plugins.modality_switcher.auth_manager._check_sentinel_availability": {
      "name": "_check_sentinel_availability",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Check if Sentinel service is reachable",
      "decorators": [],
      "calls": [
        "get",
        "warning",
        "debug",
        "info"
      ],
      "line_number": 82
    },
    "empirica.plugins.modality_switcher.auth_manager._request_from_sentinel": {
      "name": "_request_from_sentinel",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self",
        "provider",
        "scopes",
        "reason"
      ],
      "returns": "TokenResponse",
      "docstring": "Request token from Sentinel API.\n\nArgs:\n    provider: Provider identifier\n    scopes: Required scopes\n    reason: Reason for request\n    \nReturns:\n    TokenResponse\n    \nRaises:\n    Exception: If requ",
      "decorators": [],
      "calls": [
        "json",
        "Exception",
        "info",
        "post",
        "asdict",
        "get",
        "TokenRequest",
        "TokenResponse"
      ],
      "line_number": 154
    },
    "empirica.plugins.modality_switcher.auth_manager._request_from_env": {
      "name": "_request_from_env",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self",
        "provider",
        "scopes"
      ],
      "returns": "TokenResponse",
      "docstring": "Get token from environment variables (fallback).\n\nLooks for environment variables like:\n- OPENAI_API_KEY\n- ANTHROPIC_API_KEY\n- {PROVIDER}_API_KEY\n\nArgs:\n    provider: Provider identifier\n    scopes: R",
      "decorators": [],
      "calls": [
        "getenv",
        "info",
        "upper",
        "get",
        "AuthenticationError",
        "TokenResponse",
        "lower"
      ],
      "line_number": 203
    },
    "empirica.plugins.modality_switcher.auth_manager.revoke_token": {
      "name": "revoke_token",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self",
        "provider"
      ],
      "returns": "",
      "docstring": "Revoke cached token for provider.\n\nArgs:\n    provider: Provider identifier",
      "decorators": [],
      "calls": [
        "post",
        "startswith",
        "debug",
        "info"
      ],
      "line_number": 262
    },
    "empirica.plugins.modality_switcher.auth_manager.clear_cache": {
      "name": "clear_cache",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Clear all cached tokens",
      "decorators": [],
      "calls": [
        "info",
        "clear"
      ],
      "line_number": 289
    },
    "empirica.plugins.modality_switcher.snapshot_provider.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "tracker"
      ],
      "returns": "",
      "docstring": "Initialize snapshot provider\n\nArgs:\n    tracker: EmpericaTracker instance (or get singleton)",
      "decorators": [],
      "calls": [
        "get_instance"
      ],
      "line_number": 58
    },
    "empirica.plugins.modality_switcher.snapshot_provider.create_snapshot_from_session": {
      "name": "create_snapshot_from_session",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "session_id",
        "context_summary",
        "context_summary_text",
        "semantic_tags",
        "evidence_refs",
        "cascade_phase",
        "domain_vectors"
      ],
      "returns": "EpistemicStateSnapshot",
      "docstring": "Create epistemic snapshot from current session state\n\nArgs:\n    session_id: Session to snapshot\n    context_summary: Full ContextSummary object (takes precedence)\n    context_summary_text: Narrative t",
      "decorators": [],
      "calls": [
        "_estimate_fidelity",
        "get_session",
        "str",
        "calculate_delta",
        "uuid4",
        "isoformat",
        "EpistemicStateSnapshot",
        "_estimate_original_context_tokens",
        "_extract_vectors_from_assessment",
        "get_latest_snapshot",
        "_estimate_snapshot_tokens",
        "ContextSummary",
        "now",
        "ValueError",
        "_get_default_vectors",
        "_estimate_information_loss",
        "get_preflight_assessment"
      ],
      "line_number": 68
    },
    "empirica.plugins.modality_switcher.snapshot_provider.save_snapshot": {
      "name": "save_snapshot",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "snapshot"
      ],
      "returns": "",
      "docstring": "Save snapshot to database\n\nArgs:\n    snapshot: Snapshot to save",
      "decorators": [],
      "calls": [
        "cursor",
        "estimate_memory_reliability",
        "to_dict",
        "update_snapshot_status",
        "should_refresh",
        "get_refresh_reason",
        "commit",
        "print",
        "execute",
        "dumps"
      ],
      "line_number": 160
    },
    "empirica.plugins.modality_switcher.snapshot_provider.get_latest_snapshot": {
      "name": "get_latest_snapshot",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[EpistemicStateSnapshot]",
      "docstring": "Get most recent snapshot for session\n\nArgs:\n    session_id: Session identifier\n\nReturns:\n    Latest EpistemicStateSnapshot or None",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "_row_to_snapshot",
        "fetchone"
      ],
      "line_number": 235
    },
    "empirica.plugins.modality_switcher.snapshot_provider.get_snapshot_by_id": {
      "name": "get_snapshot_by_id",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "snapshot_id"
      ],
      "returns": "Optional[EpistemicStateSnapshot]",
      "docstring": "Get snapshot by ID\n\nArgs:\n    snapshot_id: Snapshot identifier\n\nReturns:\n    EpistemicStateSnapshot or None",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "_row_to_snapshot",
        "fetchone"
      ],
      "line_number": 259
    },
    "empirica.plugins.modality_switcher.snapshot_provider.get_snapshot_history": {
      "name": "get_snapshot_history",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "session_id",
        "limit"
      ],
      "returns": "List[EpistemicStateSnapshot]",
      "docstring": "Get snapshot history for session\n\nArgs:\n    session_id: Session identifier\n    limit: Maximum snapshots to return\n\nReturns:\n    List of EpistemicStateSnapshot (newest first)",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "_row_to_snapshot",
        "fetchall"
      ],
      "line_number": 281
    },
    "empirica.plugins.modality_switcher.snapshot_provider.export_snapshot_to_file": {
      "name": "export_snapshot_to_file",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "snapshot",
        "filepath"
      ],
      "returns": "str",
      "docstring": "Export snapshot to JSON file for cross-AI transfer\n\nArgs:\n    snapshot: Snapshot to export\n    filepath: Destination file path\n\nReturns:\n    Absolute path to exported file",
      "decorators": [],
      "calls": [
        "absolute",
        "open",
        "str",
        "mkdir",
        "to_json",
        "Path",
        "write",
        "print"
      ],
      "line_number": 302
    },
    "empirica.plugins.modality_switcher.snapshot_provider.import_snapshot_from_file": {
      "name": "import_snapshot_from_file",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "filepath"
      ],
      "returns": "EpistemicStateSnapshot",
      "docstring": "Import snapshot from JSON file\n\nArgs:\n    filepath: Source file path\n\nReturns:\n    EpistemicStateSnapshot\n\nRaises:\n    FileNotFoundError: If file doesn't exist",
      "decorators": [],
      "calls": [
        "read",
        "open",
        "from_json",
        "FileNotFoundError",
        "Path",
        "exists",
        "print"
      ],
      "line_number": 322
    },
    "empirica.plugins.modality_switcher.snapshot_provider._extract_vectors_from_assessment": {
      "name": "_extract_vectors_from_assessment",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Extract 13 epistemic vectors from preflight assessment\n\nArgs:\n    assessment: Preflight assessment dictionary\n\nReturns:\n    Dictionary of 13 vectors",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 345
    },
    "empirica.plugins.modality_switcher.snapshot_provider._get_default_vectors": {
      "name": "_get_default_vectors",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Get default 13 vectors (neutral state)",
      "decorators": [],
      "calls": [],
      "line_number": 378
    },
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_original_context_tokens": {
      "name": "_estimate_original_context_tokens",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "int",
      "docstring": "Estimate original context tokens (conversation history)\n\nRough estimation:\n- Each cascade: ~500 tokens (task + assessments)\n- Each assessment: ~200 tokens\n- Session metadata: ~100 tokens\n\nArgs:\n    se",
      "decorators": [],
      "calls": [
        "get_session",
        "get_session_cascades",
        "len"
      ],
      "line_number": 396
    },
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_snapshot_tokens": {
      "name": "_estimate_snapshot_tokens",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "vectors",
        "context_summary",
        "domain_vectors"
      ],
      "returns": "int",
      "docstring": "Estimate snapshot token count\n\nBreakdown:\n- 13 vectors: ~150 tokens\n- Context summary: ~200 tokens\n- Domain vectors: ~100 tokens per domain\n- Metadata: ~50 tokens\n\nArgs:\n    vectors: Core vectors\n    ",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 426
    },
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_fidelity": {
      "name": "_estimate_fidelity",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "vectors",
        "context_summary"
      ],
      "returns": "float",
      "docstring": "Estimate snapshot fidelity (how well it represents original context)\n\nHigher fidelity when:\n- Context summary is rich (semantic + narrative)\n- Vectors are well-defined (not all neutral)\n- Evidence ref",
      "decorators": [],
      "calls": [
        "min",
        "values",
        "sum",
        "max"
      ],
      "line_number": 459
    },
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_information_loss": {
      "name": "_estimate_information_loss",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "compression_ratio"
      ],
      "returns": "float",
      "docstring": "Estimate information loss from compression\n\nHigher compression = more loss (but not linear)\n95% compression \u2248 10% information loss (acceptable)\n\nArgs:\n    compression_ratio: Compression ratio (0.0-1.0",
      "decorators": [],
      "calls": [],
      "line_number": 495
    },
    "empirica.plugins.modality_switcher.snapshot_provider._row_to_snapshot": {
      "name": "_row_to_snapshot",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "params": [
        "self",
        "row"
      ],
      "returns": "EpistemicStateSnapshot",
      "docstring": "Convert database row to EpistemicStateSnapshot\n\nArgs:\n    row: SQLite row\n\nReturns:\n    EpistemicStateSnapshot",
      "decorators": [],
      "calls": [
        "from_dict",
        "dict",
        "EpistemicStateSnapshot",
        "loads",
        "get"
      ],
      "line_number": 518
    },
    "empirica.plugins.modality_switcher.epistemic_router.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "params": [
        "self",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize router\n\nArgs:\n    config: Configuration dict with thresholds and preferences",
      "decorators": [],
      "calls": [],
      "line_number": 70
    },
    "empirica.plugins.modality_switcher.epistemic_router.route": {
      "name": "route",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "params": [
        "self",
        "epistemic_assessment",
        "budget_remaining_usd",
        "request_tokens",
        "force_modality"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route request based on epistemic state and budget\n\nArgs:\n    epistemic_assessment: 13-vector assessment with scores + rationales\n    budget_remaining_usd: Remaining budget in USD\n    request_tokens: E",
      "decorators": [],
      "calls": [
        "get",
        "_estimate_cost",
        "_route_by_action",
        "_create_decision"
      ],
      "line_number": 107
    },
    "empirica.plugins.modality_switcher.epistemic_router._route_by_action": {
      "name": "_route_by_action",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "params": [
        "self",
        "action",
        "confidence",
        "uncertainty",
        "budget",
        "tokens",
        "assessment"
      ],
      "returns": "Optional[RoutingDecision]",
      "docstring": "Route based on recommended action",
      "decorators": [],
      "calls": [
        "_estimate_cost",
        "_create_decision"
      ],
      "line_number": 231
    },
    "empirica.plugins.modality_switcher.epistemic_router._estimate_cost": {
      "name": "_estimate_cost",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "params": [
        "self",
        "modality",
        "tokens"
      ],
      "returns": "float",
      "docstring": "Estimate cost for modality and token count",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 283
    },
    "empirica.plugins.modality_switcher.epistemic_router._create_decision": {
      "name": "_create_decision",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "params": [
        "self",
        "modality",
        "rationale",
        "confidence",
        "cost",
        "epistemic_state",
        "fallback"
      ],
      "returns": "RoutingDecision",
      "docstring": "Create a RoutingDecision object",
      "decorators": [],
      "calls": [
        "RoutingDecision"
      ],
      "line_number": 295
    },
    "empirica.plugins.modality_switcher.config_loader.get_config": {
      "name": "get_config",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "reload"
      ],
      "returns": "ConfigLoader",
      "docstring": "Get or create global ConfigLoader instance.\n\nArgs:\n    reload: If True, reload configuration from files\n    \nReturns:\n    ConfigLoader instance",
      "decorators": [],
      "calls": [
        "ConfigLoader"
      ],
      "line_number": 270
    },
    "empirica.plugins.modality_switcher.config_loader.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize ConfigLoader.\n\nArgs:\n    config_path: Optional explicit config file path",
      "decorators": [],
      "calls": [
        "load_config"
      ],
      "line_number": 31
    },
    "empirica.plugins.modality_switcher.config_loader.load_config": {
      "name": "load_config",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Load configuration from files and environment variables.\n\nReturns:\n    Dict with full configuration",
      "decorators": [],
      "calls": [
        "_load_yaml",
        "warning",
        "_apply_env_overrides",
        "info",
        "exists",
        "_merge_configs",
        "_get_minimal_defaults"
      ],
      "line_number": 41
    },
    "empirica.plugins.modality_switcher.config_loader._load_yaml": {
      "name": "_load_yaml",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "path"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load YAML file.",
      "decorators": [],
      "calls": [
        "open",
        "error",
        "safe_load"
      ],
      "line_number": 80
    },
    "empirica.plugins.modality_switcher.config_loader._merge_configs": {
      "name": "_merge_configs",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "base",
        "overlay"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Recursively merge two config dictionaries.\n\nArgs:\n    base: Base configuration\n    overlay: Configuration to overlay (takes precedence)\n    \nReturns:\n    Merged configuration",
      "decorators": [],
      "calls": [
        "items",
        "copy",
        "isinstance",
        "_merge_configs"
      ],
      "line_number": 94
    },
    "empirica.plugins.modality_switcher.config_loader._apply_env_overrides": {
      "name": "_apply_env_overrides",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "config"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Apply environment variable overrides.\n\nEnvironment variables format: EMPIRICA_<SECTION>_<KEY>=value\nExample: EMPIRICA_ROUTING_DEFAULT_STRATEGY=cost",
      "decorators": [],
      "calls": [
        "startswith",
        "_parse_env_value",
        "debug",
        "items",
        "split",
        "len",
        "lower"
      ],
      "line_number": 115
    },
    "empirica.plugins.modality_switcher.config_loader._parse_env_value": {
      "name": "_parse_env_value",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "value"
      ],
      "returns": "Any",
      "docstring": "Parse environment variable value to appropriate type.",
      "decorators": [],
      "calls": [
        "float",
        "lower",
        "int"
      ],
      "line_number": 142
    },
    "empirica.plugins.modality_switcher.config_loader._get_minimal_defaults": {
      "name": "_get_minimal_defaults",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get minimal default configuration if files not found.",
      "decorators": [],
      "calls": [],
      "line_number": 161
    },
    "empirica.plugins.modality_switcher.config_loader.get": {
      "name": "get",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "key_path",
        "default"
      ],
      "returns": "Any",
      "docstring": "Get configuration value by dot-notation path.\n\nArgs:\n    key_path: Dot-separated path (e.g., \"routing.default_strategy\")\n    default: Default value if not found\n    \nReturns:\n    Configuration value o",
      "decorators": [],
      "calls": [
        "isinstance",
        "split"
      ],
      "line_number": 190
    },
    "empirica.plugins.modality_switcher.config_loader.get_adapter_config": {
      "name": "get_adapter_config",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "adapter_name"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get configuration for a specific adapter.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 212
    },
    "empirica.plugins.modality_switcher.config_loader.get_routing_config": {
      "name": "get_routing_config",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get routing configuration.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 216
    },
    "empirica.plugins.modality_switcher.config_loader.is_adapter_enabled": {
      "name": "is_adapter_enabled",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "adapter_name"
      ],
      "returns": "bool",
      "docstring": "Check if adapter is enabled.",
      "decorators": [],
      "calls": [
        "get",
        "get_adapter_config"
      ],
      "line_number": 220
    },
    "empirica.plugins.modality_switcher.config_loader.get_adapter_costs": {
      "name": "get_adapter_costs",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Get cost per 1k tokens for all adapters.",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 224
    },
    "empirica.plugins.modality_switcher.config_loader.get_adapter_latencies": {
      "name": "get_adapter_latencies",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Get estimated latency for all adapters.",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 231
    },
    "empirica.plugins.modality_switcher.config_loader.get_adapter_quality": {
      "name": "get_adapter_quality",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Get quality scores for all adapters.",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 238
    },
    "empirica.plugins.modality_switcher.config_loader.save_user_config": {
      "name": "save_user_config",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self",
        "config"
      ],
      "returns": "",
      "docstring": "Save configuration to user config file.\n\nArgs:\n    config: Configuration to save",
      "decorators": [],
      "calls": [
        "open",
        "mkdir",
        "dump",
        "info"
      ],
      "line_number": 245
    },
    "empirica.plugins.modality_switcher.config_loader.to_dict": {
      "name": "to_dict",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get full configuration as dictionary.",
      "decorators": [],
      "calls": [
        "copy"
      ],
      "line_number": 261
    },
    "empirica.plugins.modality_switcher.usage_monitor.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 36
    },
    "empirica.plugins.modality_switcher.usage_monitor.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "state_file"
      ],
      "returns": "",
      "docstring": "Initialize UsageMonitor.\n\nArgs:\n    state_file: Path to JSON file for persistence\n               Defaults to ~/.empirica/usage_monitor.json",
      "decorators": [],
      "calls": [
        "_load_state",
        "mkdir",
        "home",
        "Path"
      ],
      "line_number": 91
    },
    "empirica.plugins.modality_switcher.usage_monitor._load_state": {
      "name": "_load_state",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Load state from JSON file",
      "decorators": [],
      "calls": [
        "copy",
        "_save_state",
        "open",
        "CallRecord",
        "items",
        "error",
        "info",
        "len",
        "exists",
        "load",
        "get",
        "BudgetPolicy"
      ],
      "line_number": 112
    },
    "empirica.plugins.modality_switcher.usage_monitor._save_state": {
      "name": "_save_state",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Save state to JSON file",
      "decorators": [],
      "calls": [
        "open",
        "isoformat",
        "items",
        "error",
        "dump",
        "now",
        "asdict"
      ],
      "line_number": 146
    },
    "empirica.plugins.modality_switcher.usage_monitor.record_call": {
      "name": "record_call",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "provider",
        "tokens_used",
        "cost_usd",
        "call_type",
        "success",
        "error_code",
        "meta"
      ],
      "returns": "",
      "docstring": "Record a model call.\n\nArgs:\n    provider: Provider identifier (e.g., \"openai\", \"anthropic\")\n    tokens_used: Number of tokens consumed\n    cost_usd: Estimated cost in USD\n    call_type: \"local\", \"non_",
      "decorators": [],
      "calls": [
        "CallRecord",
        "_save_state",
        "warning",
        "debug",
        "append",
        "get",
        "time"
      ],
      "line_number": 165
    },
    "empirica.plugins.modality_switcher.usage_monitor.check_budget": {
      "name": "check_budget",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "provider",
        "call_type"
      ],
      "returns": "bool",
      "docstring": "Check if a call would exceed budget limits.\n\nArgs:\n    provider: Provider identifier\n    call_type: \"local\", \"non_premium\", or \"premium\"\n    \nReturns:\n    bool: True if within budget, False otherwise\n",
      "decorators": [],
      "calls": [
        "warning",
        "len",
        "get",
        "time",
        "sum"
      ],
      "line_number": 210
    },
    "empirica.plugins.modality_switcher.usage_monitor.get_usage_summary": {
      "name": "get_usage_summary",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "provider"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get usage summary statistics.\n\nArgs:\n    provider: Optional provider to filter by\n    \nReturns:\n    Dict with usage statistics",
      "decorators": [],
      "calls": [
        "len",
        "time",
        "sum"
      ],
      "line_number": 278
    },
    "empirica.plugins.modality_switcher.usage_monitor.reset_stop_flag": {
      "name": "reset_stop_flag",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "provider"
      ],
      "returns": "",
      "docstring": "Reset stop usage flag for a provider.\n\nArgs:\n    provider: Provider identifier",
      "decorators": [],
      "calls": [
        "_save_state",
        "info"
      ],
      "line_number": 323
    },
    "empirica.plugins.modality_switcher.usage_monitor.set_policy": {
      "name": "set_policy",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "call_type",
        "policy"
      ],
      "returns": "",
      "docstring": "Update budget policy for a call type.\n\nArgs:\n    call_type: \"local\", \"non_premium\", or \"premium\"\n    policy: New budget policy",
      "decorators": [],
      "calls": [
        "_save_state",
        "info"
      ],
      "line_number": 335
    },
    "empirica.plugins.modality_switcher.usage_monitor.cleanup_old_records": {
      "name": "cleanup_old_records",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "params": [
        "self",
        "days"
      ],
      "returns": "",
      "docstring": "Remove records older than specified days.\n\nArgs:\n    days: Number of days to keep",
      "decorators": [],
      "calls": [
        "_save_state",
        "len",
        "time",
        "info"
      ],
      "line_number": 347
    },
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_from_thinking_semantically": {
      "name": "extract_from_thinking_semantically",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking_blocks",
        "response_text",
        "query"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Extract epistemic state from AI's thinking blocks.\n\nThis analyzes the AI's INTERNAL REASONING before it generated the response.\nMore genuine than analyzing the response itself (which may be performati",
      "decorators": [],
      "calls": [
        "warning",
        "_analyze_capability_confidence",
        "join",
        "info",
        "_analyze_uncertainty_level",
        "_analyze_context_awareness",
        "lower",
        "_analyze_knowledge_confidence",
        "extract_from_response_only"
      ],
      "line_number": 26
    },
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_knowledge_confidence": {
      "name": "_analyze_knowledge_confidence",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking",
        "response"
      ],
      "returns": "float",
      "docstring": "Analyze how confident AI is about its knowledge.\n\nLooks for:\n- High confidence: \"I understand\", \"this is straightforward\", \"clear that\"\n- Medium: \"I believe\", \"it seems\", \"generally\"\n- Low: \"not sure\"",
      "decorators": [],
      "calls": [
        "search",
        "len",
        "max",
        "min",
        "sum"
      ],
      "line_number": 78
    },
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_capability_confidence": {
      "name": "_analyze_capability_confidence",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking",
        "response"
      ],
      "returns": "float",
      "docstring": "Analyze whether AI thinks it CAN do the task.\n\nLooks for:\n- High: \"I can provide\", \"straightforward to\", \"I'll do\"\n- Low: \"beyond my capability\", \"cannot directly\", \"would need\"",
      "decorators": [],
      "calls": [
        "search",
        "sum"
      ],
      "line_number": 151
    },
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_context_awareness": {
      "name": "_analyze_context_awareness",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking",
        "query"
      ],
      "returns": "float",
      "docstring": "Analyze awareness of situational context.\n\nLooks for:\n- High: References to specific context, mentions constraints\n- Low: Generic response, no acknowledgment of specifics",
      "decorators": [],
      "calls": [
        "findall",
        "search",
        "len",
        "max",
        "min",
        "set",
        "sum"
      ],
      "line_number": 200
    },
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_uncertainty_level": {
      "name": "_analyze_uncertainty_level",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking"
      ],
      "returns": "float",
      "docstring": "Analyze explicit uncertainty in thinking.\n\nThis is the most direct indicator - AI explicitly saying it's uncertain.\n\nLooks for:\n- High uncertainty: \"not sure\", \"uncertain\", \"don't know\"\n- Medium: \"mig",
      "decorators": [],
      "calls": [
        "search",
        "min",
        "sum"
      ],
      "line_number": 254
    },
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_from_response_only": {
      "name": "extract_from_response_only",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "response_text",
        "query"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Fallback: Extract epistemic state from response when no thinking blocks.\n\nLess accurate than thinking analysis, but better than nothing.",
      "decorators": [],
      "calls": [
        "search",
        "lower",
        "warning"
      ],
      "line_number": 327
    },
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_decision_from_thinking": {
      "name": "extract_decision_from_thinking",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "thinking_blocks",
        "response_text",
        "vectors"
      ],
      "returns": "Tuple[str, float]",
      "docstring": "Determine decision and confidence from thinking + vectors.\n\nDecision logic:\n- ACT: DO \u2265 0.7 AND UNCERTAINTY < 0.3\n- CHECK: DO \u2265 0.7 BUT UNCERTAINTY \u2265 0.3 (need validation)\n- INVESTIGATE: UNCERTAINTY >",
      "decorators": [],
      "calls": [
        "get",
        "info"
      ],
      "line_number": 366
    },
    "empirica.plugins.modality_switcher.thinking_analyzer.validate_with_explicit_assessment": {
      "name": "validate_with_explicit_assessment",
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "params": [
        "current_vectors",
        "explicit_vectors"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Compare thinking-based vectors with explicit self-assessment.\n\nThis helps calibrate the thinking analyzer over time.\n\nArgs:\n    current_vectors: Extracted from thinking blocks\n    explicit_vectors: Fr",
      "decorators": [],
      "calls": [
        "get",
        "warning",
        "abs"
      ],
      "line_number": 414
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.create_snapshot": {
      "name": "create_snapshot",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "session_id",
        "ai_id",
        "vectors",
        "context_summary",
        "cascade_phase",
        "domain_vectors"
      ],
      "returns": "EpistemicStateSnapshot",
      "docstring": "Convenience function to create a new epistemic snapshot\n\nArgs:\n    session_id: Session identifier\n    ai_id: AI identifier\n    vectors: 13 core epistemic vectors\n    context_summary: Optional context ",
      "decorators": [],
      "calls": [
        "str",
        "isoformat",
        "EpistemicStateSnapshot",
        "now",
        "uuid4"
      ],
      "line_number": 435
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_dict": {
      "name": "to_dict",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Convert to dictionary for JSON serialization",
      "decorators": [],
      "calls": [
        "asdict",
        "to_dict"
      ],
      "line_number": 161
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.from_dict": {
      "name": "from_dict",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "cls",
        "data"
      ],
      "returns": "'EpistemicStateSnapshot'",
      "docstring": "Create from dictionary",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "cls",
        "from_dict"
      ],
      "line_number": 176
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_prompt": {
      "name": "to_prompt",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Convert to natural language prompt",
      "decorators": [],
      "calls": [
        "append",
        "items",
        "join"
      ],
      "line_number": 57
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_json": {
      "name": "to_json",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Export as JSON for cross-AI transfer",
      "decorators": [],
      "calls": [
        "to_dict",
        "dumps"
      ],
      "line_number": 171
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.from_json": {
      "name": "from_json",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "cls",
        "json_str"
      ],
      "returns": "'EpistemicStateSnapshot'",
      "docstring": "Import from JSON",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "from_dict",
        "loads"
      ],
      "line_number": 185
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_context_prompt": {
      "name": "to_context_prompt",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self",
        "level"
      ],
      "returns": "str",
      "docstring": "Convert snapshot to natural language context for AI prompt injection\n\nLevels:\n- minimal: Core vectors + phase (~500 tokens)\n- standard: + delta + summary (~1000 tokens)\n- full: + evidence + domain vec",
      "decorators": [],
      "calls": [
        "_standard_prompt",
        "_minimal_prompt",
        "ValueError",
        "_full_prompt"
      ],
      "line_number": 190
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._minimal_prompt": {
      "name": "_minimal_prompt",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Minimal context injection (~500 tokens)",
      "decorators": [],
      "calls": [
        "_format_vectors"
      ],
      "line_number": 214
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._standard_prompt": {
      "name": "_standard_prompt",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Standard context with delta and summary (~1000 tokens)",
      "decorators": [],
      "calls": [
        "to_prompt",
        "_minimal_prompt",
        "_format_delta"
      ],
      "line_number": 233
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._full_prompt": {
      "name": "_full_prompt",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Full context with all details (~1500 tokens)",
      "decorators": [],
      "calls": [
        "_standard_prompt",
        "_format_domain_vectors"
      ],
      "line_number": 245
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_vectors": {
      "name": "_format_vectors",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Format 13 vectors for display with grouping",
      "decorators": [],
      "calls": [
        "format_group",
        "join",
        "append",
        "_score_to_bar",
        "get"
      ],
      "line_number": 259
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_delta": {
      "name": "_format_delta",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Format delta changes with visual indicators",
      "decorators": [],
      "calls": [
        "abs",
        "items",
        "sorted",
        "join",
        "append"
      ],
      "line_number": 286
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_domain_vectors": {
      "name": "_format_domain_vectors",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Format domain-specific vectors",
      "decorators": [],
      "calls": [
        "title",
        "items",
        "type",
        "join",
        "append",
        "replace",
        "isinstance",
        "_score_to_bar"
      ],
      "line_number": 304
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot._score_to_bar": {
      "name": "_score_to_bar",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "score",
        "width"
      ],
      "returns": "str",
      "docstring": "Convert score to visual bar graph",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "int"
      ],
      "line_number": 329
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.calculate_delta": {
      "name": "calculate_delta",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self",
        "previous"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate vector changes from previous snapshot\n\nArgs:\n    previous: Previous snapshot to compare against\n\nReturns:\n    Dictionary of vector changes (positive = improvement, negative = degradation)",
      "decorators": [],
      "calls": [
        "get",
        "items"
      ],
      "line_number": 335
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.increment_transfer_count": {
      "name": "increment_transfer_count",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Increment transfer count (called when snapshot is passed to another AI)",
      "decorators": [],
      "calls": [],
      "line_number": 351
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.estimate_memory_reliability": {
      "name": "estimate_memory_reliability",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "float",
      "docstring": "Calculate how reliable the compressed snapshot is vs full context\n\nFactors:\n- Fidelity score (from compression)\n- Number of model transfers (degrades with each hop)\n- Time since original creation (tem",
      "decorators": [],
      "calls": [
        "now",
        "max",
        "min",
        "total_seconds",
        "fromisoformat"
      ],
      "line_number": 355
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.should_refresh": {
      "name": "should_refresh",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self",
        "min_reliability",
        "max_transfers",
        "max_age_hours"
      ],
      "returns": "bool",
      "docstring": "Determine if snapshot should be refreshed with full context\n\nArgs:\n    min_reliability: Minimum acceptable reliability\n    max_transfers: Maximum transfer count before refresh\n    max_age_hours: Maxim",
      "decorators": [],
      "calls": [
        "estimate_memory_reliability",
        "now",
        "total_seconds",
        "fromisoformat"
      ],
      "line_number": 384
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.get_refresh_reason": {
      "name": "get_refresh_reason",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "self"
      ],
      "returns": "Optional[str]",
      "docstring": "Get reason why refresh is recommended (if applicable)",
      "decorators": [],
      "calls": [
        "estimate_memory_reliability",
        "now",
        "total_seconds",
        "fromisoformat"
      ],
      "line_number": 415
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.format_group": {
      "name": "format_group",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "params": [
        "name",
        "vectors"
      ],
      "returns": "str",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "join",
        "_score_to_bar",
        "append"
      ],
      "line_number": 270
    },
    "empirica.plugins.modality_switcher.modality_switcher.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize ModalitySwitcher.\n\nArgs:\n    config: Optional configuration dict",
      "decorators": [],
      "calls": [
        "get_registry",
        "info"
      ],
      "line_number": 82
    },
    "empirica.plugins.modality_switcher.modality_switcher.route_request": {
      "name": "route_request",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route a request to the best adapter based on epistemic state and preferences.\n\nArgs:\n    query: User query/task\n    epistemic_state: Dict with epistemic vectors (know, do, context, uncertainty, etc.)\n",
      "decorators": [],
      "calls": [
        "_latency_route",
        "_quality_route",
        "_balanced_route",
        "RoutingPreferences",
        "_force_adapter_route",
        "_epistemic_route",
        "_cost_route"
      ],
      "line_number": 136
    },
    "empirica.plugins.modality_switcher.modality_switcher._epistemic_route": {
      "name": "_epistemic_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route based on epistemic vectors.\n\nDecision Logic:\n- High UNCERTAINTY \u2192 Qwen/Local (exploration phase)\n- Low KNOW \u2192 MiniMax (need authoritative knowledge)\n- High confidence + ACT \u2192 MiniMax (final qual",
      "decorators": [],
      "calls": [
        "get",
        "RoutingDecision"
      ],
      "line_number": 174
    },
    "empirica.plugins.modality_switcher.modality_switcher._cost_route": {
      "name": "_cost_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route to minimize cost (prefer free adapters).",
      "decorators": [],
      "calls": [
        "RoutingDecision"
      ],
      "line_number": 236
    },
    "empirica.plugins.modality_switcher.modality_switcher._latency_route": {
      "name": "_latency_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route to minimize latency.",
      "decorators": [],
      "calls": [
        "RoutingDecision"
      ],
      "line_number": 258
    },
    "empirica.plugins.modality_switcher.modality_switcher._quality_route": {
      "name": "_quality_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Route to maximize quality.",
      "decorators": [],
      "calls": [
        "RoutingDecision"
      ],
      "line_number": 280
    },
    "empirica.plugins.modality_switcher.modality_switcher._balanced_route": {
      "name": "_balanced_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context"
      ],
      "returns": "RoutingDecision",
      "docstring": "Balanced routing considering all factors.\n\nScoring formula:\nscore = quality * 0.4 + (1 - normalized_cost) * 0.3 + (1 - normalized_latency) * 0.3",
      "decorators": [],
      "calls": [
        "RoutingDecision",
        "sorted",
        "values",
        "max"
      ],
      "line_number": 302
    },
    "empirica.plugins.modality_switcher.modality_switcher._force_adapter_route": {
      "name": "_force_adapter_route",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "adapter_name",
        "epistemic_state"
      ],
      "returns": "RoutingDecision",
      "docstring": "Force routing to a specific adapter.",
      "decorators": [],
      "calls": [
        "RoutingDecision",
        "ValueError"
      ],
      "line_number": 351
    },
    "empirica.plugins.modality_switcher.modality_switcher.execute_with_routing": {
      "name": "execute_with_routing",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "query",
        "epistemic_state",
        "preferences",
        "context",
        "system",
        "temperature",
        "max_tokens"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Route request and execute with selected adapter.\n\nArgs:\n    query: User query\n    epistemic_state: Epistemic vectors\n    preferences: Routing preferences\n    context: Additional context\n    system: Sy",
      "decorators": [],
      "calls": [
        "call",
        "warning",
        "str",
        "route_request",
        "error",
        "_try_fallback",
        "info",
        "isinstance",
        "get",
        "AdapterPayload",
        "AdapterError",
        "get_adapter"
      ],
      "line_number": 371
    },
    "empirica.plugins.modality_switcher.modality_switcher._try_fallback": {
      "name": "_try_fallback",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self",
        "payload",
        "fallback_adapters",
        "context"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Try fallback adapters in order.",
      "decorators": [],
      "calls": [
        "call",
        "warning",
        "error",
        "info",
        "isinstance",
        "get",
        "AdapterError",
        "get_adapter"
      ],
      "line_number": 455
    },
    "empirica.plugins.modality_switcher.modality_switcher.get_usage_stats": {
      "name": "get_usage_stats",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self"
      ],
      "returns": "Dict[str, int]",
      "docstring": "Get usage statistics.",
      "decorators": [],
      "calls": [
        "dict"
      ],
      "line_number": 499
    },
    "empirica.plugins.modality_switcher.modality_switcher.reset_usage_stats": {
      "name": "reset_usage_stats",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Reset usage statistics.",
      "decorators": [],
      "calls": [],
      "line_number": 503
    },
    "empirica.plugins.modality_switcher.plugin_registry.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 95
    },
    "empirica.plugins.modality_switcher.plugin_registry.get_augmented_prompt": {
      "name": "get_augmented_prompt",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Return prompt with epistemic context injected (if snapshot present)\n\nThis method combines the user query with compressed epistemic state\nfrom a previous AI interaction, enabling cross-AI context conti",
      "decorators": [],
      "calls": [
        "to_context_prompt"
      ],
      "line_number": 42
    },
    "empirica.plugins.modality_switcher.plugin_registry.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if adapter is operational.\n\nReturns:\n    bool: True if healthy, False otherwise",
      "decorators": [],
      "calls": [],
      "line_number": 107
    },
    "empirica.plugins.modality_switcher.plugin_registry.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Request authentication from AuthManager.\n\nArgs:\n    meta: Metadata about the auth request (reason, scopes, etc.)\n    \nReturns:\n    Dict with token metadata\n    \nRaises:\n    Exception if authentication",
      "decorators": [],
      "calls": [],
      "line_number": 116
    },
    "empirica.plugins.modality_switcher.plugin_registry.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute model call through this adapter.\n\nArgs:\n    payload: Standard adapter payload\n    token_meta: Authentication token metadata\n    \nReturns:\n    AdapterResponse on success, AdapterError on failur",
      "decorators": [],
      "calls": [],
      "line_number": 131
    },
    "empirica.plugins.modality_switcher.plugin_registry.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 153
    },
    "empirica.plugins.modality_switcher.plugin_registry.register": {
      "name": "register",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "name",
        "adapter_class",
        "metadata"
      ],
      "returns": "",
      "docstring": "Register an adapter manually.\n\nArgs:\n    name: Adapter identifier (e.g., \"openai\", \"local\", \"copilot\")\n    adapter_class: Class implementing AdapterInterface\n    metadata: Optional metadata (version, ",
      "decorators": [],
      "calls": [
        "_validates_interface",
        "ValueError",
        "info"
      ],
      "line_number": 157
    },
    "empirica.plugins.modality_switcher.plugin_registry._validates_interface": {
      "name": "_validates_interface",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "adapter_class"
      ],
      "returns": "bool",
      "docstring": "Check if adapter class implements required methods.\n\nArgs:\n    adapter_class: Class to validate\n    \nReturns:\n    bool: True if valid, False otherwise",
      "decorators": [],
      "calls": [
        "hasattr",
        "error",
        "getattr",
        "callable"
      ],
      "line_number": 174
    },
    "empirica.plugins.modality_switcher.plugin_registry.discover_adapters": {
      "name": "discover_adapters",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "adapter_dir"
      ],
      "returns": "",
      "docstring": "Discover and register adapters from a directory.\n\nLooks for Python modules matching *_adapter.py pattern.\n\nArgs:\n    adapter_dir: Directory to search for adapters",
      "decorators": [],
      "calls": [
        "list",
        "glob",
        "warning",
        "error",
        "info",
        "Path",
        "_load_adapter_module",
        "len",
        "exists"
      ],
      "line_number": 198
    },
    "empirica.plugins.modality_switcher.plugin_registry._load_adapter_module": {
      "name": "_load_adapter_module",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "module_path"
      ],
      "returns": "",
      "docstring": "Load a single adapter module and register it.\n\nArgs:\n    module_path: Path to adapter Python file",
      "decorators": [],
      "calls": [
        "getmembers",
        "ImportError",
        "warning",
        "hasattr",
        "replace",
        "endswith",
        "spec_from_file_location",
        "register",
        "module_from_spec",
        "exec_module"
      ],
      "line_number": 223
    },
    "empirica.plugins.modality_switcher.plugin_registry.get_adapter": {
      "name": "get_adapter",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self",
        "name",
        "config"
      ],
      "returns": "Any",
      "docstring": "Get an instantiated adapter by name.\n\nArgs:\n    name: Adapter identifier\n    config: Optional configuration to pass to adapter constructor\n    \nReturns:\n    Instantiated adapter instance\n    \nRaises:\n",
      "decorators": [],
      "calls": [
        "list",
        "adapter_class",
        "KeyError",
        "keys"
      ],
      "line_number": 260
    },
    "empirica.plugins.modality_switcher.plugin_registry.list_adapters": {
      "name": "list_adapters",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "List all registered adapters with metadata.\n\nReturns:\n    List of dicts with adapter info",
      "decorators": [],
      "calls": [
        "append",
        "get"
      ],
      "line_number": 289
    },
    "empirica.plugins.modality_switcher.plugin_registry.health_check_all": {
      "name": "health_check_all",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "params": [
        "self"
      ],
      "returns": "Dict[str, bool]",
      "docstring": "Run health checks on all registered adapters.\n\nReturns:\n    Dict mapping adapter name to health status",
      "decorators": [],
      "calls": [
        "error",
        "get_adapter",
        "health_check"
      ],
      "line_number": 306
    },
    "empirica.plugins.modality_switcher.epistemic_extractor.extract_epistemic_vectors": {
      "name": "extract_epistemic_vectors",
      "module": "empirica.plugins.modality_switcher.epistemic_extractor",
      "params": [
        "response_text",
        "thinking_blocks",
        "query"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Extract epistemic vectors from AI response and thinking blocks.\n\nArgs:\n    response_text: The AI's response\n    thinking_blocks: Optional thinking/reasoning blocks\n    query: The user's query\n\nReturns",
      "decorators": [],
      "calls": [
        "findall",
        "round",
        "search",
        "split",
        "join",
        "info",
        "min",
        "len",
        "max",
        "lower",
        "sum"
      ],
      "line_number": 15
    },
    "empirica.plugins.modality_switcher.epistemic_extractor.extract_decision": {
      "name": "extract_decision",
      "module": "empirica.plugins.modality_switcher.epistemic_extractor",
      "params": [
        "response_text",
        "thinking_blocks"
      ],
      "returns": "tuple[str, float]",
      "docstring": "Extract decision and confidence from AI response.\n\nReturns:\n    Tuple of (decision, confidence) where decision is ACT|CHECK|INVESTIGATE|VERIFY",
      "decorators": [],
      "calls": [
        "any",
        "lower",
        "join",
        "sum"
      ],
      "line_number": 210
    },
    "empirica.plugins.modality_switcher.register_adapters.get_registry": {
      "name": "get_registry",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [
        "force_reload"
      ],
      "returns": "PluginRegistry",
      "docstring": "Get or create the global plugin registry with all adapters registered.\n\nArgs:\n    force_reload: If True, recreate registry even if it exists\n    \nReturns:\n    PluginRegistry with all adapters register",
      "decorators": [],
      "calls": [
        "create_registry"
      ],
      "line_number": 30
    },
    "empirica.plugins.modality_switcher.register_adapters.create_registry": {
      "name": "create_registry",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [],
      "returns": "PluginRegistry",
      "docstring": "Create a new PluginRegistry and register all available adapters.\n\nReturns:\n    PluginRegistry with adapters registered",
      "decorators": [],
      "calls": [
        "warning",
        "debug",
        "error",
        "PluginRegistry",
        "info",
        "len",
        "register",
        "list_adapters"
      ],
      "line_number": 48
    },
    "empirica.plugins.modality_switcher.register_adapters.register_custom_adapter": {
      "name": "register_custom_adapter",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [
        "name",
        "adapter_class",
        "metadata"
      ],
      "returns": "",
      "docstring": "Register a custom adapter to the global registry.\n\nArgs:\n    name: Adapter identifier\n    adapter_class: Class implementing AdapterInterface\n    metadata: Optional metadata dictionary",
      "decorators": [],
      "calls": [
        "get_registry",
        "register",
        "info"
      ],
      "line_number": 146
    },
    "empirica.plugins.modality_switcher.register_adapters.list_registered_adapters": {
      "name": "list_registered_adapters",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [],
      "returns": "list",
      "docstring": "Get list of all registered adapters with metadata.\n\nReturns:\n    List of adapter info dicts",
      "decorators": [],
      "calls": [
        "get_registry",
        "list_adapters"
      ],
      "line_number": 160
    },
    "empirica.plugins.modality_switcher.register_adapters.health_check_adapters": {
      "name": "health_check_adapters",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [],
      "returns": "dict",
      "docstring": "Run health checks on all registered adapters.\n\nReturns:\n    Dict mapping adapter name to health status (bool)",
      "decorators": [],
      "calls": [
        "get_registry",
        "health_check_all"
      ],
      "line_number": 171
    },
    "empirica.plugins.modality_switcher.register_adapters.get_adapter": {
      "name": "get_adapter",
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "params": [
        "name",
        "config"
      ],
      "returns": "",
      "docstring": "Get an instantiated adapter by name.\n\nArgs:\n    name: Adapter identifier ('minimax', 'qwen', 'local')\n    config: Optional configuration dict\n    \nReturns:\n    Instantiated adapter instance\n    \nRaise",
      "decorators": [],
      "calls": [
        "get_registry",
        "get_adapter"
      ],
      "line_number": 183
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize OpenRouter adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - timeout: Request timeout in seconds (default",
      "decorators": [],
      "calls": [
        "Session",
        "get_credentials_loader",
        "get",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_base_url",
        "get_default_model",
        "get_api_key",
        "ValueError",
        "get_headers"
      ],
      "line_number": 44
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if OpenRouter adapter is properly configured.\n\nReturns:\n    bool: True if API key is present and valid format",
      "decorators": [],
      "calls": [
        "debug",
        "warning",
        "startswith",
        "error"
      ],
      "line_number": 83
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate for OpenRouter calls (uses API key).\n\nArgs:\n    meta: Metadata about auth request\n    \nReturns:\n    Dict with minimal token metadata",
      "decorators": [],
      "calls": [
        "debug",
        "error"
      ],
      "line_number": 107
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute OpenRouter API call and parse response.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Auth token metadata\n    \nReturns:\n    AdapterResponse with s",
      "decorators": [],
      "calls": [
        "json",
        "str",
        "debug",
        "_transform_to_schema",
        "error",
        "info",
        "append",
        "increment_transfer_count",
        "post",
        "strip",
        "len",
        "get_augmented_prompt",
        "AdapterError"
      ],
      "line_number": 133
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "params": [
        "self",
        "raw_response",
        "payload",
        "api_result"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform raw OpenRouter response to RESPONSE_SCHEMA.\n\nArgs:\n    raw_response: Raw text from OpenRouter\n    payload: Original payload for context\n    api_result: Full API response for metadata\n    \nRe",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "insert",
        "get",
        "lower"
      ],
      "line_number": 262
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize MiniMax adapter\n\nArgs:\n    model: Model name (always MiniMax-M2 for this provider)\n    config: Additional configuration",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "warning",
        "get",
        "get_provider_config",
        "info",
        "get_api_key",
        "ValueError",
        "Anthropic",
        "ImportError"
      ],
      "line_number": 39
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if adapter is configured",
      "decorators": [],
      "calls": [
        "bool"
      ],
      "line_number": 80
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate",
      "decorators": [],
      "calls": [],
      "line_number": 84
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute MiniMax M2 API call via Anthropic SDK\n\nArgs:\n    payload: Adapter payload with query and context\n    token_meta: Dictionary to store token usage metadata\n\nReturns:\n    AdapterResponse or Adapt",
      "decorators": [],
      "calls": [
        "create",
        "str",
        "debug",
        "update",
        "_transform_to_schema",
        "error",
        "join",
        "type",
        "info",
        "append",
        "increment_transfer_count",
        "strip",
        "max",
        "AdapterError",
        "min",
        "get_augmented_prompt"
      ],
      "line_number": 88
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.stream_call": {
      "name": "stream_call",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self",
        "payload"
      ],
      "returns": "Any",
      "docstring": "Execute streaming MiniMax M2 API call\n\nArgs:\n    payload: Adapter payload with query and context\n\nYields:\n    Streaming response chunks",
      "decorators": [],
      "calls": [
        "create",
        "str",
        "hasattr",
        "debug",
        "error",
        "info",
        "increment_transfer_count",
        "max",
        "min",
        "get_augmented_prompt"
      ],
      "line_number": 206
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "params": [
        "self",
        "response_text",
        "usage",
        "thinking",
        "payload"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform MiniMax response to RESPONSE_SCHEMA\n\nUses genuine epistemic extraction from thinking blocks (AI's internal reasoning).\nThis is more accurate than heuristics because it reflects actual though",
      "decorators": [],
      "calls": [
        "extract_decision_from_thinking",
        "extract_from_thinking_semantically",
        "AdapterResponse",
        "join",
        "len",
        "get",
        "insert"
      ],
      "line_number": 282
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize Qodo adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - cli_path: Path to qodo CLI (default: 'qodo')\n     ",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_base_url",
        "get_default_model",
        "get_api_key",
        "ValueError",
        "get"
      ],
      "line_number": 44
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if Qodo CLI is available and working.\n\nReturns:\n    bool: True if healthy",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "warning",
        "debug"
      ],
      "line_number": 83
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate for Qodo calls (uses API key from environment).\n\nArgs:\n    meta: Metadata about auth request\n    \nReturns:\n    Dict with minimal token metadata",
      "decorators": [],
      "calls": [
        "debug"
      ],
      "line_number": 127
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute Qodo CLI call and parse response.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Auth token metadata (unused for CLI)\n    \nReturns:\n    AdapterResp",
      "decorators": [],
      "calls": [
        "str",
        "debug",
        "run",
        "_transform_to_schema",
        "error",
        "join",
        "info",
        "append",
        "increment_transfer_count",
        "loads",
        "strip",
        "isinstance",
        "get_augmented_prompt",
        "AdapterError"
      ],
      "line_number": 145
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "params": [
        "self",
        "raw_response",
        "payload"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform raw Qodo response to RESPONSE_SCHEMA.\n\nArgs:\n    raw_response: Raw text from Qodo\n    payload: Original payload for context\n    \nReturns:\n    AdapterResponse",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "insert",
        "lower"
      ],
      "line_number": 255
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize Rovodev adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - port: Server port (default: 8123)\n           - ",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "get",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_base_url",
        "get_default_model",
        "get_api_key",
        "ValueError",
        "get_headers"
      ],
      "line_number": 56
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._start_server": {
      "name": "_start_server",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Start Rovo Dev server in background.",
      "decorators": [],
      "calls": [
        "Popen",
        "sleep",
        "str",
        "error",
        "info",
        "range",
        "get"
      ],
      "line_number": 102
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._stop_server": {
      "name": "_stop_server",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Stop Rovo Dev server.",
      "decorators": [],
      "calls": [
        "terminate",
        "wait",
        "kill",
        "info"
      ],
      "line_number": 148
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if Rovo Dev server is accessible.\n\nReturns:\n    bool: True if healthy, False otherwise",
      "decorators": [],
      "calls": [
        "json",
        "warning",
        "debug",
        "_start_server",
        "get"
      ],
      "line_number": 160
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate with Rovo Dev.\n\nNote: Authentication is handled by ACLI auth system.\nThis just verifies the server is accessible.\n\nArgs:\n    meta: Metadata about the auth request\n    \nReturns:\n    Dict w",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "_start_server",
        "health_check",
        "info"
      ],
      "line_number": 190
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "",
      "docstring": "Execute Rovo Dev query via server mode.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Authentication token metadata\n    \nReturns:\n    AdapterResponse on s",
      "decorators": [],
      "calls": [
        "startswith",
        "str",
        "debug",
        "authenticate",
        "_transform_to_schema",
        "decode",
        "error",
        "post",
        "info",
        "increment_transfer_count",
        "iter_lines",
        "loads",
        "append",
        "isinstance",
        "get_augmented_prompt",
        "get",
        "AdapterError"
      ],
      "line_number": 222
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self",
        "response_text",
        "full_data",
        "payload"
      ],
      "returns": "",
      "docstring": "Transform Rovo Dev response to RESPONSE_SCHEMA.\n\nArgs:\n    response_text: Collected text from stream\n    full_data: Full stream data\n    payload: Original payload\n    \nReturns:\n    AdapterResponse wit",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "max",
        "lower"
      ],
      "line_number": 348
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.__del__": {
      "name": "__del__",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Cleanup: stop server if we started it.",
      "decorators": [],
      "calls": [
        "_stop_server"
      ],
      "line_number": 459
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize Gemini adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - cli_path: Path to gemini CLI (default: 'gemini')",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_base_url",
        "get_default_model",
        "get_api_key",
        "ValueError",
        "get"
      ],
      "line_number": 44
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if Gemini CLI is available and working.\n\nReturns:\n    bool: True if healthy",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "warning",
        "debug"
      ],
      "line_number": 83
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate for Gemini calls (uses API key from environment).\n\nArgs:\n    meta: Metadata about auth request\n    \nReturns:\n    Dict with minimal token metadata",
      "decorators": [],
      "calls": [
        "debug"
      ],
      "line_number": 127
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute Gemini CLI call and parse response.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Auth token metadata (unused for CLI)\n    \nReturns:\n    AdapterRe",
      "decorators": [],
      "calls": [
        "str",
        "debug",
        "run",
        "_transform_to_schema",
        "error",
        "join",
        "info",
        "append",
        "increment_transfer_count",
        "loads",
        "strip",
        "isinstance",
        "get_augmented_prompt",
        "AdapterError",
        "extend"
      ],
      "line_number": 145
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "params": [
        "self",
        "raw_response",
        "payload"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform raw Gemini response to RESPONSE_SCHEMA.\n\nArgs:\n    raw_response: Raw text from Gemini\n    payload: Original payload for context\n    \nReturns:\n    AdapterResponse",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "insert",
        "lower"
      ],
      "line_number": 259
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize Copilot adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - cli_path: Path to copilot CLI (default: 'copilo",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_default_model",
        "ValueError",
        "get"
      ],
      "line_number": 59
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if Copilot CLI is available and working.\n\nReturns:\n    bool: True if healthy",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "debug",
        "error",
        "strip"
      ],
      "line_number": 94
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate for Copilot calls (uses GitHub authentication).\n\nArgs:\n    meta: Metadata about auth request\n    \nReturns:\n    Dict with minimal token metadata",
      "decorators": [],
      "calls": [
        "debug"
      ],
      "line_number": 127
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute Copilot CLI call and parse response.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Auth token metadata (unused for CLI)\n    \nReturns:\n    AdapterR",
      "decorators": [],
      "calls": [
        "_parse_token_usage",
        "str",
        "debug",
        "run",
        "_transform_to_schema",
        "error",
        "split",
        "join",
        "info",
        "append",
        "increment_transfer_count",
        "strip",
        "get_augmented_prompt",
        "AdapterError"
      ],
      "line_number": 145
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter._parse_token_usage": {
      "name": "_parse_token_usage",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self",
        "output"
      ],
      "returns": "Dict[str, int]",
      "docstring": "Parse token usage from Copilot CLI output.\n\nExample output:\n    claude-sonnet-4      23.0k input, 10 output, 0 cache read, 0 cache write\n\nArgs:\n    output: Full CLI output\n    \nReturns:\n    Dict with ",
      "decorators": [],
      "calls": [
        "warning",
        "int",
        "search",
        "split",
        "float",
        "group"
      ],
      "line_number": 269
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "params": [
        "self",
        "raw_response",
        "payload",
        "token_usage"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform raw Copilot response to RESPONSE_SCHEMA.\n\nArgs:\n    raw_response: Raw text from Copilot\n    payload: Original payload for context\n    token_usage: Parsed token usage stats\n    \nReturns:\n    ",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "insert",
        "get",
        "lower"
      ],
      "line_number": 314
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.__init__": {
      "name": "__init__",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "params": [
        "self",
        "model",
        "config"
      ],
      "returns": "",
      "docstring": "Initialize Qwen adapter.\n\nArgs:\n    model: Model to use (defaults to config default_model)\n    config: Configuration dict with optional:\n           - cli_path: Path to qwen CLI (default: 'qwen')\n     ",
      "decorators": [],
      "calls": [
        "get_credentials_loader",
        "get_provider_config",
        "validate_model",
        "get_available_models",
        "info",
        "get_base_url",
        "get_default_model",
        "get_api_key",
        "ValueError",
        "get"
      ],
      "line_number": 46
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.health_check": {
      "name": "health_check",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if Qwen CLI is available and working.\n\nReturns:\n    bool: True if healthy",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "warning",
        "debug"
      ],
      "line_number": 83
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.authenticate": {
      "name": "authenticate",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "params": [
        "self",
        "meta"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Authenticate for Qwen calls (local CLI, no auth needed).\n\nArgs:\n    meta: Metadata about auth request\n    \nReturns:\n    Dict with minimal token metadata",
      "decorators": [],
      "calls": [
        "debug"
      ],
      "line_number": 128
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.call": {
      "name": "call",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "params": [
        "self",
        "payload",
        "token_meta"
      ],
      "returns": "AdapterResponse | AdapterError",
      "docstring": "Execute Qwen CLI call and parse response.\n\nArgs:\n    payload: Standard adapter payload (supports epistemic snapshots)\n    token_meta: Auth token metadata (unused for local CLI)\n    \nReturns:\n    Adapt",
      "decorators": [],
      "calls": [
        "str",
        "debug",
        "run",
        "_transform_to_schema",
        "error",
        "join",
        "info",
        "loads",
        "increment_transfer_count",
        "strip",
        "isinstance",
        "get_augmented_prompt",
        "AdapterError",
        "extend"
      ],
      "line_number": 146
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter._transform_to_schema": {
      "name": "_transform_to_schema",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "params": [
        "self",
        "raw_response",
        "payload"
      ],
      "returns": "AdapterResponse",
      "docstring": "Transform raw Qwen response to RESPONSE_SCHEMA.\n\nPhase 1: Simple heuristic-based transformation.\nFuture: Use PersonaEnforcer for proper validation.\n\nArgs:\n    raw_response: Raw text from Qwen\n    payl",
      "decorators": [],
      "calls": [
        "AdapterResponse",
        "split",
        "min",
        "len",
        "any",
        "insert",
        "lower"
      ],
      "line_number": 277
    },
    "empirica.core.git_ops.signed_operations.__init__": {
      "name": "__init__",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "repo_path",
        "enforce_cascade_phases"
      ],
      "returns": "",
      "docstring": "Initialize Git operations\n\nArgs:\n    repo_path: Path to git repository (default: current dir)\n    enforce_cascade_phases: If True, enforce CASCADE phase ordering and validation\n                       ",
      "decorators": [],
      "calls": [
        "info",
        "lower",
        "getenv",
        "GitRepo"
      ],
      "line_number": 86
    },
    "empirica.core.git_ops.signed_operations.commit_signed_state": {
      "name": "commit_signed_state",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "signing_persona",
        "epistemic_state",
        "phase",
        "message",
        "additional_data",
        "required_personas"
      ],
      "returns": "str",
      "docstring": "Create a Git commit with signed epistemic state in notes\n\nFlow:\n1. Sign the epistemic state with persona's private key\n2. Store signed state in git notes\n3. Create commit with persona as author\n4. Ret",
      "decorators": [],
      "calls": [
        "get_persona_info",
        "_validate_cascade_phase",
        "Actor",
        "error",
        "info",
        "commit",
        "GitCommandError",
        "notes",
        "sign_epistemic_state",
        "dumps"
      ],
      "line_number": 108
    },
    "empirica.core.git_ops.signed_operations.get_signed_state_from_commit": {
      "name": "get_signed_state_from_commit",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "commit_sha"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Retrieve signed epistemic state from commit's git notes\n\nArgs:\n    commit_sha: Commit SHA hash\n\nReturns:\n    Dict with signed state, or None if no notes found",
      "decorators": [],
      "calls": [
        "loads",
        "notes"
      ],
      "line_number": 193
    },
    "empirica.core.git_ops.signed_operations.verify_cascade_chain": {
      "name": "verify_cascade_chain",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "start_commit",
        "end_commit",
        "known_personas"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Verify entire CASCADE trace from start to end commit\n\nFor each commit in the range:\n1. Get commit metadata\n2. Load signed state from git notes\n3. Verify signature with persona's public key\n4. Return v",
      "decorators": [],
      "calls": [
        "list",
        "warning",
        "encode",
        "str",
        "isoformat",
        "verify",
        "error",
        "split",
        "info",
        "append",
        "len",
        "iter_commits",
        "get",
        "get_signed_state_from_commit",
        "dumps",
        "fromhex"
      ],
      "line_number": 214
    },
    "empirica.core.git_ops.signed_operations.export_cascade_report": {
      "name": "export_cascade_report",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "start_commit",
        "end_commit",
        "output_file"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Export CASCADE chain verification report\n\nCreates a JSON report of all verifications that can be:\n- Stored for audit purposes\n- Shared with collaborators\n- Used for reproducibility verification\n\nArgs:",
      "decorators": [],
      "calls": [
        "list",
        "all",
        "open",
        "str",
        "isoformat",
        "mkdir",
        "dump",
        "Path",
        "info",
        "verify_cascade_chain",
        "len",
        "now",
        "get",
        "set",
        "sum"
      ],
      "line_number": 347
    },
    "empirica.core.git_ops.signed_operations._validate_cascade_phase": {
      "name": "_validate_cascade_phase",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "phase",
        "required_personas"
      ],
      "returns": "None",
      "docstring": "Validate CASCADE phase ordering and requirements\n\nArgs:\n    phase: CASCADE phase (PREFLIGHT, INVESTIGATE, CHECK, ACT, POSTFLIGHT)\n    required_personas: List of personas that must sign this phase\n\nRai",
      "decorators": [],
      "calls": [
        "index",
        "_get_last_cascade_phase",
        "join",
        "info",
        "ValueError"
      ],
      "line_number": 402
    },
    "empirica.core.git_ops.signed_operations._get_last_cascade_phase": {
      "name": "_get_last_cascade_phase",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self"
      ],
      "returns": "Optional[str]",
      "docstring": "Get the last CASCADE phase that was committed\n\nReturns:\n    Last phase string or None if no phases committed yet",
      "decorators": [],
      "calls": [
        "warning",
        "split",
        "log"
      ],
      "line_number": 442
    },
    "empirica.core.git_ops.signed_operations.get_cascade_timeline": {
      "name": "get_cascade_timeline",
      "module": "empirica.core.git_ops.signed_operations",
      "params": [
        "self",
        "start_commit",
        "end_commit"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get epistemic timeline for CASCADE phases\n\nReturns chronological sequence of epistemic states through CASCADE\n\nArgs:\n    start_commit: Starting commit\n    end_commit: Ending commit\n\nReturns:\n    List ",
      "decorators": [],
      "calls": [
        "get",
        "verify_cascade_chain",
        "sort"
      ],
      "line_number": 466
    },
    "empirica.core.persona.signing_persona.__init__": {
      "name": "__init__",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self",
        "persona_profile",
        "ai_identity"
      ],
      "returns": "",
      "docstring": "Initialize a signing persona\n\nArgs:\n    persona_profile: The epistemic definition\n    ai_identity: The Ed25519 identity (must have keypair loaded)\n\nRaises:\n    ValueError: If identity has no public ke",
      "decorators": [],
      "calls": [
        "ValueError",
        "info"
      ],
      "line_number": 79
    },
    "empirica.core.persona.signing_persona._create_canonical_state": {
      "name": "_create_canonical_state",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self",
        "epistemic_vectors",
        "phase"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Create canonical representation of epistemic state\n\nThis is deterministic so the same state always produces the same JSON,\nwhich is critical for signature verification.\n\nArgs:\n    epistemic_vectors: T",
      "decorators": [],
      "calls": [
        "isoformat",
        "public_key_hex",
        "sorted",
        "now",
        "ValueError"
      ],
      "line_number": 102
    },
    "empirica.core.persona.signing_persona.sign_epistemic_state": {
      "name": "sign_epistemic_state",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self",
        "epistemic_vectors",
        "phase",
        "additional_data"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Sign an epistemic state with the persona's private key\n\nArgs:\n    epistemic_vectors: Dict with 13 epistemic vectors\n    phase: CASCADE phase name\n    additional_data: Optional extra data to include (n",
      "decorators": [],
      "calls": [
        "hex",
        "_create_canonical_state",
        "sign",
        "info",
        "encode",
        "dumps"
      ],
      "line_number": 150
    },
    "empirica.core.persona.signing_persona.verify_signature": {
      "name": "verify_signature",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self",
        "signed_state"
      ],
      "returns": "bool",
      "docstring": "Verify a previously signed epistemic state\n\nArgs:\n    signed_state: Dict with state, signature, and algorithm\n\nReturns:\n    bool: True if signature is valid",
      "decorators": [],
      "calls": [
        "warning",
        "verify",
        "public_key_hex",
        "error",
        "info",
        "get",
        "encode",
        "dumps",
        "fromhex"
      ],
      "line_number": 203
    },
    "empirica.core.persona.signing_persona.get_persona_info": {
      "name": "get_persona_info",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get public information about this persona\n\nReturns:\n    Dict with persona_id, name, public_key, focus_domains, etc.",
      "decorators": [],
      "calls": [
        "public_key_hex",
        "get_type"
      ],
      "line_number": 263
    },
    "empirica.core.persona.signing_persona.export_public_persona": {
      "name": "export_public_persona",
      "module": "empirica.core.persona.signing_persona",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Export persona for public registry (Qdrant)\n\nThis contains everything needed to verify signatures except the\nprivate key, which remains only in AIIdentity storage.\n\nReturns:\n    Dict suitable for stor",
      "decorators": [],
      "calls": [
        "public_key_hex",
        "get_type",
        "asdict"
      ],
      "line_number": 281
    },
    "empirica.core.persona.persona_manager.__init__": {
      "name": "__init__",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "personas_dir"
      ],
      "returns": "",
      "docstring": "Initialize PersonaManager\n\nArgs:\n    personas_dir: Custom directory for persona storage\n                 (default: .empirica/personas)",
      "decorators": [],
      "calls": [
        "mkdir",
        "Path"
      ],
      "line_number": 45
    },
    "empirica.core.persona.persona_manager.create_persona": {
      "name": "create_persona",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "persona_id",
        "name",
        "version",
        "user_id",
        "identity_name",
        "epistemic_priors",
        "focus_domains",
        "template"
      ],
      "returns": "PersonaProfile",
      "docstring": "Create a new persona profile\n\nArgs:\n    persona_id: Unique identifier\n    name: Human-readable name\n    version: Semantic version\n    user_id: User who owns this persona\n    identity_name: Identity fo",
      "decorators": [],
      "calls": [
        "PersonaProfile",
        "_get_or_create_signing_identity",
        "info",
        "_create_from_template",
        "EpistemicConfig",
        "_get_default_priors"
      ],
      "line_number": 56
    },
    "empirica.core.persona.persona_manager.save_persona": {
      "name": "save_persona",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "profile",
        "overwrite"
      ],
      "returns": "Path",
      "docstring": "Save persona to disk\n\nArgs:\n    profile: PersonaProfile to save\n    overwrite: Allow overwriting existing persona\n\nReturns:\n    Path to saved file\n\nRaises:\n    FileExistsError: If persona exists and o",
      "decorators": [],
      "calls": [
        "open",
        "to_dict",
        "dump",
        "info",
        "FileExistsError",
        "exists",
        "validate_persona_profile"
      ],
      "line_number": 130
    },
    "empirica.core.persona.persona_manager.load_persona": {
      "name": "load_persona",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "persona_id"
      ],
      "returns": "PersonaProfile",
      "docstring": "Load persona from disk\n\nArgs:\n    persona_id: Persona identifier\n\nReturns:\n    PersonaProfile instance\n\nRaises:\n    FileNotFoundError: If persona doesn't exist\n    ValidationError: If persona file inv",
      "decorators": [],
      "calls": [
        "open",
        "from_dict",
        "FileNotFoundError",
        "info",
        "exists",
        "validate_persona_profile",
        "load"
      ],
      "line_number": 165
    },
    "empirica.core.persona.persona_manager.list_personas": {
      "name": "list_personas",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self"
      ],
      "returns": "List[str]",
      "docstring": "List all available personas\n\nReturns:\n    List of persona IDs",
      "decorators": [],
      "calls": [
        "glob"
      ],
      "line_number": 198
    },
    "empirica.core.persona.persona_manager.delete_persona": {
      "name": "delete_persona",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "persona_id"
      ],
      "returns": "None",
      "docstring": "Delete a persona\n\nArgs:\n    persona_id: Persona to delete\n\nRaises:\n    FileNotFoundError: If persona doesn't exist",
      "decorators": [],
      "calls": [
        "FileNotFoundError",
        "exists",
        "unlink",
        "info"
      ],
      "line_number": 208
    },
    "empirica.core.persona.persona_manager.get_persona_type": {
      "name": "get_persona_type",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "persona_id"
      ],
      "returns": "str",
      "docstring": "Get persona type based on focus domains\n\nArgs:\n    persona_id: Persona identifier\n\nReturns:\n    Persona type (security, ux, performance, etc.)",
      "decorators": [],
      "calls": [
        "get_type",
        "load_persona"
      ],
      "line_number": 226
    },
    "empirica.core.persona.persona_manager._get_or_create_signing_identity": {
      "name": "_get_or_create_signing_identity",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "user_id",
        "identity_name"
      ],
      "returns": "SigningIdentityConfig",
      "docstring": "Get existing signing identity or create new one\n\nIntegrates with Phase 2 AIIdentity system",
      "decorators": [],
      "calls": [
        "hex",
        "public_bytes_raw",
        "load_keypair",
        "SigningIdentityConfig",
        "info",
        "save_keypair",
        "AIIdentity",
        "generate_keypair"
      ],
      "line_number": 241
    },
    "empirica.core.persona.persona_manager._get_default_priors": {
      "name": "_get_default_priors",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Get default epistemic priors (neutral)",
      "decorators": [],
      "calls": [],
      "line_number": 275
    },
    "empirica.core.persona.persona_manager._create_from_template": {
      "name": "_create_from_template",
      "module": "empirica.core.persona.persona_manager",
      "params": [
        "self",
        "template",
        "persona_id",
        "name",
        "version",
        "user_id"
      ],
      "returns": "PersonaProfile",
      "docstring": "Create persona from built-in template",
      "decorators": [],
      "calls": [
        "list",
        "keys",
        "PersonaProfile",
        "_get_or_create_signing_identity",
        "info",
        "replace",
        "EpistemicConfig",
        "ValueError"
      ],
      "line_number": 293
    },
    "empirica.core.persona.persona_profile.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.persona.persona_profile",
      "params": [
        "self"
      ],
      "returns": "Dict",
      "docstring": "Convert to dictionary for JSON serialization",
      "decorators": [],
      "calls": [
        "to_dict"
      ],
      "line_number": 217
    },
    "empirica.core.persona.persona_profile.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.core.persona.persona_profile",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Validate persona profile",
      "decorators": [],
      "calls": [
        "match",
        "len",
        "ValueError"
      ],
      "line_number": 202
    },
    "empirica.core.persona.persona_profile._parse_sentinel_config": {
      "name": "_parse_sentinel_config",
      "module": "empirica.core.persona.persona_profile",
      "params": [
        "cls",
        "sentinel_data"
      ],
      "returns": "'SentinelConfig'",
      "docstring": "Parse sentinel config from dictionary",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "copy",
        "EscalationTrigger",
        "pop",
        "SentinelConfig",
        "get"
      ],
      "line_number": 231
    },
    "empirica.core.persona.persona_profile.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.persona.persona_profile",
      "params": [
        "cls",
        "data"
      ],
      "returns": "'PersonaProfile'",
      "docstring": "Load persona profile from dictionary",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "_parse_sentinel_config",
        "SigningIdentityConfig",
        "PersonaMetadata",
        "EpistemicConfig",
        "CapabilitiesConfig",
        "get",
        "cls"
      ],
      "line_number": 249
    },
    "empirica.core.persona.persona_profile.get_type": {
      "name": "get_type",
      "module": "empirica.core.persona.persona_profile",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Get persona type based on focus domains",
      "decorators": [],
      "calls": [
        "any"
      ],
      "line_number": 262
    },
    "empirica.core.persona.validation.load_schema": {
      "name": "load_schema",
      "module": "empirica.core.persona.validation",
      "params": [],
      "returns": "Dict",
      "docstring": "Load the persona JSON schema",
      "decorators": [],
      "calls": [
        "open",
        "FileNotFoundError",
        "Path",
        "exists",
        "load"
      ],
      "line_number": 19
    },
    "empirica.core.persona.validation.validate_persona_profile": {
      "name": "validate_persona_profile",
      "module": "empirica.core.persona.validation",
      "params": [
        "profile_data"
      ],
      "returns": "None",
      "docstring": "Validate persona profile against JSON schema\n\nArgs:\n    profile_data: Persona profile as dictionary\n\nRaises:\n    ValidationError: If validation fails",
      "decorators": [],
      "calls": [
        "ValidationError",
        "str",
        "_validate_business_logic",
        "join",
        "info",
        "validate",
        "get",
        "load_schema"
      ],
      "line_number": 29
    },
    "empirica.core.persona.validation._validate_business_logic": {
      "name": "_validate_business_logic",
      "module": "empirica.core.persona.validation",
      "params": [
        "profile_data"
      ],
      "returns": "None",
      "docstring": "Additional validation beyond JSON schema\n\nChecks:\n- Weights sum to 1.0\n- Thresholds are reasonable\n- Focus domains not empty\n- Escalation triggers are valid",
      "decorators": [],
      "calls": [
        "ValidationError",
        "warning",
        "_validate_escalation_trigger",
        "values",
        "get",
        "sum"
      ],
      "line_number": 55
    },
    "empirica.core.persona.validation._validate_escalation_trigger": {
      "name": "_validate_escalation_trigger",
      "module": "empirica.core.persona.validation",
      "params": [
        "trigger"
      ],
      "returns": "None",
      "docstring": "Validate escalation trigger condition syntax",
      "decorators": [],
      "calls": [
        "debug",
        "ValidationError",
        "any"
      ],
      "line_number": 91
    },
    "empirica.core.skills.parser.parse_markdown_to_skill": {
      "name": "parse_markdown_to_skill",
      "module": "empirica.core.skills.parser",
      "params": [
        "md_text",
        "name",
        "tags"
      ],
      "returns": "Dict",
      "docstring": "",
      "decorators": [],
      "calls": [
        "match",
        "startswith",
        "join",
        "splitlines",
        "sub",
        "append",
        "setdefault",
        "group",
        "strip",
        "extract_paragraph",
        "extract_list",
        "get",
        "lower"
      ],
      "line_number": 11
    },
    "empirica.core.skills.parser.extract_list": {
      "name": "extract_list",
      "module": "empirica.core.skills.parser",
      "params": [
        "sec_key"
      ],
      "returns": "List[str]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "strip",
        "append",
        "startswith"
      ],
      "line_number": 24
    },
    "empirica.core.skills.parser.extract_paragraph": {
      "name": "extract_paragraph",
      "module": "empirica.core.skills.parser",
      "params": [
        "sec_key"
      ],
      "returns": "str",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "strip",
        "join"
      ],
      "line_number": 33
    },
    "empirica.core.goals.repository.__init__": {
      "name": "__init__",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "db_path"
      ],
      "returns": "",
      "docstring": "Initialize repository\n\nArgs:\n    db_path: Optional custom database path",
      "decorators": [],
      "calls": [
        "_ensure_tables",
        "SessionDatabase"
      ],
      "line_number": 23
    },
    "empirica.core.goals.repository._ensure_tables": {
      "name": "_ensure_tables",
      "module": "empirica.core.goals.repository",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create goal-related tables if they don't exist",
      "decorators": [],
      "calls": [
        "commit",
        "execute",
        "error",
        "info"
      ],
      "line_number": 33
    },
    "empirica.core.goals.repository.save_goal": {
      "name": "save_goal",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "goal",
        "session_id"
      ],
      "returns": "bool",
      "docstring": "Save goal to database\n\nArgs:\n    goal: Goal object to save\n    session_id: Optional session ID to associate with goal\n    \nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "rollback",
        "to_dict",
        "error",
        "info",
        "commit",
        "execute",
        "dumps"
      ],
      "line_number": 86
    },
    "empirica.core.goals.repository.get_goal": {
      "name": "get_goal",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "Optional[Goal]",
      "docstring": "Retrieve goal by ID\n\nArgs:\n    goal_id: Goal identifier\n    \nReturns:\n    Goal object or None if not found",
      "decorators": [],
      "calls": [
        "from_dict",
        "error",
        "loads",
        "fetchone",
        "execute"
      ],
      "line_number": 160
    },
    "empirica.core.goals.repository.get_session_goals": {
      "name": "get_session_goals",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[Goal]",
      "docstring": "Retrieve all goals for a session\n\nArgs:\n    session_id: Session identifier\n    \nReturns:\n    List of Goal objects",
      "decorators": [],
      "calls": [
        "fetchall",
        "from_dict",
        "error",
        "loads",
        "append",
        "execute"
      ],
      "line_number": 187
    },
    "empirica.core.goals.repository.update_goal_completion": {
      "name": "update_goal_completion",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "goal_id",
        "is_completed"
      ],
      "returns": "bool",
      "docstring": "Update goal completion status\n\nArgs:\n    goal_id: Goal identifier\n    is_completed: Completion status\n    \nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "rollback",
        "to_dict",
        "error",
        "get_goal",
        "info",
        "commit",
        "dumps",
        "execute",
        "time"
      ],
      "line_number": 214
    },
    "empirica.core.goals.repository.query_goals": {
      "name": "query_goals",
      "module": "empirica.core.goals.repository",
      "params": [
        "self",
        "session_id",
        "is_completed",
        "scope"
      ],
      "returns": "List[Goal]",
      "docstring": "Query goals with filters\n\nArgs:\n    session_id: Filter by session\n    is_completed: Filter by completion status\n    scope: Filter by scope\n    \nReturns:\n    List of matching Goal objects",
      "decorators": [],
      "calls": [
        "fetchall",
        "to_dict",
        "from_dict",
        "error",
        "loads",
        "append",
        "execute",
        "dumps"
      ],
      "line_number": 256
    },
    "empirica.core.goals.repository.close": {
      "name": "close",
      "module": "empirica.core.goals.repository",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Close database connection",
      "decorators": [],
      "calls": [
        "close"
      ],
      "line_number": 304
    },
    "empirica.core.goals.types.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.core.goals.types",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Validate ranges",
      "decorators": [],
      "calls": [
        "type",
        "isinstance",
        "getattr",
        "ValueError"
      ],
      "line_number": 27
    },
    "empirica.core.goals.types.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.goals.types",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Serialize to dictionary",
      "decorators": [],
      "calls": [
        "to_dict"
      ],
      "line_number": 131
    },
    "empirica.core.goals.types.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.goals.types",
      "params": [
        "data"
      ],
      "returns": "'Goal'",
      "docstring": "Deserialize from dictionary",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "SuccessCriterion",
        "from_dict",
        "Dependency",
        "DependencyType",
        "get",
        "Goal",
        "time"
      ],
      "line_number": 166
    },
    "empirica.core.goals.types.create": {
      "name": "create",
      "module": "empirica.core.goals.types",
      "params": [
        "objective",
        "success_criteria",
        "scope"
      ],
      "returns": "'Goal'",
      "docstring": "Convenience factory method with validation",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "ScopeVector",
        "str",
        "validate_success_criteria",
        "validate_objective",
        "validate_complexity",
        "get",
        "Goal",
        "uuid4",
        "validate_scope_vector"
      ],
      "line_number": 102
    },
    "empirica.core.goals.types.get_subtasks": {
      "name": "get_subtasks",
      "module": "empirica.core.goals.types",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Get all subtasks for this goal\n\nReturns list of SubTask objects from database\n\nNote: Creates its own repository connection for simplicity.\nFor bulk operations, use TaskRepository directly.",
      "decorators": [],
      "calls": [
        "TaskRepository",
        "close",
        "get_goal_subtasks"
      ],
      "line_number": 200
    },
    "empirica.core.goals.types.calculate_progress": {
      "name": "calculate_progress",
      "module": "empirica.core.goals.types",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Calculate goal progress based on subtasks\n\nReturns:\n    {\n        'total_subtasks': int,\n        'completed': int,\n        'in_progress': int,\n        'pending': int,\n        'blocked': int,\n        '",
      "decorators": [],
      "calls": [
        "get",
        "get_subtasks",
        "len"
      ],
      "line_number": 217
    },
    "empirica.core.goals.types.is_ready_for_completion": {
      "name": "is_ready_for_completion",
      "module": "empirica.core.goals.types",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if goal is ready to be marked complete\n\nChecks:\n1. All subtasks completed or skipped (if subtasks exist)\n2. Falls back to is_completed flag if no subtasks\n\nReturns:\n    True if ready for complet",
      "decorators": [],
      "calls": [
        "calculate_progress"
      ],
      "line_number": 286
    },
    "empirica.core.goals.decision_logic.decide_goal_creation": {
      "name": "decide_goal_creation",
      "module": "empirica.core.goals.decision_logic",
      "params": [
        "clarity",
        "signal",
        "know",
        "context",
        "clarity_threshold",
        "signal_threshold",
        "know_threshold",
        "context_threshold"
      ],
      "returns": "GoalDecision",
      "docstring": "Simple decision logic: Should we create a goal now?\n\nLogic:\n1. Check COMPREHENSION (clarity + signal)\n2. Check FOUNDATION (know + context)\n3. Decide based on both\n\nArgs:\n    clarity: How clear is the ",
      "decorators": [],
      "calls": [
        "min",
        "GoalDecision"
      ],
      "line_number": 40
    },
    "empirica.core.goals.decision_logic.get_investigation_focus": {
      "name": "get_investigation_focus",
      "module": "empirica.core.goals.decision_logic",
      "params": [
        "decision"
      ],
      "returns": "Optional[str]",
      "docstring": "Helper: What should investigation focus on?\n\nReturns:\n    String describing investigation focus, or None if not investigating",
      "decorators": [],
      "calls": [],
      "line_number": 155
    },
    "empirica.core.goals.decision_logic.format_decision_for_ai": {
      "name": "format_decision_for_ai",
      "module": "empirica.core.goals.decision_logic",
      "params": [
        "decision"
      ],
      "returns": "str",
      "docstring": "Format decision as natural language for AI reasoning\n\nThis is GUIDANCE for AI, not a command.",
      "decorators": [],
      "calls": [
        "append",
        "upper",
        "join",
        "get_investigation_focus"
      ],
      "line_number": 172
    },
    "empirica.core.goals.validation.validate_objective": {
      "name": "validate_objective",
      "module": "empirica.core.goals.validation",
      "params": [
        "objective"
      ],
      "returns": "None",
      "docstring": "Validate goal objective\n\nArgs:\n    objective: Goal objective string\n    \nRaises:\n    ValidationError: If objective is invalid",
      "decorators": [],
      "calls": [
        "ValidationError",
        "len",
        "strip"
      ],
      "line_number": 21
    },
    "empirica.core.goals.validation.validate_success_criteria": {
      "name": "validate_success_criteria",
      "module": "empirica.core.goals.validation",
      "params": [
        "success_criteria"
      ],
      "returns": "None",
      "docstring": "Validate success criteria list\n\nArgs:\n    success_criteria: List of success criteria\n    \nRaises:\n    ValidationError: If criteria are invalid",
      "decorators": [],
      "calls": [
        "ValidationError",
        "strip",
        "enumerate"
      ],
      "line_number": 38
    },
    "empirica.core.goals.validation.validate_complexity": {
      "name": "validate_complexity",
      "module": "empirica.core.goals.validation",
      "params": [
        "complexity"
      ],
      "returns": "None",
      "docstring": "Validate complexity estimate\n\nArgs:\n    complexity: Complexity value (should be 0.0-1.0)\n    \nRaises:\n    ValidationError: If complexity is out of range",
      "decorators": [],
      "calls": [
        "ValidationError"
      ],
      "line_number": 78
    },
    "empirica.core.goals.validation.validate_scope_vector": {
      "name": "validate_scope_vector",
      "module": "empirica.core.goals.validation",
      "params": [
        "scope"
      ],
      "returns": "None",
      "docstring": "Validate scope vector and check coherence\n\nArgs:\n    scope: ScopeVector to validate\n    \nRaises:\n    ValidationError: If scope values are out of range\n    \nLogs warnings for incoherent combinations (a",
      "decorators": [],
      "calls": [
        "ValidationError",
        "type",
        "isinstance",
        "warning"
      ],
      "line_number": 95
    },
    "empirica.core.goals.validation.validate_goal": {
      "name": "validate_goal",
      "module": "empirica.core.goals.validation",
      "params": [
        "goal"
      ],
      "returns": "None",
      "docstring": "Validate complete goal object\n\nArgs:\n    goal: Goal to validate\n    \nRaises:\n    ValidationError: If goal is invalid",
      "decorators": [],
      "calls": [
        "validate_objective",
        "validate_complexity",
        "validate_scope_vector",
        "validate_success_criteria"
      ],
      "line_number": 135
    },
    "empirica.core.goals.validation.validate_mcp_goal_input": {
      "name": "validate_mcp_goal_input",
      "module": "empirica.core.goals.validation",
      "params": [
        "arguments"
      ],
      "returns": "None",
      "docstring": "Validate MCP create_goal input arguments\n\nArgs:\n    arguments: MCP tool arguments dict\n    \nRaises:\n    ValidationError: If arguments are invalid",
      "decorators": [],
      "calls": [
        "ValidationError",
        "type",
        "enumerate",
        "float",
        "strip",
        "isinstance",
        "get"
      ],
      "line_number": 151
    },
    "empirica.core.goals.validation.validate_mcp_subtask_input": {
      "name": "validate_mcp_subtask_input",
      "module": "empirica.core.goals.validation",
      "params": [
        "arguments"
      ],
      "returns": "None",
      "docstring": "Validate MCP add_subtask input arguments\n\nArgs:\n    arguments: MCP tool arguments dict\n    \nRaises:\n    ValidationError: If arguments are invalid",
      "decorators": [],
      "calls": [
        "ValidationError",
        "int",
        "type",
        "len",
        "strip",
        "isinstance",
        "get"
      ],
      "line_number": 227
    },
    "empirica.core.drift.mirror_drift_monitor.__init__": {
      "name": "__init__",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "drift_threshold",
        "lookback_window",
        "enable_logging"
      ],
      "returns": "",
      "docstring": "Initialize drift monitor\n\nArgs:\n    drift_threshold: Minimum drop to flag as drift (default: 0.2)\n    lookback_window: Number of recent checkpoints to use for baseline (default: 5)\n    enable_logging:",
      "decorators": [],
      "calls": [],
      "line_number": 49
    },
    "empirica.core.drift.mirror_drift_monitor.detect_drift": {
      "name": "detect_drift",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "current_assessment",
        "session_id"
      ],
      "returns": "DriftReport",
      "docstring": "Detect drift by comparing current state to recent history\n\nArgs:\n    current_assessment: Current epistemic assessment\n    session_id: Session UUID\n\nReturns:\n    DriftReport with detection results",
      "decorators": [],
      "calls": [
        "DriftReport",
        "_log_drift",
        "_load_recent_checkpoints",
        "_calculate_baseline",
        "_compare_states"
      ],
      "line_number": 67
    },
    "empirica.core.drift.mirror_drift_monitor._load_recent_checkpoints": {
      "name": "_load_recent_checkpoints",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "session_id",
        "count"
      ],
      "returns": "List[Dict]",
      "docstring": "Load recent checkpoints from Git notes\n\nArgs:\n    session_id: Session UUID\n    count: Number of recent checkpoints to load\n\nReturns:\n    List of checkpoint dicts with vectors",
      "decorators": [],
      "calls": [
        "load_recent_checkpoints",
        "CheckpointManager",
        "warning"
      ],
      "line_number": 106
    },
    "empirica.core.drift.mirror_drift_monitor._calculate_baseline": {
      "name": "_calculate_baseline",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "history"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate baseline by averaging recent checkpoints\n\nArgs:\n    history: List of checkpoint dicts\n\nReturns:\n    Dict mapping vector names to baseline values",
      "decorators": [],
      "calls": [
        "append",
        "len",
        "sum"
      ],
      "line_number": 131
    },
    "empirica.core.drift.mirror_drift_monitor._compare_states": {
      "name": "_compare_states",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "baseline",
        "current"
      ],
      "returns": "DriftReport",
      "docstring": "Compare current state to baseline, detect drift\n\nArgs:\n    baseline: Baseline vector values\n    current: Current epistemic assessment\n\nReturns:\n    DriftReport with detection results",
      "decorators": [],
      "calls": [
        "_extract_vectors",
        "_recommend_action",
        "_classify_drift_pattern",
        "_classify_overall_severity",
        "items",
        "DriftReport",
        "append",
        "len",
        "_classify_drift_severity",
        "max",
        "get"
      ],
      "line_number": 165
    },
    "empirica.core.drift.mirror_drift_monitor._extract_vectors": {
      "name": "_extract_vectors",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Extract vector scores from assessment\n\nArgs:\n    assessment: EpistemicAssessmentSchema\n\nReturns:\n    Dict mapping vector names to scores",
      "decorators": [],
      "calls": [
        "hasattr",
        "getattr"
      ],
      "line_number": 233
    },
    "empirica.core.drift.mirror_drift_monitor._classify_drift_severity": {
      "name": "_classify_drift_severity",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "drift"
      ],
      "returns": "str",
      "docstring": "Classify single vector drift severity",
      "decorators": [],
      "calls": [],
      "line_number": 266
    },
    "empirica.core.drift.mirror_drift_monitor._classify_overall_severity": {
      "name": "_classify_overall_severity",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "max_drift",
        "vector_count"
      ],
      "returns": "str",
      "docstring": "Classify overall drift severity",
      "decorators": [],
      "calls": [],
      "line_number": 277
    },
    "empirica.core.drift.mirror_drift_monitor._recommend_action": {
      "name": "_recommend_action",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "severity"
      ],
      "returns": "str",
      "docstring": "Recommend action based on drift severity",
      "decorators": [],
      "calls": [],
      "line_number": 288
    },
    "empirica.core.drift.mirror_drift_monitor._log_drift": {
      "name": "_log_drift",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "report"
      ],
      "returns": "",
      "docstring": "Log drift warning",
      "decorators": [],
      "calls": [
        "len",
        "warning",
        "upper"
      ],
      "line_number": 299
    },
    "empirica.core.drift.mirror_drift_monitor._classify_drift_pattern": {
      "name": "_classify_drift_pattern",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "params": [
        "self",
        "current",
        "baseline"
      ],
      "returns": "tuple[Optional[str], float]",
      "docstring": "Classify drift pattern using real epistemic vector relationships.\n\nPatterns:\n- TRUE_DRIFT: Memory loss (KNOW\u2193 + CLARITY\u2193 + CONTEXT\u2193)\n- LEARNING: Discovering complexity (KNOW\u2193 + CLARITY\u2191)\n- SCOPE_DRIFT",
      "decorators": [],
      "calls": [
        "get",
        "min",
        "abs"
      ],
      "line_number": 323
    },
    "empirica.core.schemas.epistemic_assessment.validate_assessment": {
      "name": "validate_assessment",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "data"
      ],
      "returns": "bool",
      "docstring": "Validate assessment dictionary format\n\nChecks:\n- All 13 vectors present\n- Each vector has score, rationale\n- Scores in valid range [0.0, 1.0]\n- Proper nesting (foundation/comprehension/execution)\n\nArg",
      "decorators": [],
      "calls": [
        "float",
        "check_vector",
        "ValueError"
      ],
      "line_number": 536
    },
    "empirica.core.schemas.epistemic_assessment.parse_assessment_dict": {
      "name": "parse_assessment_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "data",
        "phase"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Parse and validate assessment dictionary\n\nArgs:\n    data: Nested assessment dictionary\n    phase: Current CASCADE phase\n\nReturns:\n    EpistemicAssessmentSchema instance\n\nRaises:\n    ValueError: If val",
      "decorators": [],
      "calls": [
        "from_nested_dict",
        "validate_assessment"
      ],
      "line_number": 597
    },
    "empirica.core.schemas.epistemic_assessment.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Validate score range",
      "decorators": [],
      "calls": [
        "ValueError"
      ],
      "line_number": 80
    },
    "empirica.core.schemas.epistemic_assessment.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to dictionary",
      "decorators": [],
      "calls": [],
      "line_number": 85
    },
    "empirica.core.schemas.epistemic_assessment.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "cls",
        "data"
      ],
      "returns": "'VectorAssessment'",
      "docstring": "Parse from dictionary",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "get",
        "float",
        "str",
        "cls"
      ],
      "line_number": 99
    },
    "empirica.core.schemas.epistemic_assessment.to_nested_dict": {
      "name": "to_nested_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to nested format (for CLI/MCP)\n\nReturns nested dict with structure:\n{\n  \"engagement\": {\"score\": 0.85, \"rationale\": \"...\"},\n  \"foundation\": {\n    \"know\": {\"score\": 0.70, \"rationale\": \"...\"},\n  ",
      "decorators": [],
      "calls": [
        "to_dict"
      ],
      "line_number": 156
    },
    "empirica.core.schemas.epistemic_assessment.to_flat_dict": {
      "name": "to_flat_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Convert to flat score dictionary (for storage/comparison)\n\nReturns: {\n    \"engagement\": 0.85,\n    \"know\": 0.70,\n    \"do\": 0.75,\n    ...\n}",
      "decorators": [],
      "calls": [],
      "line_number": 195
    },
    "empirica.core.schemas.epistemic_assessment.from_nested_dict": {
      "name": "from_nested_dict",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "cls",
        "data",
        "phase"
      ],
      "returns": "'EpistemicAssessmentSchema'",
      "docstring": "Parse from nested format (CLI/MCP input)\n\nArgs:\n    data: Nested dict with foundation/comprehension/execution structure\n    phase: Current CASCADE phase\n\nReturns:\n    EpistemicAssessmentSchema instanc",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "cls",
        "from_dict"
      ],
      "line_number": 223
    },
    "empirica.core.schemas.epistemic_assessment.apply_persona_priors": {
      "name": "apply_persona_priors",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self",
        "persona_priors",
        "strength"
      ],
      "returns": "'EpistemicAssessmentSchema'",
      "docstring": "Apply persona priors to this assessment\n\nBlends baseline assessment with persona-specific domain knowledge.\n\nArgs:\n    persona_priors: Dict of prior values {\"know\": 0.90, \"uncertainty\": 0.15, ...}\n   ",
      "decorators": [],
      "calls": [
        "VectorAssessment",
        "EpistemicAssessmentSchema",
        "blend_vector"
      ],
      "line_number": 251
    },
    "empirica.core.schemas.epistemic_assessment.calculate_tier_confidences": {
      "name": "calculate_tier_confidences",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self",
        "weights"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate tier-level confidence scores\n\nArgs:\n    weights: Optional custom weights for tiers\n            Default: equal weighting within tiers\n\nReturns:\n    Dict with foundation_confidence, comprehens",
      "decorators": [],
      "calls": [],
      "line_number": 299
    },
    "empirica.core.schemas.epistemic_assessment.determine_action": {
      "name": "determine_action",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self",
        "thresholds"
      ],
      "returns": "str",
      "docstring": "Determine recommended action based on assessment\n\nArgs:\n    thresholds: Optional custom thresholds\n               Default: standard CASCADE thresholds\n\nReturns:\n    \"proceed\", \"investigate\", or \"escal",
      "decorators": [],
      "calls": [
        "calculate_tier_confidences"
      ],
      "line_number": 353
    },
    "empirica.core.schemas.epistemic_assessment.know": {
      "name": "know",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: know \u2192 foundation_know",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 391
    },
    "empirica.core.schemas.epistemic_assessment.do": {
      "name": "do",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: do \u2192 foundation_do",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 396
    },
    "empirica.core.schemas.epistemic_assessment.context": {
      "name": "context",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: context \u2192 foundation_context",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 401
    },
    "empirica.core.schemas.epistemic_assessment.clarity": {
      "name": "clarity",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: clarity \u2192 comprehension_clarity",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 406
    },
    "empirica.core.schemas.epistemic_assessment.coherence": {
      "name": "coherence",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: coherence \u2192 comprehension_coherence",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 411
    },
    "empirica.core.schemas.epistemic_assessment.signal": {
      "name": "signal",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: signal \u2192 comprehension_signal",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 416
    },
    "empirica.core.schemas.epistemic_assessment.density": {
      "name": "density",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: density \u2192 comprehension_density",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 421
    },
    "empirica.core.schemas.epistemic_assessment.state": {
      "name": "state",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: state \u2192 execution_state",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 426
    },
    "empirica.core.schemas.epistemic_assessment.change": {
      "name": "change",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: change \u2192 execution_change",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 431
    },
    "empirica.core.schemas.epistemic_assessment.completion": {
      "name": "completion",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: completion \u2192 execution_completion",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 436
    },
    "empirica.core.schemas.epistemic_assessment.impact": {
      "name": "impact",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: impact \u2192 execution_impact",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 441
    },
    "empirica.core.schemas.epistemic_assessment.engagement_gate_passed": {
      "name": "engagement_gate_passed",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Check if engagement >= 0.6",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 446
    },
    "empirica.core.schemas.epistemic_assessment.assessment_id": {
      "name": "assessment_id",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Generate assessment ID from phase and timestamp",
      "decorators": [
        "property"
      ],
      "calls": [
        "uuid4"
      ],
      "line_number": 451
    },
    "empirica.core.schemas.epistemic_assessment.foundation_confidence": {
      "name": "foundation_confidence",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Calculate foundation tier confidence",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 457
    },
    "empirica.core.schemas.epistemic_assessment.comprehension_confidence": {
      "name": "comprehension_confidence",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Calculate comprehension tier confidence",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 462
    },
    "empirica.core.schemas.epistemic_assessment.execution_confidence": {
      "name": "execution_confidence",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Calculate execution tier confidence",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 472
    },
    "empirica.core.schemas.epistemic_assessment.overall_confidence": {
      "name": "overall_confidence",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Calculate overall confidence using canonical weights",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 482
    },
    "empirica.core.schemas.epistemic_assessment.recommended_action": {
      "name": "recommended_action",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Determine recommended action based on thresholds",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 493
    },
    "empirica.core.schemas.epistemic_assessment.coherence_critical": {
      "name": "coherence_critical",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Check if coherence score is below critical threshold",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 521
    },
    "empirica.core.schemas.epistemic_assessment.density_critical": {
      "name": "density_critical",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Check if density score is above critical threshold",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 526
    },
    "empirica.core.schemas.epistemic_assessment.change_critical": {
      "name": "change_critical",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Backwards compat: Check if change score is below critical threshold",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 531
    },
    "empirica.core.schemas.epistemic_assessment.check_vector": {
      "name": "check_vector",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "vector_data",
        "vector_name"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "float",
        "ValueError"
      ],
      "line_number": 576
    },
    "empirica.core.schemas.epistemic_assessment.blend_vector": {
      "name": "blend_vector",
      "module": "empirica.core.schemas.epistemic_assessment",
      "params": [
        "vector",
        "prior",
        "vector_name"
      ],
      "returns": "VectorAssessment",
      "docstring": "Blend baseline with persona prior",
      "decorators": [],
      "calls": [
        "VectorAssessment"
      ],
      "line_number": 267
    },
    "empirica.core.schemas.assessment_converters.convert_old_to_new": {
      "name": "convert_old_to_new",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "old_assessment"
      ],
      "returns": "",
      "docstring": "Convert OLD EpistemicAssessment to NEW EpistemicAssessmentSchema.\n\nArgs:\n    old_assessment: EpistemicAssessment from reflex_frame.py\n    \nReturns:\n    EpistemicAssessmentSchema with converted values\n",
      "decorators": [],
      "calls": [
        "VectorAssessment",
        "hasattr",
        "EpistemicAssessmentSchema",
        "convert_vector",
        "get",
        "_convert_phase_to_enum",
        "lower"
      ],
      "line_number": 17
    },
    "empirica.core.schemas.assessment_converters.convert_new_to_old": {
      "name": "convert_new_to_old",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "new_assessment"
      ],
      "returns": "",
      "docstring": "Convert NEW EpistemicAssessmentSchema to OLD EpistemicAssessment.\n\nArgs:\n    new_assessment: EpistemicAssessmentSchema from schemas/epistemic_assessment.py\n    \nReturns:\n    EpistemicAssessment with c",
      "decorators": [],
      "calls": [
        "determine_action",
        "VectorState",
        "calculate_tier_confidences",
        "_calculate_tier_confidence",
        "_convert_action_to_old",
        "convert_vector",
        "EpistemicAssessment"
      ],
      "line_number": 87
    },
    "empirica.core.schemas.assessment_converters._calculate_tier_confidence": {
      "name": "_calculate_tier_confidence",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "scores"
      ],
      "returns": "float",
      "docstring": "Calculate tier confidence from vector scores.",
      "decorators": [],
      "calls": [
        "len",
        "sum"
      ],
      "line_number": 200
    },
    "empirica.core.schemas.assessment_converters._convert_phase_to_enum": {
      "name": "_convert_phase_to_enum",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "task_str"
      ],
      "returns": "",
      "docstring": "Convert task string to CascadePhase enum (best effort).",
      "decorators": [],
      "calls": [
        "lower"
      ],
      "line_number": 205
    },
    "empirica.core.schemas.assessment_converters._convert_action": {
      "name": "_convert_action",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "old_action"
      ],
      "returns": "",
      "docstring": "Convert OLD Action enum to NEW action string.",
      "decorators": [],
      "calls": [
        "str",
        "upper"
      ],
      "line_number": 229
    },
    "empirica.core.schemas.assessment_converters._convert_action_to_old": {
      "name": "_convert_action_to_old",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "new_action"
      ],
      "returns": "",
      "docstring": "Convert NEW action string to OLD Action enum.",
      "decorators": [],
      "calls": [
        "lower"
      ],
      "line_number": 244
    },
    "empirica.core.schemas.assessment_converters.validate_conversion_old_to_new": {
      "name": "validate_conversion_old_to_new",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "old_assessment"
      ],
      "returns": "bool",
      "docstring": "Validate that OLD -> NEW conversion preserves critical data.\n\nReturns:\n    True if conversion is valid, False otherwise",
      "decorators": [],
      "calls": [
        "convert_old_to_new",
        "print"
      ],
      "line_number": 262
    },
    "empirica.core.schemas.assessment_converters.validate_conversion_new_to_old": {
      "name": "validate_conversion_new_to_old",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "new_assessment"
      ],
      "returns": "bool",
      "docstring": "Validate that NEW -> OLD conversion preserves critical data.\n\nNote: Some data loss is expected (evidence, investigation flags).\n\nReturns:\n    True if conversion is valid, False otherwise",
      "decorators": [],
      "calls": [
        "print",
        "convert_new_to_old"
      ],
      "line_number": 288
    },
    "empirica.core.schemas.assessment_converters.convert_vector": {
      "name": "convert_vector",
      "module": "empirica.core.schemas.assessment_converters",
      "params": [
        "vector_assessment"
      ],
      "returns": "VectorState",
      "docstring": "Convert NEW VectorAssessment to OLD VectorState.",
      "decorators": [],
      "calls": [
        "VectorState"
      ],
      "line_number": 111
    },
    "empirica.core.canonical.canonical_epistemic_assessment.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "agent_id"
      ],
      "returns": "",
      "docstring": "Initialize assessor\n\nArgs:\n    agent_id: Agent identifier for tracking",
      "decorators": [],
      "calls": [],
      "line_number": 60
    },
    "empirica.core.canonical.canonical_epistemic_assessment._generate_assessment_id": {
      "name": "_generate_assessment_id",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "task"
      ],
      "returns": "str",
      "docstring": "Generate unique assessment ID",
      "decorators": [],
      "calls": [
        "isoformat",
        "hexdigest",
        "now",
        "sha256",
        "encode"
      ],
      "line_number": 70
    },
    "empirica.core.canonical.canonical_epistemic_assessment._build_self_assessment_prompt": {
      "name": "_build_self_assessment_prompt",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "task",
        "context"
      ],
      "returns": "str",
      "docstring": "Build self-assessment prompt for genuine AI self-reflection\n\nThis prompt guides the AI to use its actual reasoning capabilities\nto evaluate its own epistemic state across all 12 vectors.\n\nNO HEURISTIC",
      "decorators": [],
      "calls": [
        "_format_context"
      ],
      "line_number": 141
    },
    "empirica.core.canonical.canonical_epistemic_assessment._format_context": {
      "name": "_format_context",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "context"
      ],
      "returns": "str",
      "docstring": "Format context dictionary for inclusion in self-assessment prompt",
      "decorators": [],
      "calls": [
        "items",
        "join",
        "append",
        "len",
        "isinstance"
      ],
      "line_number": 356
    },
    "empirica.core.canonical.canonical_epistemic_assessment._build_self_assessment_template_for_mapping": {
      "name": "_build_self_assessment_template_for_mapping",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Returns the prompt template for the 12-vector epistemic assessment.\nThis is used by the mapping LLM to generate the structured JSON.",
      "decorators": [],
      "calls": [],
      "line_number": 400
    },
    "empirica.core.canonical.canonical_epistemic_assessment.parse_llm_response": {
      "name": "parse_llm_response",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "llm_response",
        "assessment_id",
        "task",
        "context",
        "profile",
        "phase",
        "round_num"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Parse LLM's self-assessment response into EpistemicAssessmentSchema\n\nArgs:\n    llm_response: LLM's JSON response (string or dict)\n    assessment_id: Assessment identifier (not used in NEW schema)\n    ",
      "decorators": [],
      "calls": [
        "VectorAssessment",
        "EpistemicAssessmentSchema",
        "loads",
        "strip",
        "isinstance",
        "find",
        "ValueError",
        "get"
      ],
      "line_number": 587
    },
    "empirica.core.canonical.canonical_epistemic_assessment._determine_action": {
      "name": "_determine_action",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "params": [
        "self",
        "engagement",
        "engagement_gate_passed",
        "coherence",
        "density",
        "change",
        "clarity",
        "foundation_confidence",
        "overall_confidence",
        "uncertainty",
        "profile"
      ],
      "returns": "Action",
      "docstring": "Determine recommended action based on epistemic vectors and profile.\n\nIf profile.action_thresholds.override_allowed is True, AI can override\nthese recommendations with strong rationale.\n\nArgs:\n    vec",
      "decorators": [],
      "calls": [
        "load_profile"
      ],
      "line_number": 778
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "session_id",
        "enable_git_notes",
        "base_log_dir",
        "git_repo_path",
        "signing_persona"
      ],
      "returns": "",
      "docstring": "Initialize checkpoint logger.\n\nArgs:\n    session_id: Session identifier\n    enable_git_notes: Enable git notes storage (default: True, now required)\n    base_log_dir: Base directory for checkpoint log",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "_check_git_available",
        "mkdir",
        "cwd",
        "Path",
        "SignedGitOperations"
      ],
      "line_number": 62
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.git_enabled": {
      "name": "git_enabled",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if git notes are enabled and available.\n\nReturns:\n    True if git notes enabled AND git available",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 109
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._check_git_available": {
      "name": "_check_git_available",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if git repository is available.\n\nReturns:\n    True if git repo exists and git command available",
      "decorators": [],
      "calls": [
        "run",
        "debug"
      ],
      "line_number": 118
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.add_checkpoint": {
      "name": "add_checkpoint",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "phase",
        "round_num",
        "vectors",
        "metadata",
        "epistemic_tags",
        "noema"
      ],
      "returns": "Optional[str]",
      "docstring": "Add compressed checkpoint to git notes and SQLite with optional signing.\n\nStorage Architecture (Pointer-based):\n- Git: Authoritative source for signed epistemic states (immutable, verifiable)\n- SQLite",
      "decorators": [],
      "calls": [
        "_git_add_signed_note",
        "_create_checkpoint",
        "_save_checkpoint_to_sqlite",
        "_git_add_note"
      ],
      "line_number": 151
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._create_checkpoint": {
      "name": "_create_checkpoint",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "phase",
        "round_num",
        "vectors",
        "metadata",
        "epistemic_tags",
        "noema"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Create compressed checkpoint (target: 200-500 tokens).\n\nCompression strategy:\n- Only store vector scores (not rationales)\n- Store metadata selectively (only what's needed for context)\n- Use compact fi",
      "decorators": [],
      "calls": [
        "round",
        "isoformat",
        "_calculate_learning_delta",
        "now",
        "len",
        "get",
        "_capture_git_state",
        "_estimate_token_count",
        "sum"
      ],
      "line_number": 219
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._estimate_token_count": {
      "name": "_estimate_token_count",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "data"
      ],
      "returns": "int",
      "docstring": "Estimate token count for checkpoint data.\n\nUses simple approximation: len(text.split()) * 1.3\n(Good enough for Phase 1.5, tiktoken will be added later)\n\nArgs:\n    data: Checkpoint dictionary\n\nReturns:",
      "decorators": [],
      "calls": [
        "split",
        "len",
        "dumps",
        "int"
      ],
      "line_number": 280
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._capture_git_state": {
      "name": "_capture_git_state",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Capture current git state at checkpoint time.\n\nPhase 2.5: Enables correlation of epistemic deltas to code changes.\n\nReturns:\n    Dictionary containing:\n    - head_commit: Current HEAD SHA\n    - commit",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "_get_uncommitted_changes",
        "strip",
        "_get_commits_since_last_checkpoint"
      ],
      "line_number": 297
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._get_commits_since_last_checkpoint": {
      "name": "_get_commits_since_last_checkpoint",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get commits made since last checkpoint.\n\nReturns:\n    List of commit dictionaries with sha, message, author, timestamp, files_changed",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "split",
        "append",
        "strip",
        "len",
        "get",
        "get_last_checkpoint"
      ],
      "line_number": 341
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._get_uncommitted_changes": {
      "name": "_get_uncommitted_changes",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get uncommitted working directory changes.\n\nReturns:\n    Dictionary with files_modified, files_added, files_deleted, diff_stat",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "split",
        "append",
        "strip",
        "len"
      ],
      "line_number": 407
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._calculate_learning_delta": {
      "name": "_calculate_learning_delta",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "current_vectors"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Calculate epistemic delta since last checkpoint.\n\nPhase 2.5: Enables attribution analysis (what caused learning increase).\n\nArgs:\n    current_vectors: Current epistemic vectors\n\nReturns:\n    Dictionar",
      "decorators": [],
      "calls": [
        "get",
        "warning",
        "get_last_checkpoint",
        "round"
      ],
      "line_number": 467
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._save_checkpoint_to_sqlite": {
      "name": "_save_checkpoint_to_sqlite",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "checkpoint",
        "git_commit_sha",
        "git_notes_ref"
      ],
      "returns": "",
      "docstring": "Save checkpoint pointer to SQLite reflexes table.\n\nArchitecture (Pointer-based):\n- Git: Authoritative source for full signed epistemic state (immutable)\n- SQLite: Lightweight index with pointers + noe",
      "decorators": [],
      "calls": [
        "store_vectors",
        "debug",
        "error",
        "close",
        "SessionDatabase",
        "get"
      ],
      "line_number": 507
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._git_add_note": {
      "name": "_git_add_note",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "checkpoint"
      ],
      "returns": "Optional[str]",
      "docstring": "Add checkpoint to git notes with session-specific namespace.\n\nUses session-specific git notes refs to prevent agent collisions:\n- empirica/session/<session_id> for individual sessions\n- Multiple agent",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "split",
        "info",
        "loads",
        "strip",
        "get",
        "dumps"
      ],
      "line_number": 584
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._git_add_signed_note": {
      "name": "_git_add_signed_note",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "checkpoint",
        "phase"
      ],
      "returns": "Optional[str]",
      "docstring": "Add cryptographically signed checkpoint to git notes.\n\nUses SignedGitOperations to:\n1. Sign epistemic state with persona's Ed25519 key\n2. Store signed state in hierarchical git notes\n3. Enable verific",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "debug",
        "_git_add_note",
        "info",
        "commit_signed_state",
        "get",
        "dumps"
      ],
      "line_number": 647
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.get_last_checkpoint": {
      "name": "get_last_checkpoint",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "max_age_hours",
        "phase"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load most recent checkpoint (git notes preferred, SQLite fallback).\n\nArgs:\n    max_age_hours: Maximum age of checkpoint to consider (default: 24 hours)\n    phase: Filter by specific phase (optional)\n\n",
      "decorators": [],
      "calls": [
        "_load_checkpoint_from_sqlite",
        "_is_fresh",
        "_git_get_latest_note_new"
      ],
      "line_number": 725
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._git_get_latest_note": {
      "name": "_git_get_latest_note",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "phase"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Retrieve latest checkpoint from git notes (new hierarchical structure).\n\nArgs:\n    phase: Filter by phase (optional)\n\nReturns:\n    Checkpoint dictionary or None",
      "decorators": [],
      "calls": [
        "warning",
        "debug",
        "run",
        "split",
        "loads",
        "strip",
        "len",
        "get"
      ],
      "line_number": 749
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._git_get_latest_note_new": {
      "name": "_git_get_latest_note_new",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "phase"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Retrieve most recent checkpoint from hierarchical git notes structure.\n\nArgs:\n    phase: Filter by phase (optional)\n\nReturns:\n    Checkpoint dictionary or None",
      "decorators": [],
      "calls": [
        "warning",
        "debug",
        "run",
        "loads",
        "range",
        "get"
      ],
      "line_number": 855
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._load_checkpoint_from_sqlite": {
      "name": "_load_checkpoint_from_sqlite",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "phase",
        "max_age_hours"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load checkpoint from SQLite fallback storage.\n\nArgs:\n    phase: Filter by phase (optional)\n    max_age_hours: Maximum age in hours\n\nReturns:\n    Checkpoint dictionary or None",
      "decorators": [],
      "calls": [
        "glob",
        "open",
        "debug",
        "get",
        "sorted",
        "now",
        "exists",
        "load",
        "stat",
        "timedelta",
        "fromisoformat"
      ],
      "line_number": 905
    },
    "empirica.core.canonical.git_enhanced_reflex_logger._is_fresh": {
      "name": "_is_fresh",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "checkpoint",
        "max_age_hours"
      ],
      "returns": "bool",
      "docstring": "Check if checkpoint is within acceptable age.\n\nArgs:\n    checkpoint: Checkpoint dictionary\n    max_age_hours: Maximum age in hours\n\nReturns:\n    True if checkpoint is fresh enough",
      "decorators": [],
      "calls": [
        "timedelta",
        "now",
        "fromisoformat"
      ],
      "line_number": 956
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.list_checkpoints": {
      "name": "list_checkpoints",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "session_id",
        "limit",
        "phase"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "List checkpoints from git notes (using hierarchical namespace).\n\nUses git for-each-ref to discover all checkpoints automatically.\n\nArgs:\n    session_id: Filter by session (optional, defaults to self.s",
      "decorators": [],
      "calls": [
        "sort",
        "warning",
        "run",
        "debug",
        "split",
        "loads",
        "append",
        "strip",
        "len",
        "get"
      ],
      "line_number": 974
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.get_vector_diff": {
      "name": "get_vector_diff",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "params": [
        "self",
        "since_checkpoint",
        "current_vectors"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Compute vector delta since last checkpoint.\n\nReturns differential update (~400 tokens vs ~3,500 for full assessment).\n\nArgs:\n    since_checkpoint: Baseline checkpoint\n    current_vectors: Current epis",
      "decorators": [],
      "calls": [
        "abs",
        "round",
        "isoformat",
        "append",
        "now",
        "get",
        "_estimate_token_count"
      ],
      "line_number": 1062
    },
    "empirica.core.canonical.goal_orchestrator_bridge.create_orchestrator_with_bridge": {
      "name": "create_orchestrator_with_bridge",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "llm_callback",
        "use_placeholder",
        "db_path"
      ],
      "returns": "GoalOrchestratorBridge",
      "docstring": "Create goal orchestrator with bridge to new architecture\n\nArgs:\n    llm_callback: LLM callback function\n    use_placeholder: Use placeholder mode\n    db_path: Optional database path\n    \nReturns:\n    ",
      "decorators": [],
      "calls": [
        "GoalOrchestratorBridge",
        "CanonicalGoalOrchestrator"
      ],
      "line_number": 306
    },
    "empirica.core.canonical.goal_orchestrator_bridge.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "self",
        "orchestrator",
        "db_path"
      ],
      "returns": "",
      "docstring": "Initialize bridge\n\nArgs:\n    orchestrator: Canonical goal orchestrator instance\n    db_path: Optional database path",
      "decorators": [],
      "calls": [
        "GoalRepository"
      ],
      "line_number": 39
    },
    "empirica.core.canonical.goal_orchestrator_bridge._convert_to_structured_goal": {
      "name": "_convert_to_structured_goal",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "self",
        "llm_goal"
      ],
      "returns": "Goal",
      "docstring": "Convert LLM-generated Goal to structured Goal\n\nArgs:\n    llm_goal: Goal from canonical_goal_orchestrator\n    \nReturns:\n    Structured Goal object",
      "decorators": [],
      "calls": [
        "SuccessCriterion",
        "ScopeVector",
        "create",
        "str",
        "_map_priority_to_complexity",
        "append",
        "uuid4"
      ],
      "line_number": 109
    },
    "empirica.core.canonical.goal_orchestrator_bridge._map_priority_to_complexity": {
      "name": "_map_priority_to_complexity",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "self",
        "priority"
      ],
      "returns": "float",
      "docstring": "Map LLM priority (1-10) to complexity (0.0-1.0)\n\nArgs:\n    priority: Priority level 1-10\n    \nReturns:\n    Complexity 0.0-1.0",
      "decorators": [],
      "calls": [],
      "line_number": 171
    },
    "empirica.core.canonical.goal_orchestrator_bridge.create_goal_from_decision": {
      "name": "create_goal_from_decision",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "self",
        "task_description",
        "session_id",
        "epistemic_assessment",
        "goal_decision"
      ],
      "returns": "Optional[str]",
      "docstring": "Create goal based on decision logic output\n\nThis is called when goal_decision.should_create_goal_now is True.\nUses epistemic assessment to determine appropriate scope.\n\nArgs:\n    task_description: Tas",
      "decorators": [],
      "calls": [
        "SuccessCriterion",
        "ScopeVector",
        "create",
        "str",
        "hasattr",
        "getattr",
        "error",
        "info",
        "get",
        "save_goal",
        "uuid4"
      ],
      "line_number": 194
    },
    "empirica.core.canonical.goal_orchestrator_bridge.close": {
      "name": "close",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Close repository connections",
      "decorators": [],
      "calls": [
        "close"
      ],
      "line_number": 301
    },
    "empirica.core.canonical.reflex_frame.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.core.canonical.reflex_frame",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "ValueError"
      ],
      "line_number": 58
    },
    "empirica.core.canonical.reflex_frame.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.canonical.reflex_frame",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "asdict"
      ],
      "line_number": 62
    },
    "empirica.core.canonical.canonical_goal_orchestrator.create_goal_orchestrator": {
      "name": "create_goal_orchestrator",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "llm_client",
        "llm_callback",
        "use_placeholder"
      ],
      "returns": "CanonicalGoalOrchestrator",
      "docstring": "Create and return a CanonicalGoalOrchestrator instance\n\nArgs:\n    llm_client: LLM client (legacy, async)\n    llm_callback: Function(prompt: str) -> str for AI reasoning (preferred)\n    use_placeholder",
      "decorators": [],
      "calls": [
        "CanonicalGoalOrchestrator"
      ],
      "line_number": 462
    },
    "empirica.core.canonical.canonical_goal_orchestrator.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to dictionary",
      "decorators": [],
      "calls": [],
      "line_number": 88
    },
    "empirica.core.canonical.canonical_goal_orchestrator.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "ActionEnum",
        "Vector"
      ],
      "line_number": 502
    },
    "empirica.core.canonical.canonical_goal_orchestrator._build_goal_orchestration_prompt": {
      "name": "_build_goal_orchestration_prompt",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self",
        "conversation_context",
        "epistemic_assessment",
        "current_state"
      ],
      "returns": "str",
      "docstring": "Build meta-prompt for LLM-powered goal generation",
      "decorators": [],
      "calls": [
        "_format_epistemic_state",
        "join",
        "append",
        "dumps",
        "_get_goal_generation_instructions"
      ],
      "line_number": 177
    },
    "empirica.core.canonical.canonical_goal_orchestrator._format_epistemic_state": {
      "name": "_format_epistemic_state",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "str",
      "docstring": "Format epistemic assessment for prompt",
      "decorators": [],
      "calls": [],
      "line_number": 204
    },
    "empirica.core.canonical.canonical_goal_orchestrator._get_goal_generation_instructions": {
      "name": "_get_goal_generation_instructions",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Get instructions for LLM goal generation",
      "decorators": [],
      "calls": [],
      "line_number": 271
    },
    "empirica.core.canonical.canonical_goal_orchestrator._placeholder_goal_generation": {
      "name": "_placeholder_goal_generation",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self",
        "conversation_context",
        "epistemic_assessment",
        "current_state"
      ],
      "returns": "List[Goal]",
      "docstring": "Placeholder goal generation (for testing without LLM)\n\nThis simulates what the LLM would generate, using simple logic\nbased on the epistemic assessment (not hardcoded keywords).",
      "decorators": [],
      "calls": [
        "append",
        "Goal"
      ],
      "line_number": 320
    },
    "empirica.core.canonical.canonical_goal_orchestrator._parse_llm_goal_response": {
      "name": "_parse_llm_goal_response",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "params": [
        "self",
        "llm_response"
      ],
      "returns": "List[Goal]",
      "docstring": "Parse LLM response into Goal objects",
      "decorators": [],
      "calls": [
        "warning",
        "rfind",
        "loads",
        "append",
        "GoalAutonomyLevel",
        "find",
        "ValueError",
        "get",
        "Goal"
      ],
      "line_number": 412
    },
    "empirica.core.canonical.reflex_logger.log_assessment_sync": {
      "name": "log_assessment_sync",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "assessment",
        "frame_id",
        "task",
        "context",
        "agent_id",
        "logger_instance"
      ],
      "returns": "Path",
      "docstring": "Synchronous version of log_assessment\n\nSee log_assessment for documentation.",
      "decorators": [],
      "calls": [
        "run",
        "log_assessment"
      ],
      "line_number": 404
    },
    "empirica.core.canonical.reflex_logger.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "base_log_dir"
      ],
      "returns": "",
      "docstring": "Initialize logger\n\nArgs:\n    base_log_dir: Root directory for all reflex logs\n                 Default: .empirica_reflex_logs (hidden, project-local)",
      "decorators": [],
      "calls": [
        "_ensure_log_directory",
        "Path"
      ],
      "line_number": 46
    },
    "empirica.core.canonical.reflex_logger._ensure_log_directory": {
      "name": "_ensure_log_directory",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create log directory structure if it doesn't exist",
      "decorators": [],
      "calls": [
        "mkdir"
      ],
      "line_number": 57
    },
    "empirica.core.canonical.reflex_logger._get_agent_log_dir": {
      "name": "_get_agent_log_dir",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "agent_id",
        "session_id",
        "log_date"
      ],
      "returns": "Path",
      "docstring": "Get log directory for specific agent, date, and session\n\nDirectory structure: .empirica_reflex_logs/{YYYY-MM-DD}/{agent_id}/{session_id}/\n\nArgs:\n    agent_id: AI identifier (e.g., \"minimax\", \"claude\",",
      "decorators": [],
      "calls": [
        "isoformat",
        "mkdir",
        "today"
      ],
      "line_number": 61
    },
    "empirica.core.canonical.reflex_logger._generate_log_filename": {
      "name": "_generate_log_filename",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "frame_id"
      ],
      "returns": "str",
      "docstring": "Generate timestamped log filename\n\nFormat: {frame_id}_{timestamp}.json\nExample: assess_abc123_20251027T153045.json",
      "decorators": [],
      "calls": [
        "now",
        "strftime"
      ],
      "line_number": 98
    },
    "empirica.core.canonical.reflex_logger.log_frame_sync": {
      "name": "log_frame_sync",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "frame_dict",
        "agent_id",
        "session_id"
      ],
      "returns": "Path",
      "docstring": "Synchronous version of log_frame for non-async contexts\n\nArgs:\n    frame_dict: Frame data as dictionary\n    agent_id: Agent identifier\n    session_id: Session UUID for session-specific organization\n\nR",
      "decorators": [],
      "calls": [
        "open",
        "_generate_log_filename",
        "_get_agent_log_dir",
        "write",
        "get",
        "dumps"
      ],
      "line_number": 148
    },
    "empirica.core.canonical.reflex_logger.get_recent_frames_sync": {
      "name": "get_recent_frames_sync",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "agent_id",
        "limit",
        "log_date"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Synchronous version of get_recent_frames\n\nArgs:\n    agent_id: Agent identifier\n    limit: Maximum number of frames to retrieve\n    log_date: Specific date to query (default: today)\n\nReturns:\n    List ",
      "decorators": [],
      "calls": [
        "glob",
        "open",
        "_get_agent_log_dir",
        "sorted",
        "append",
        "load",
        "stat"
      ],
      "line_number": 213
    },
    "empirica.core.canonical.reflex_logger.get_assessment_history": {
      "name": "get_assessment_history",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "agent_id",
        "days"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get assessment history across multiple days\n\nArgs:\n    agent_id: Agent identifier\n    days: Number of days to look back\n\nReturns:\n    List of all frames from the past N days\n\nUse Case: Calibration ana",
      "decorators": [],
      "calls": [
        "get_recent_frames_sync",
        "range",
        "timedelta",
        "extend",
        "today"
      ],
      "line_number": 277
    },
    "empirica.core.canonical.reflex_logger.cleanup_old_logs": {
      "name": "cleanup_old_logs",
      "module": "empirica.core.canonical.reflex_logger",
      "params": [
        "self",
        "agent_id",
        "days_to_keep"
      ],
      "returns": "",
      "docstring": "Remove logs older than specified days\n\nArgs:\n    agent_id: Agent identifier\n    days_to_keep: Number of days of logs to retain\n\nNote: Be cautious - this permanently deletes historical calibration data",
      "decorators": [],
      "calls": [
        "iterdir",
        "rmtree",
        "is_dir",
        "info",
        "exists",
        "timedelta",
        "fromisoformat",
        "today"
      ],
      "line_number": 308
    },
    "empirica.core.completion.git_query.__init__": {
      "name": "__init__",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Initialize git query interface",
      "decorators": [],
      "calls": [
        "_check_git_available"
      ],
      "line_number": 28
    },
    "empirica.core.completion.git_query._check_git_available": {
      "name": "_check_git_available",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if git is available",
      "decorators": [],
      "calls": [
        "run"
      ],
      "line_number": 32
    },
    "empirica.core.completion.git_query.get_goal_timeline": {
      "name": "get_goal_timeline",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self",
        "goal_id",
        "max_commits"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get commit timeline for goal with task metadata\n\nArgs:\n    goal_id: Goal UUID to query\n    max_commits: Maximum commits to retrieve\n    \nReturns:\n    Timeline dict with commits and task metadata",
      "decorators": [],
      "calls": [
        "startswith",
        "str",
        "int",
        "run",
        "isoformat",
        "error",
        "split",
        "append",
        "len",
        "strip",
        "fromtimestamp",
        "_get_task_note"
      ],
      "line_number": 45
    },
    "empirica.core.completion.git_query._get_task_note": {
      "name": "_get_task_note",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self",
        "commit_hash",
        "note_ref"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get task note for a specific commit\n\nArgs:\n    commit_hash: Commit hash\n    note_ref: Git notes reference\n    \nReturns:\n    Task metadata dict or None",
      "decorators": [],
      "calls": [
        "run",
        "debug",
        "loads"
      ],
      "line_number": 136
    },
    "empirica.core.completion.git_query.get_team_progress": {
      "name": "get_team_progress",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self",
        "goal_ids"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Multi-goal progress for team coordination\n\nLead AI can see progress across multiple agents/goals\n\nArgs:\n    goal_ids: List of goal UUIDs\n    \nReturns:\n    Team progress summary",
      "decorators": [],
      "calls": [
        "append",
        "get",
        "get_goal_timeline"
      ],
      "line_number": 173
    },
    "empirica.core.completion.git_query.get_unified_timeline": {
      "name": "get_unified_timeline",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self",
        "session_id",
        "goal_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Combine task metadata with epistemic state\n\nShows complete agent journey: goals \u2192 actions \u2192 learning\n\nArgs:\n    session_id: Session UUID\n    goal_id: Goal UUID\n    \nReturns:\n    Unified timeline with ",
      "decorators": [],
      "calls": [
        "sort",
        "str",
        "run",
        "error",
        "append",
        "len",
        "get",
        "get_goal_timeline",
        "_get_task_note"
      ],
      "line_number": 215
    },
    "empirica.core.completion.git_query.get_recent_activity": {
      "name": "get_recent_activity",
      "module": "empirica.core.completion.git_query",
      "params": [
        "self",
        "hours"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get recent activity across all goals\n\nUseful for lead AI to see what's happening now\n\nArgs:\n    hours: Hours to look back\n    \nReturns:\n    Recent activity summary",
      "decorators": [],
      "calls": [
        "str",
        "int",
        "run",
        "isoformat",
        "error",
        "split",
        "append",
        "len",
        "strip",
        "fromtimestamp"
      ],
      "line_number": 306
    },
    "empirica.core.completion.types.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.completion.types",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Serialize to dictionary",
      "decorators": [],
      "calls": [],
      "line_number": 75
    },
    "empirica.core.completion.types.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.completion.types",
      "params": [
        "data"
      ],
      "returns": "'CompletionRecord'",
      "docstring": "Deserialize from dictionary",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "get",
        "CompletionRecord",
        "time"
      ],
      "line_number": 46
    },
    "empirica.core.completion.tracker.__init__": {
      "name": "__init__",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "db_path",
        "enable_git_notes"
      ],
      "returns": "",
      "docstring": "Initialize tracker\n\nArgs:\n    db_path: Optional custom database path\n    enable_git_notes: Enable git notes for task metadata (default: True)",
      "decorators": [],
      "calls": [
        "_check_git_available",
        "TaskRepository",
        "GoalRepository"
      ],
      "line_number": 33
    },
    "empirica.core.completion.tracker.track_progress": {
      "name": "track_progress",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "CompletionRecord",
      "docstring": "Calculate completion status for a goal\n\nArgs:\n    goal_id: Goal identifier\n    \nReturns:\n    CompletionRecord with current status",
      "decorators": [],
      "calls": [
        "warning",
        "update_goal_completion",
        "get_goal_subtasks",
        "CompletionRecord",
        "error",
        "info",
        "append",
        "len",
        "sum"
      ],
      "line_number": 46
    },
    "empirica.core.completion.tracker.auto_update_completion": {
      "name": "auto_update_completion",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "CompletionRecord",
      "docstring": "Automatically update completion based on current task status\n\nMVP: Just calls track_progress (future: git commit parsing)\n\nArgs:\n    goal_id: Goal identifier\n    \nReturns:\n    Updated CompletionRecord",
      "decorators": [],
      "calls": [
        "track_progress"
      ],
      "line_number": 136
    },
    "empirica.core.completion.tracker.record_subtask_completion": {
      "name": "record_subtask_completion",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "subtask_id",
        "evidence"
      ],
      "returns": "bool",
      "docstring": "Mark subtask as complete with optional evidence\n\nPhase 2: Also adds git note for task metadata\n\nArgs:\n    subtask_id: SubTask identifier\n    evidence: Completion evidence (commit hash, file path, etc.",
      "decorators": [],
      "calls": [
        "startswith",
        "_add_task_note",
        "error",
        "split",
        "info",
        "update_subtask_status"
      ],
      "line_number": 152
    },
    "empirica.core.completion.tracker.get_session_metrics": {
      "name": "get_session_metrics",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "CompletionMetrics",
      "docstring": "Calculate aggregate completion metrics for a session\n\nArgs:\n    session_id: Session identifier\n    \nReturns:\n    CompletionMetrics with aggregated statistics",
      "decorators": [],
      "calls": [
        "get_session_goals",
        "track_progress",
        "error",
        "CompletionMetrics",
        "len"
      ],
      "line_number": 194
    },
    "empirica.core.completion.tracker.auto_update_from_recent_commits": {
      "name": "auto_update_from_recent_commits",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "goal_id",
        "since"
      ],
      "returns": "int",
      "docstring": "Scan recent git commits and auto-mark subtasks complete\n\nLooks for commit message patterns like:\n- \u2705 [TASK:subtask-uuid] \n- [COMPLETE:subtask-uuid]\n- Addresses subtask subtask-uuid\n\nArgs:\n    goal_id:",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "debug",
        "search",
        "get_subtask",
        "split",
        "info",
        "group",
        "strip",
        "record_subtask_completion"
      ],
      "line_number": 261
    },
    "empirica.core.completion.tracker._check_git_available": {
      "name": "_check_git_available",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if git is available and we're in a git repository\n\nReturns:\n    True if git available and in repo",
      "decorators": [],
      "calls": [
        "run"
      ],
      "line_number": 342
    },
    "empirica.core.completion.tracker._add_task_note": {
      "name": "_add_task_note",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self",
        "subtask_id",
        "commit_hash"
      ],
      "returns": "Optional[str]",
      "docstring": "Add task completion note to git\n\nStores structured metadata in git notes for lead AI queries.\nUses goal-specific namespace: refs/notes/empirica/tasks/<goal_id>\n\nArgs:\n    subtask_id: SubTask UUID\n    ",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "get_subtask",
        "error",
        "time",
        "info",
        "split",
        "strip",
        "dumps"
      ],
      "line_number": 363
    },
    "empirica.core.completion.tracker.close": {
      "name": "close",
      "module": "empirica.core.completion.tracker",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Close repository connections",
      "decorators": [],
      "calls": [
        "close"
      ],
      "line_number": 451
    },
    "empirica.core.handoff.report_generator.__init__": {
      "name": "__init__",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "db_path"
      ],
      "returns": "",
      "docstring": "Initialize report generator\n\nArgs:\n    db_path: Optional path to session database",
      "decorators": [],
      "calls": [
        "SessionDatabase"
      ],
      "line_number": 39
    },
    "empirica.core.handoff.report_generator.generate_handoff_report": {
      "name": "generate_handoff_report",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id",
        "task_summary",
        "key_findings",
        "remaining_unknowns",
        "next_session_context",
        "artifacts_created",
        "start_assessment",
        "end_assessment",
        "handoff_subtype"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Generate comprehensive handoff report\n\nArgs:\n    session_id: Session UUID\n    task_summary: What was accomplished (2-3 sentences)\n    key_findings: What was learned (3-5 bullet points)\n    remaining_u",
      "decorators": [],
      "calls": [
        "_compress_report",
        "_generate_markdown",
        "_extract_investigation_tools",
        "_get_postflight_assessment",
        "len",
        "get",
        "_calculate_deltas",
        "_check_calibration",
        "_generate_recommendations",
        "isoformat",
        "_calculate_duration",
        "info",
        "now",
        "_get_preflight_assessment",
        "get_check_phase_assessments",
        "_identify_filled_gaps",
        "_get_session_metadata",
        "ValueError",
        "bool"
      ],
      "line_number": 50
    },
    "empirica.core.handoff.report_generator.generate_planning_handoff": {
      "name": "generate_planning_handoff",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id",
        "task_summary",
        "key_findings",
        "remaining_unknowns",
        "next_session_context",
        "artifacts_created"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Generate planning handoff (documentation without CASCADE workflow assessments)\n\nUsed for:\n- Multi-session planning (no PREFLIGHT/POSTFLIGHT yet)\n- Architecture/design phase handoffs\n- Documentation of",
      "decorators": [],
      "calls": [
        "isoformat",
        "_get_session_metadata",
        "join",
        "_calculate_duration",
        "info",
        "append",
        "now",
        "len",
        "_compress_planning_handoff",
        "get",
        "extend"
      ],
      "line_number": 184
    },
    "empirica.core.handoff.report_generator._get_preflight_assessment": {
      "name": "_get_preflight_assessment",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Fetch PREFLIGHT assessment from database (now uses reflexes table)",
      "decorators": [],
      "calls": [
        "get",
        "warning",
        "get_latest_vectors"
      ],
      "line_number": 282
    },
    "empirica.core.handoff.report_generator._get_postflight_assessment": {
      "name": "_get_postflight_assessment",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Fetch POSTFLIGHT assessment from database (now uses reflexes table)",
      "decorators": [],
      "calls": [
        "get",
        "warning",
        "get_latest_vectors"
      ],
      "line_number": 298
    },
    "empirica.core.handoff.report_generator._calculate_deltas": {
      "name": "_calculate_deltas",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "preflight_vectors",
        "postflight_vectors"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate epistemic vector deltas\n\nReturns deltas for all 13 vectors + overall_confidence",
      "decorators": [],
      "calls": [
        "get",
        "round"
      ],
      "line_number": 314
    },
    "empirica.core.handoff.report_generator._check_calibration": {
      "name": "_check_calibration",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id",
        "deltas",
        "end_assessment"
      ],
      "returns": "Dict",
      "docstring": "Get calibration status - prioritize genuine introspection, validate with heuristics\n\nFor investigation handoffs (PREFLIGHT\u2192CHECK), calibration is not applicable\nsince CHECK is a decision gate, not a l",
      "decorators": [],
      "calls": [
        "debug",
        "info",
        "isinstance",
        "get",
        "_heuristic_calibration_check",
        "get_latest_vectors"
      ],
      "line_number": 346
    },
    "empirica.core.handoff.report_generator._heuristic_calibration_check": {
      "name": "_heuristic_calibration_check",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "deltas"
      ],
      "returns": "Dict",
      "docstring": "Heuristic calibration check based on vector deltas\n\nUsed as:\n1. Fallback when genuine introspection missing\n2. Validation check against AI's self-assessment",
      "decorators": [],
      "calls": [
        "get",
        "abs"
      ],
      "line_number": 407
    },
    "empirica.core.handoff.report_generator._identify_filled_gaps": {
      "name": "_identify_filled_gaps",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "preflight_vectors",
        "postflight_vectors",
        "key_findings"
      ],
      "returns": "List[Dict]",
      "docstring": "Identify which knowledge gaps were filled during session\n\nReturns:\n    [\n        {\n            'gap': 'Understanding of API patterns',\n            'before': 'Uncertain about factory methods',\n        ",
      "decorators": [],
      "calls": [
        "round",
        "append",
        "any",
        "get",
        "lower"
      ],
      "line_number": 439
    },
    "empirica.core.handoff.report_generator._extract_investigation_tools": {
      "name": "_extract_investigation_tools",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "List[str]",
      "docstring": "Extract which investigation tools were used during session\n\nQueries database for tool usage",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "list",
        "add",
        "debug",
        "sorted",
        "fetchone",
        "execute",
        "set"
      ],
      "line_number": 502
    },
    "empirica.core.handoff.report_generator._generate_recommendations": {
      "name": "_generate_recommendations",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "postflight_vectors",
        "remaining_unknowns",
        "calibration"
      ],
      "returns": "List[str]",
      "docstring": "Generate recommended next steps based on epistemic state",
      "decorators": [],
      "calls": [
        "get",
        "len",
        "append"
      ],
      "line_number": 533
    },
    "empirica.core.handoff.report_generator._get_session_metadata": {
      "name": "_get_session_metadata",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Dict",
      "docstring": "Get session metadata from database",
      "decorators": [],
      "calls": [
        "cursor",
        "warning",
        "isoformat",
        "now",
        "fetchone",
        "execute"
      ],
      "line_number": 588
    },
    "empirica.core.handoff.report_generator._calculate_duration": {
      "name": "_calculate_duration",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "float",
      "docstring": "Calculate session duration in seconds",
      "decorators": [],
      "calls": [
        "cursor",
        "debug",
        "now",
        "fetchone",
        "execute",
        "total_seconds",
        "fromisoformat"
      ],
      "line_number": 616
    },
    "empirica.core.handoff.report_generator._generate_markdown": {
      "name": "_generate_markdown",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "report",
        "start_assessment",
        "end_assessment",
        "calibration"
      ],
      "returns": "str",
      "docstring": "Generate full markdown report",
      "decorators": [],
      "calls": [
        "title",
        "_format_gaps",
        "isoformat",
        "join",
        "replace",
        "now",
        "_build_delta_table",
        "get"
      ],
      "line_number": 635
    },
    "empirica.core.handoff.report_generator._build_delta_table": {
      "name": "_build_delta_table",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "start_vectors",
        "end_vectors",
        "deltas"
      ],
      "returns": "str",
      "docstring": "Build markdown table of vector deltas",
      "decorators": [],
      "calls": [
        "abs",
        "items",
        "join",
        "append",
        "upper",
        "get"
      ],
      "line_number": 746
    },
    "empirica.core.handoff.report_generator._format_gaps": {
      "name": "_format_gaps",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "gaps"
      ],
      "returns": "str",
      "docstring": "Format knowledge gaps as markdown",
      "decorators": [],
      "calls": [
        "get",
        "join",
        "append"
      ],
      "line_number": 784
    },
    "empirica.core.handoff.report_generator._compress_report": {
      "name": "_compress_report",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "report"
      ],
      "returns": "str",
      "docstring": "Generate minimal JSON for storage (~800 tokens)\n\nStrips verbose markdown, keeps critical data",
      "decorators": [],
      "calls": [
        "abs",
        "round",
        "items",
        "get",
        "dumps"
      ],
      "line_number": 799
    },
    "empirica.core.handoff.report_generator._compress_planning_handoff": {
      "name": "_compress_planning_handoff",
      "module": "empirica.core.handoff.report_generator",
      "params": [
        "self",
        "report"
      ],
      "returns": "str",
      "docstring": "Generate minimal JSON for planning handoff storage\n\nSimilar to epistemic handoff but without deltas/calibration",
      "decorators": [],
      "calls": [
        "dumps",
        "round"
      ],
      "line_number": 835
    },
    "empirica.core.handoff.auto_generator.auto_generate_handoff": {
      "name": "auto_generate_handoff",
      "module": "empirica.core.handoff.auto_generator",
      "params": [
        "session_id",
        "db_path"
      ],
      "returns": "Dict",
      "docstring": "Auto-generate handoff report from cascades data in database.\n\nToken efficiency: ~500 tokens vs 2000+ if storing full cascade data\n\nArgs:\n    session_id: Session UUID\n    db_path: Path to session datab",
      "decorators": [],
      "calls": [
        "enumerate",
        "fetchone",
        "SessionDatabase",
        "execute",
        "total_seconds",
        "extend",
        "fetchall",
        "utcnow",
        "len",
        "get",
        "fromisoformat",
        "list",
        "fromkeys",
        "isoformat",
        "append",
        "isinstance",
        "map",
        "cursor",
        "int",
        "round",
        "join",
        "close",
        "loads",
        "_get_artifacts_from_session",
        "ValueError"
      ],
      "line_number": 16
    },
    "empirica.core.handoff.auto_generator._get_artifacts_from_session": {
      "name": "_get_artifacts_from_session",
      "module": "empirica.core.handoff.auto_generator",
      "params": [
        "session_id",
        "start_time"
      ],
      "returns": "List[str]",
      "docstring": "Get list of files modified during session using git diff.\n\nArgs:\n    session_id: Session UUID\n    start_time: Session start timestamp\n    \nReturns:\n    List of modified file paths",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "debug",
        "split"
      ],
      "line_number": 202
    },
    "empirica.core.handoff.auto_generator.close_session": {
      "name": "close_session",
      "module": "empirica.core.handoff.auto_generator",
      "params": [
        "session_id",
        "db_path"
      ],
      "returns": "None",
      "docstring": "Close session by setting end_time in database.\n\nArgs:\n    session_id: Session UUID\n    db_path: Path to session database",
      "decorators": [],
      "calls": [
        "cursor",
        "isoformat",
        "info",
        "commit",
        "close",
        "utcnow",
        "SessionDatabase",
        "execute"
      ],
      "line_number": 236
    },
    "empirica.core.handoff.storage.__init__": {
      "name": "__init__",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "repo_path",
        "db_path"
      ],
      "returns": "",
      "docstring": "Initialize hybrid storage with both backends\n\nArgs:\n    repo_path: Path to git repository (default: current directory)\n    db_path: Path to session database (default: .empirica/sessions/sessions.db)",
      "decorators": [],
      "calls": [
        "DatabaseHandoffStorage",
        "info",
        "GitHandoffStorage"
      ],
      "line_number": 422
    },
    "empirica.core.handoff.storage.store_handoff": {
      "name": "store_handoff",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "session_id",
        "report"
      ],
      "returns": "Dict[str, bool]",
      "docstring": "Store handoff in BOTH git notes and database\n\nArgs:\n    session_id: Session UUID\n    report: Full handoff report dict\n\nReturns:\n    {\n        'git_stored': bool,\n        'db_stored': bool,\n        'fu",
      "decorators": [],
      "calls": [
        "store_handoff",
        "error",
        "warning",
        "info"
      ],
      "line_number": 435
    },
    "empirica.core.handoff.storage.load_handoff": {
      "name": "load_handoff",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "session_id",
        "format",
        "prefer"
      ],
      "returns": "Optional[Dict]",
      "docstring": "Load handoff from preferred storage, fallback to alternative\n\nArgs:\n    session_id: Session UUID\n    format: 'json' or 'markdown'\n    prefer: 'database' or 'git' (default: database for speed)\n\nReturns",
      "decorators": [],
      "calls": [
        "debug",
        "load_handoff"
      ],
      "line_number": 483
    },
    "empirica.core.handoff.storage.list_handoffs": {
      "name": "list_handoffs",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "source"
      ],
      "returns": "List[str]",
      "docstring": "List all handoff session IDs\n\nArgs:\n    source: 'database' or 'git' or 'both'\n\nReturns:\n    List of session IDs",
      "decorators": [],
      "calls": [
        "list_handoffs",
        "list",
        "sorted",
        "set"
      ],
      "line_number": 547
    },
    "empirica.core.handoff.storage._get_note_sha": {
      "name": "_get_note_sha",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "note_ref"
      ],
      "returns": "Optional[str]",
      "docstring": "Get SHA of note",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "str"
      ],
      "line_number": 183
    },
    "empirica.core.handoff.storage._create_table": {
      "name": "_create_table",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create handoff_reports table",
      "decorators": [],
      "calls": [
        "cursor",
        "execute",
        "commit"
      ],
      "line_number": 224
    },
    "empirica.core.handoff.storage.query_handoffs": {
      "name": "query_handoffs",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "ai_id",
        "since",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "Query handoffs with filters (uses database for performance)\n\nArgs:\n    ai_id: Filter by AI ID\n    since: Filter by timestamp (ISO format)\n    limit: Max results to return\n\nReturns:\n    List of handoff",
      "decorators": [],
      "calls": [
        "query_handoffs"
      ],
      "line_number": 527
    },
    "empirica.core.handoff.storage._row_to_dict": {
      "name": "_row_to_dict",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "row"
      ],
      "returns": "Dict",
      "docstring": "Convert database row to dict",
      "decorators": [],
      "calls": [
        "loads"
      ],
      "line_number": 373
    },
    "empirica.core.handoff.storage.check_sync_status": {
      "name": "check_sync_status",
      "module": "empirica.core.handoff.storage",
      "params": [
        "self",
        "session_id"
      ],
      "returns": "Dict[str, bool]",
      "docstring": "Check if handoff exists in both stores\n\nReturns:\n    {\n        'in_git': bool,\n        'in_database': bool,\n        'synced': bool\n    }",
      "decorators": [],
      "calls": [
        "load_handoff"
      ],
      "line_number": 566
    },
    "empirica.core.qdrant.persona_registry.__init__": {
      "name": "__init__",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "qdrant_host",
        "qdrant_port",
        "prefer_grpc"
      ],
      "returns": "",
      "docstring": "Initialize PersonaRegistry\n\nArgs:\n    qdrant_host: Qdrant server host\n    qdrant_port: Qdrant server port\n    prefer_grpc: Use gRPC if available (faster)\n\nRaises:\n    ConnectionError: If cannot connec",
      "decorators": [],
      "calls": [
        "ConnectionError",
        "QdrantClient",
        "error",
        "info",
        "_ensure_collection",
        "get_collections"
      ],
      "line_number": 98
    },
    "empirica.core.qdrant.persona_registry._ensure_collection": {
      "name": "_ensure_collection",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Create collection if it doesn't exist",
      "decorators": [],
      "calls": [
        "VectorParams",
        "get_collection",
        "create_collection",
        "info"
      ],
      "line_number": 136
    },
    "empirica.core.qdrant.persona_registry.register_persona": {
      "name": "register_persona",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "signing_persona"
      ],
      "returns": "str",
      "docstring": "Register a persona in Qdrant\n\nArgs:\n    signing_persona: SigningPersona instance to register\n\nReturns:\n    str: Point ID in Qdrant\n\nRaises:\n    ValueError: If persona data invalid",
      "decorators": [],
      "calls": [
        "PointStruct",
        "error",
        "info",
        "_persona_id_to_point_id",
        "ValueError",
        "get",
        "export_public_persona",
        "upsert"
      ],
      "line_number": 157
    },
    "empirica.core.qdrant.persona_registry.find_personas_by_domain": {
      "name": "find_personas_by_domain",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "domain",
        "limit"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Find personas focused on a specific domain\n\nUses metadata filtering for exact domain matching.\n\nArgs:\n    domain: Domain name (e.g., \"security\", \"performance\")\n    limit: Maximum results to return\n\nRe",
      "decorators": [],
      "calls": [
        "warning",
        "append",
        "scroll",
        "get",
        "_point_to_persona_dict"
      ],
      "line_number": 217
    },
    "empirica.core.qdrant.persona_registry.find_personas_by_tag": {
      "name": "find_personas_by_tag",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "tag",
        "limit"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Find personas by tag\n\nArgs:\n    tag: Tag to search for (e.g., \"builtin\", \"expert\", \"specialist\")\n    limit: Maximum results\n\nReturns:\n    List of matching personas",
      "decorators": [],
      "calls": [
        "warning",
        "append",
        "scroll",
        "get",
        "_point_to_persona_dict"
      ],
      "line_number": 259
    },
    "empirica.core.qdrant.persona_registry.find_similar_personas": {
      "name": "find_similar_personas",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "signing_persona",
        "limit",
        "min_similarity"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Find personas with similar epistemic profiles\n\nUses cosine similarity of epistemic vectors.\n\nArgs:\n    signing_persona: Reference persona\n    limit: Maximum results\n    min_similarity: Minimum similar",
      "decorators": [],
      "calls": [
        "warning",
        "search",
        "append",
        "get",
        "_point_to_persona_dict"
      ],
      "line_number": 291
    },
    "empirica.core.qdrant.persona_registry.get_persona_by_id": {
      "name": "get_persona_by_id",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "persona_id"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get persona by ID\n\nArgs:\n    persona_id: Persona identifier\n\nReturns:\n    Persona dict or None if not found",
      "decorators": [],
      "calls": [
        "retrieve",
        "_persona_id_to_point_id",
        "warning",
        "_point_to_persona_dict"
      ],
      "line_number": 341
    },
    "empirica.core.qdrant.persona_registry.list_all_personas": {
      "name": "list_all_personas",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "List all registered personas\n\nReturns:\n    List of all persona dicts",
      "decorators": [],
      "calls": [
        "warning",
        "info",
        "scroll",
        "len",
        "_point_to_persona_dict"
      ],
      "line_number": 367
    },
    "empirica.core.qdrant.persona_registry.get_personas_by_type": {
      "name": "get_personas_by_type",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "persona_type"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get personas by type (security, ux, performance, etc.)\n\nArgs:\n    persona_type: Type to filter by\n\nReturns:\n    List of personas of that type",
      "decorators": [],
      "calls": [
        "get",
        "scroll",
        "warning",
        "_point_to_persona_dict"
      ],
      "line_number": 392
    },
    "empirica.core.qdrant.persona_registry.get_personas_by_reputation": {
      "name": "get_personas_by_reputation",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "min_reputation",
        "max_reputation",
        "limit"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get high-reputation personas\n\nArgs:\n    min_reputation: Minimum reputation score\n    max_reputation: Maximum reputation score\n    limit: Maximum results\n\nReturns:\n    List of personas sorted by reputa",
      "decorators": [],
      "calls": [
        "get",
        "list_all_personas",
        "sort",
        "warning"
      ],
      "line_number": 420
    },
    "empirica.core.qdrant.persona_registry.delete_persona": {
      "name": "delete_persona",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self",
        "persona_id"
      ],
      "returns": "bool",
      "docstring": "Delete a persona from registry\n\nArgs:\n    persona_id: Persona to delete\n\nReturns:\n    bool: True if deleted successfully",
      "decorators": [],
      "calls": [
        "info",
        "_persona_id_to_point_id",
        "warning",
        "delete"
      ],
      "line_number": 455
    },
    "empirica.core.qdrant.persona_registry.get_registry_stats": {
      "name": "get_registry_stats",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get registry statistics\n\nReturns:\n    Dict with collection stats",
      "decorators": [],
      "calls": [
        "get_collection",
        "warning"
      ],
      "line_number": 479
    },
    "empirica.core.qdrant.persona_registry._persona_id_to_point_id": {
      "name": "_persona_id_to_point_id",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "persona_id"
      ],
      "returns": "int",
      "docstring": "Convert persona_id to Qdrant point ID",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "from_bytes",
        "sha256",
        "digest",
        "encode"
      ],
      "line_number": 503
    },
    "empirica.core.qdrant.persona_registry._point_to_persona_dict": {
      "name": "_point_to_persona_dict",
      "module": "empirica.core.qdrant.persona_registry",
      "params": [
        "point"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert Qdrant point to persona dict",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "get",
        "hasattr"
      ],
      "line_number": 511
    },
    "empirica.core.qdrant.embeddings.get_embedding": {
      "name": "get_embedding",
      "module": "empirica.core.qdrant.embeddings",
      "params": [
        "text"
      ],
      "returns": "List[float]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "EmbeddingsProvider",
        "embed"
      ],
      "line_number": 59
    },
    "empirica.core.qdrant.embeddings.__init__": {
      "name": "__init__",
      "module": "empirica.core.qdrant.embeddings",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "OpenAI",
        "lower",
        "getenv"
      ],
      "line_number": 23
    },
    "empirica.core.qdrant.embeddings.embed": {
      "name": "embed",
      "module": "empirica.core.qdrant.embeddings",
      "params": [
        "self",
        "text"
      ],
      "returns": "List[float]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "create",
        "int",
        "hexdigest",
        "split",
        "sqrt",
        "sha256",
        "encode",
        "sum"
      ],
      "line_number": 37
    },
    "empirica.core.qdrant.vector_store._get_qdrant_client": {
      "name": "_get_qdrant_client",
      "module": "empirica.core.qdrant.vector_store",
      "params": [],
      "returns": "QdrantClient",
      "docstring": "",
      "decorators": [],
      "calls": [
        "QdrantClient",
        "getenv"
      ],
      "line_number": 18
    },
    "empirica.core.qdrant.vector_store._docs_collection": {
      "name": "_docs_collection",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id"
      ],
      "returns": "str",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 26
    },
    "empirica.core.qdrant.vector_store._memory_collection": {
      "name": "_memory_collection",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id"
      ],
      "returns": "str",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 30
    },
    "empirica.core.qdrant.vector_store.init_collections": {
      "name": "init_collections",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id"
      ],
      "returns": "None",
      "docstring": "",
      "decorators": [],
      "calls": [
        "create_collection",
        "_docs_collection",
        "_get_qdrant_client",
        "VectorParams",
        "collection_exists",
        "_memory_collection"
      ],
      "line_number": 34
    },
    "empirica.core.qdrant.vector_store.upsert_docs": {
      "name": "upsert_docs",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id",
        "docs"
      ],
      "returns": "None",
      "docstring": "docs: List of {id, text, metadata:{doc_path, tags, concepts, questions, use_cases}}",
      "decorators": [],
      "calls": [
        "PointStruct",
        "get_embedding",
        "append",
        "_docs_collection",
        "_get_qdrant_client",
        "get",
        "upsert"
      ],
      "line_number": 41
    },
    "empirica.core.qdrant.vector_store.upsert_memory": {
      "name": "upsert_memory",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id",
        "items"
      ],
      "returns": "None",
      "docstring": "items: List of {id, text, type: finding|unknown|mistake|dead_end}",
      "decorators": [],
      "calls": [
        "PointStruct",
        "get_embedding",
        "append",
        "_get_qdrant_client",
        "get",
        "upsert",
        "_memory_collection"
      ],
      "line_number": 62
    },
    "empirica.core.qdrant.vector_store._service_url": {
      "name": "_service_url",
      "module": "empirica.core.qdrant.vector_store",
      "params": [],
      "returns": "Optional[str]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "getenv"
      ],
      "line_number": 77
    },
    "empirica.core.qdrant.vector_store._rest_search": {
      "name": "_rest_search",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "collection",
        "vector",
        "limit"
      ],
      "returns": "List[Dict]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "json",
        "raise_for_status",
        "post",
        "_service_url",
        "get"
      ],
      "line_number": 81
    },
    "empirica.core.qdrant.vector_store.search": {
      "name": "search",
      "module": "empirica.core.qdrant.vector_store",
      "params": [
        "project_id",
        "query_text",
        "kind",
        "limit"
      ],
      "returns": "Dict[str, List[Dict]]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "hasattr",
        "search",
        "getattr",
        "get_embedding",
        "callable",
        "_docs_collection",
        "_get_qdrant_client",
        "get",
        "_memory_collection",
        "_rest_search"
      ],
      "line_number": 94
    },
    "empirica.core.tasks.repository.__init__": {
      "name": "__init__",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "db_path"
      ],
      "returns": "",
      "docstring": "Initialize repository\n\nArgs:\n    db_path: Optional custom database path",
      "decorators": [],
      "calls": [
        "_ensure_tables",
        "SessionDatabase"
      ],
      "line_number": 23
    },
    "empirica.core.tasks.repository._ensure_tables": {
      "name": "_ensure_tables",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create task-related tables if they don't exist",
      "decorators": [],
      "calls": [
        "commit",
        "execute",
        "error",
        "info"
      ],
      "line_number": 33
    },
    "empirica.core.tasks.repository.save_subtask": {
      "name": "save_subtask",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "subtask"
      ],
      "returns": "bool",
      "docstring": "Save subtask to database\n\nArgs:\n    subtask: SubTask object to save\n    \nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "rollback",
        "to_dict",
        "error",
        "info",
        "commit",
        "execute",
        "dumps"
      ],
      "line_number": 84
    },
    "empirica.core.tasks.repository.get_subtask": {
      "name": "get_subtask",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "subtask_id"
      ],
      "returns": "Optional[SubTask]",
      "docstring": "Retrieve subtask by ID\n\nArgs:\n    subtask_id: SubTask identifier\n    \nReturns:\n    SubTask object or None if not found",
      "decorators": [],
      "calls": [
        "from_dict",
        "error",
        "loads",
        "fetchone",
        "execute"
      ],
      "line_number": 141
    },
    "empirica.core.tasks.repository.get_goal_subtasks": {
      "name": "get_goal_subtasks",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "List[SubTask]",
      "docstring": "Retrieve all subtasks for a goal\n\nArgs:\n    goal_id: Goal identifier\n    \nReturns:\n    List of SubTask objects",
      "decorators": [],
      "calls": [
        "fetchall",
        "from_dict",
        "error",
        "loads",
        "append",
        "execute"
      ],
      "line_number": 168
    },
    "empirica.core.tasks.repository.update_subtask_status": {
      "name": "update_subtask_status",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "subtask_id",
        "status",
        "completion_evidence"
      ],
      "returns": "bool",
      "docstring": "Update subtask status\n\nArgs:\n    subtask_id: SubTask identifier\n    status: New status\n    completion_evidence: Optional evidence (commit hash, etc.)\n    \nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "rollback",
        "to_dict",
        "get_subtask",
        "error",
        "info",
        "commit",
        "dumps",
        "execute",
        "time"
      ],
      "line_number": 195
    },
    "empirica.core.tasks.repository.save_decomposition": {
      "name": "save_decomposition",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "decomposition"
      ],
      "returns": "bool",
      "docstring": "Save task decomposition metadata\n\nArgs:\n    decomposition: TaskDecomposition object\n    \nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "rollback",
        "to_dict",
        "save_subtask",
        "error",
        "info",
        "commit",
        "execute",
        "dumps"
      ],
      "line_number": 245
    },
    "empirica.core.tasks.repository.get_decomposition": {
      "name": "get_decomposition",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "Optional[TaskDecomposition]",
      "docstring": "Retrieve task decomposition for a goal\n\nArgs:\n    goal_id: Goal identifier\n    \nReturns:\n    TaskDecomposition object or None if not found",
      "decorators": [],
      "calls": [
        "from_dict",
        "error",
        "loads",
        "fetchone",
        "execute"
      ],
      "line_number": 283
    },
    "empirica.core.tasks.repository.query_subtasks": {
      "name": "query_subtasks",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self",
        "goal_id",
        "status",
        "epistemic_importance"
      ],
      "returns": "List[SubTask]",
      "docstring": "Query subtasks with filters\n\nArgs:\n    goal_id: Filter by goal\n    status: Filter by status\n    epistemic_importance: Filter by importance\n    \nReturns:\n    List of matching SubTask objects",
      "decorators": [],
      "calls": [
        "fetchall",
        "from_dict",
        "error",
        "loads",
        "append",
        "execute"
      ],
      "line_number": 310
    },
    "empirica.core.tasks.repository.close": {
      "name": "close",
      "module": "empirica.core.tasks.repository",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Close database connection",
      "decorators": [],
      "calls": [
        "close"
      ],
      "line_number": 358
    },
    "empirica.core.tasks.types.create": {
      "name": "create",
      "module": "empirica.core.tasks.types",
      "params": [
        "goal_id",
        "description",
        "epistemic_importance"
      ],
      "returns": "'SubTask'",
      "docstring": "Convenience factory method",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "SubTask",
        "uuid4",
        "str"
      ],
      "line_number": 61
    },
    "empirica.core.tasks.types.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.tasks.types",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Serialize to dictionary",
      "decorators": [],
      "calls": [
        "to_dict"
      ],
      "line_number": 134
    },
    "empirica.core.tasks.types.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.tasks.types",
      "params": [
        "data"
      ],
      "returns": "'TaskDecomposition'",
      "docstring": "Deserialize from dictionary",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "get",
        "TaskDecomposition",
        "time",
        "from_dict"
      ],
      "line_number": 146
    },
    "empirica.core.docs.doc_planner._load_yaml": {
      "name": "_load_yaml",
      "module": "empirica.core.docs.doc_planner",
      "params": [
        "path"
      ],
      "returns": "Dict",
      "docstring": "",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "open",
        "safe_load"
      ],
      "line_number": 12
    },
    "empirica.core.docs.doc_planner._load_semantic_index": {
      "name": "_load_semantic_index",
      "module": "empirica.core.docs.doc_planner",
      "params": [
        "root"
      ],
      "returns": "Dict[str, Dict]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "_load_yaml",
        "exists",
        "join"
      ],
      "line_number": 21
    },
    "empirica.core.docs.doc_planner._find_cli_reference": {
      "name": "_find_cli_reference",
      "module": "empirica.core.docs.doc_planner",
      "params": [
        "root"
      ],
      "returns": "Optional[str]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "listdir",
        "startswith",
        "join",
        "lower",
        "isdir"
      ],
      "line_number": 29
    },
    "empirica.core.docs.doc_planner.compute_doc_plan": {
      "name": "compute_doc_plan",
      "module": "empirica.core.docs.doc_planner",
      "params": [
        "project_id",
        "session_id",
        "goal_id"
      ],
      "returns": "Dict",
      "docstring": "Heuristic planner that:\n- Loads semantic index\n- Loads project memory (findings/unknowns/mistakes)\n- Computes a rough completeness score\n- Suggests doc updates (paths + reasons)",
      "decorators": [],
      "calls": [
        "getcwd",
        "SessionDatabase",
        "max",
        "execute",
        "get_project_unknowns",
        "fetchall",
        "dict",
        "items",
        "len",
        "get",
        "lower",
        "_find_cli_reference",
        "append",
        "min",
        "cursor",
        "round",
        "_suggest_if_present",
        "close",
        "get_project_findings",
        "any",
        "_load_semantic_index"
      ],
      "line_number": 39
    },
    "empirica.core.docs.doc_planner._suggest_if_present": {
      "name": "_suggest_if_present",
      "module": "empirica.core.docs.doc_planner",
      "params": [
        "rel",
        "reason"
      ],
      "returns": "None",
      "docstring": "",
      "decorators": [],
      "calls": [
        "append",
        "get"
      ],
      "line_number": 88
    },
    "empirica.core.validation.rehydration.__init__": {
      "name": "__init__",
      "module": "empirica.core.validation.rehydration",
      "params": [
        "self",
        "session_id",
        "ai_id"
      ],
      "returns": "",
      "docstring": "Initialize rehydration.\n\nArgs:\n    session_id: Session ID\n    ai_id: Next AI's identifier",
      "decorators": [],
      "calls": [],
      "line_number": 26
    },
    "empirica.core.validation.rehydration.rehydrate_from_checkpoint": {
      "name": "rehydrate_from_checkpoint",
      "module": "empirica.core.validation.rehydration",
      "params": [
        "self",
        "checkpoint_data",
        "my_knowledge_assessment"
      ],
      "returns": "Dict[str, any]",
      "docstring": "I'm resuming from a checkpoint. What should I understand before starting?\n\nReturns calibration guidance for PREFLIGHT:\n- Which findings am I inheriting?\n- Which unknowns should I be aware of?\n- Should",
      "decorators": [],
      "calls": [
        "round",
        "_format_rehydration_message",
        "get",
        "calculate_understanding_ratio",
        "min",
        "estimate_rehydration_boost",
        "_identify_rehydration_warnings"
      ],
      "line_number": 37
    },
    "empirica.core.validation.rehydration._identify_rehydration_warnings": {
      "name": "_identify_rehydration_warnings",
      "module": "empirica.core.validation.rehydration",
      "params": [
        "self",
        "findings",
        "unknowns",
        "deadends",
        "understanding_ratio",
        "my_knowledge"
      ],
      "returns": "List[str]",
      "docstring": "Identify potential issues during rehydration.\n\nArgs:\n    findings: Previous AI's findings\n    unknowns: Remaining unknowns\n    deadends: Tried and failed approaches\n    understanding_ratio: How much I",
      "decorators": [],
      "calls": [
        "append",
        "len",
        "max",
        "get",
        "sum"
      ],
      "line_number": 107
    },
    "empirica.core.validation.rehydration._format_rehydration_message": {
      "name": "_format_rehydration_message",
      "module": "empirica.core.validation.rehydration",
      "params": [
        "self",
        "understanding_ratio",
        "confidence_boost",
        "warnings",
        "ready"
      ],
      "returns": "str",
      "docstring": "Format human-readable rehydration message",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 170
    },
    "empirica.core.validation.rehydration.calculate_adjusted_preflight": {
      "name": "calculate_adjusted_preflight",
      "module": "empirica.core.validation.rehydration",
      "params": [
        "self",
        "checkpoint_data",
        "my_base_assessment"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate adjusted PREFLIGHT vectors based on rehydration.\n\nTakes my honest assessment and adjusts based on inherited context.\n\nArgs:\n    checkpoint_data: Previous checkpoint with epistemic_tags\n    m",
      "decorators": [],
      "calls": [
        "copy",
        "len",
        "rehydrate_from_checkpoint",
        "get",
        "min"
      ],
      "line_number": 194
    },
    "empirica.core.validation.coherence_validator.__init__": {
      "name": "__init__",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "session_id",
        "ai_id"
      ],
      "returns": "",
      "docstring": "Initialize validator.\n\nArgs:\n    session_id: Current session ID\n    ai_id: AI identifier",
      "decorators": [],
      "calls": [],
      "line_number": 24
    },
    "empirica.core.validation.coherence_validator.validate_before_handoff": {
      "name": "validate_before_handoff",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "preflight_vectors",
        "postflight_vectors",
        "preflight_plan",
        "findings",
        "unknowns"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Validate: can I hand off, or do I need to investigate more?\n\nArgs:\n    preflight_vectors: Assessment at start of phase\n    postflight_vectors: Current epistemic assessment\n    preflight_plan: My origi",
      "decorators": [],
      "calls": [
        "_check_scope_match",
        "append",
        "_check_findings_honesty",
        "_format_message",
        "_check_trajectory"
      ],
      "line_number": 35
    },
    "empirica.core.validation.coherence_validator._check_scope_match": {
      "name": "_check_scope_match",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "preflight_plan"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Check: Did I do what I planned?\n\nArgs:\n    preflight_plan: Original plan (scope estimate, what I'd work on)\n\nReturns:\n    {\n        \"valid\": bool,\n        \"reason\": str - explanation\n    }",
      "decorators": [],
      "calls": [
        "get",
        "get_git_diff_summary",
        "abs"
      ],
      "line_number": 106
    },
    "empirica.core.validation.coherence_validator._check_trajectory": {
      "name": "_check_trajectory",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "preflight_vectors",
        "postflight_vectors"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Check: Is my learning trajectory coherent?\n\nArgs:\n    preflight_vectors: Starting assessment\n    postflight_vectors: Current assessment\n\nReturns:\n    {\n        \"coherent\": bool,\n        \"pattern\": str",
      "decorators": [],
      "calls": [
        "get",
        "analyze_epistemic_trajectory"
      ],
      "line_number": 152
    },
    "empirica.core.validation.coherence_validator._check_findings_honesty": {
      "name": "_check_findings_honesty",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "findings",
        "postflight_vectors"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Check: Are my findings honest? (Not overstating confidence)\n\nArgs:\n    findings: Tagged findings\n    postflight_vectors: My assessment (know, clarity, etc.)\n\nReturns:\n    {\n        \"honest\": bool,\n   ",
      "decorators": [],
      "calls": [
        "get",
        "len",
        "sum"
      ],
      "line_number": 179
    },
    "empirica.core.validation.coherence_validator._format_message": {
      "name": "_format_message",
      "module": "empirica.core.validation.coherence_validator",
      "params": [
        "self",
        "coherent",
        "recommendation",
        "concerns"
      ],
      "returns": "str",
      "docstring": "Format human-readable validation message",
      "decorators": [],
      "calls": [
        "join"
      ],
      "line_number": 223
    },
    "empirica.core.validation.handoff_validator.__init__": {
      "name": "__init__",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "session_id",
        "ai_id"
      ],
      "returns": "",
      "docstring": "Initialize validator.\n\nArgs:\n    session_id: Session ID\n    ai_id: My (next AI's) identifier",
      "decorators": [],
      "calls": [],
      "line_number": 26
    },
    "empirica.core.validation.handoff_validator.validate_handoff": {
      "name": "validate_handoff",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "checkpoint_data",
        "previous_ai_id"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Before I trust previous AI's work, verify it makes sense.\n\nArgs:\n    checkpoint_data: Previous AI's checkpoint\n    previous_ai_id: Who handed off to me\n\nReturns:\n    Validation result:\n    {\n        \"",
      "decorators": [],
      "calls": [
        "_check_claim_vs_reality",
        "_check_unknowns_reasonableness",
        "append",
        "_check_overall_coherence",
        "len",
        "any",
        "get",
        "_format_validation_message",
        "_check_findings_credibility"
      ],
      "line_number": 37
    },
    "empirica.core.validation.handoff_validator._check_claim_vs_reality": {
      "name": "_check_claim_vs_reality",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "checkpoint_data"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Did they do what they claimed?\n\nArgs:\n    checkpoint_data: Their checkpoint\n\nReturns:\n    {\n        \"valid\": bool,\n        \"reason\": str,\n        \"recommendation\": str\n    }",
      "decorators": [],
      "calls": [
        "get",
        "get_git_diff_summary",
        "lower",
        "len"
      ],
      "line_number": 120
    },
    "empirica.core.validation.handoff_validator._check_findings_credibility": {
      "name": "_check_findings_credibility",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "findings",
        "checkpoint_data"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Are findings credible given their assessment?\n\nArgs:\n    findings: Their findings tags\n    checkpoint_data: Full checkpoint\n\nReturns:\n    {\n        \"credible\": bool,\n        \"reason\": str\n    }",
      "decorators": [],
      "calls": [
        "get",
        "len",
        "sum"
      ],
      "line_number": 169
    },
    "empirica.core.validation.handoff_validator._check_unknowns_reasonableness": {
      "name": "_check_unknowns_reasonableness",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "unknowns",
        "findings"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Do the remaining unknowns make sense?\n\nArgs:\n    unknowns: Their remaining unknowns\n    findings: Their findings\n\nReturns:\n    {\n        \"reasonable\": bool,\n        \"reason\": str\n    }",
      "decorators": [],
      "calls": [
        "get",
        "len"
      ],
      "line_number": 225
    },
    "empirica.core.validation.handoff_validator._check_overall_coherence": {
      "name": "_check_overall_coherence",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "checkpoint_data",
        "findings",
        "unknowns"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Does the overall checkpoint hang together coherently?\n\nArgs:\n    checkpoint_data: Full checkpoint\n    findings: Their findings\n    unknowns: Their unknowns\n\nReturns:\n    {\n        \"coherent\": bool,\n  ",
      "decorators": [],
      "calls": [
        "get",
        "len",
        "sum"
      ],
      "line_number": 274
    },
    "empirica.core.validation.handoff_validator._format_validation_message": {
      "name": "_format_validation_message",
      "module": "empirica.core.validation.handoff_validator",
      "params": [
        "self",
        "valid",
        "trustworthy",
        "issues",
        "recommendations"
      ],
      "returns": "str",
      "docstring": "Format human-readable validation message",
      "decorators": [],
      "calls": [],
      "line_number": 320
    },
    "empirica.core.validation.validation_utils.get_git_diff_summary": {
      "name": "get_git_diff_summary",
      "module": "empirica.core.validation.validation_utils",
      "params": [
        "since_preflight"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Get summary of git changes since last checkpoint.\n\nReturns:\n    Dictionary with:\n    - file_count: number of files modified\n    - line_additions: total lines added\n    - line_deletions: total lines de",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "int",
        "run",
        "split",
        "enumerate",
        "replace",
        "strip",
        "len"
      ],
      "line_number": 16
    },
    "empirica.core.validation.validation_utils.analyze_epistemic_trajectory": {
      "name": "analyze_epistemic_trajectory",
      "module": "empirica.core.validation.validation_utils",
      "params": [
        "preflight_vectors",
        "postflight_vectors"
      ],
      "returns": "Dict[str, any]",
      "docstring": "Analyze if epistemic trajectory is coherent.\n\nCoherent patterns:\n- KNOW\u2191 + CLARITY\u2191 + UNCERTAINTY\u2193 = learning happened\n- KNOW\u2193 + CLARITY\u2193 + UNCERTAINTY\u2191 = discovered complexity\n- KNOW\u2192 + CLARITY\u2192 = no",
      "decorators": [],
      "calls": [
        "get",
        "abs"
      ],
      "line_number": 95
    },
    "empirica.core.validation.validation_utils.understand_finding": {
      "name": "understand_finding",
      "module": "empirica.core.validation.validation_utils",
      "params": [
        "finding",
        "my_knowledge"
      ],
      "returns": "bool",
      "docstring": "Estimate if I (next AI) can understand a previous AI's finding.\n\nSimple heuristic: if the domain mentioned in finding matches my knowledge areas,\nassume I understand it. This is validated later during",
      "decorators": [],
      "calls": [
        "get",
        "lower",
        "warning",
        "any"
      ],
      "line_number": 165
    },
    "empirica.core.validation.validation_utils.calculate_understanding_ratio": {
      "name": "calculate_understanding_ratio",
      "module": "empirica.core.validation.validation_utils",
      "params": [
        "findings",
        "my_knowledge"
      ],
      "returns": "float",
      "docstring": "Calculate what percentage of findings I understand.\n\nArgs:\n    findings: List of finding dicts\n    my_knowledge: My knowledge assessment\n\nReturns:\n    float 0.0-1.0 - ratio of understood findings",
      "decorators": [],
      "calls": [
        "len",
        "understand_finding",
        "sum"
      ],
      "line_number": 202
    },
    "empirica.core.validation.validation_utils.estimate_rehydration_boost": {
      "name": "estimate_rehydration_boost",
      "module": "empirica.core.validation.validation_utils",
      "params": [
        "findings",
        "unknowns",
        "my_know"
      ],
      "returns": "float",
      "docstring": "Estimate how much my knowledge should increase from rehydration.\n\nIf I read findings/unknowns and understand them, my confidence\nshould increase because context improved.\n\nArgs:\n    findings: List of ",
      "decorators": [],
      "calls": [
        "min",
        "calculate_understanding_ratio",
        "len",
        "warning"
      ],
      "line_number": 223
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_jira_plugin": {
      "name": "create_jira_plugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: JIRA integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 188
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_confluence_plugin": {
      "name": "create_confluence_plugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Confluence integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 204
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_slack_plugin": {
      "name": "create_slack_plugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Slack integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 219
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_github_plugin": {
      "name": "create_github_plugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: GitHub integration plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 235
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_database_query_plugin": {
      "name": "create_database_query_plugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "InvestigationPlugin",
      "docstring": "Example: Database query plugin",
      "decorators": [],
      "calls": [
        "InvestigationPlugin"
      ],
      "line_number": 251
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.create_common_plugins": {
      "name": "create_common_plugins",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [],
      "returns": "Dict[str, InvestigationPlugin]",
      "docstring": "Create a set of commonly useful plugins",
      "decorators": [],
      "calls": [
        "create_slack_plugin",
        "create_jira_plugin",
        "create_github_plugin",
        "create_confluence_plugin"
      ],
      "line_number": 267
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.__post_init__": {
      "name": "__post_init__",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Validate plugin configuration",
      "decorators": [],
      "calls": [
        "ValueError"
      ],
      "line_number": 55
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.to_capability_dict": {
      "name": "to_capability_dict",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert plugin to capability dictionary for tool mapping\n\nReturns dictionary compatible with Empirica's tool capability format",
      "decorators": [],
      "calls": [],
      "line_number": 82
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.__repr__": {
      "name": "__repr__",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 182
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.__init__": {
      "name": "__init__",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 140
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.register": {
      "name": "register",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self",
        "plugin"
      ],
      "returns": "None",
      "docstring": "Register a plugin",
      "decorators": [],
      "calls": [
        "ValueError",
        "info"
      ],
      "line_number": 143
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.unregister": {
      "name": "unregister",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self",
        "plugin_name"
      ],
      "returns": "None",
      "docstring": "Unregister a plugin",
      "decorators": [],
      "calls": [
        "info"
      ],
      "line_number": 151
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.get": {
      "name": "get",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self",
        "plugin_name"
      ],
      "returns": "Optional[InvestigationPlugin]",
      "docstring": "Get a plugin by name",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 157
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.list_plugins": {
      "name": "list_plugins",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "List[str]",
      "docstring": "List all registered plugin names",
      "decorators": [],
      "calls": [
        "list",
        "keys"
      ],
      "line_number": 161
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.get_all_capabilities": {
      "name": "get_all_capabilities",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "Get capability dictionary for all plugins",
      "decorators": [],
      "calls": [
        "items",
        "to_capability_dict"
      ],
      "line_number": 165
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.find_by_vector": {
      "name": "find_by_vector",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self",
        "vector"
      ],
      "returns": "List[InvestigationPlugin]",
      "docstring": "Find all plugins that improve a specific vector",
      "decorators": [],
      "calls": [
        "values"
      ],
      "line_number": 172
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.__len__": {
      "name": "__len__",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "len"
      ],
      "line_number": 179
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.to_json": {
      "name": "to_json",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Export for tmux display or logging",
      "decorators": [],
      "calls": [
        "_extract_vector_summary"
      ],
      "line_number": 139
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._extract_vector_summary": {
      "name": "_extract_vector_summary",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Extract vector summary for reporting",
      "decorators": [],
      "calls": [],
      "line_number": 2074
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.__init__": {
      "name": "__init__",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "profile_name",
        "ai_model",
        "domain",
        "action_confidence_threshold",
        "max_investigation_rounds",
        "agent_id",
        "tmux_extension",
        "enable_bayesian",
        "enable_drift_monitor",
        "investigation_plugins",
        "enable_action_hooks",
        "auto_start_dashboard",
        "enable_perspective_caching",
        "cache_ttl",
        "enable_session_db",
        "enable_git_notes",
        "session_id",
        "epistemic_bus"
      ],
      "returns": "",
      "docstring": "Initialize canonical cascade\n\nArgs:\n    # NEW: Profile-based configuration\n    profile_name: Investigation profile name (e.g., 'balanced', 'autonomous_agent')\n    ai_model: AI model for auto-selection",
      "decorators": [],
      "calls": [
        "keys",
        "warning",
        "int",
        "get_profile_loader",
        "warn",
        "GitEnhancedReflexLogger",
        "error",
        "ParallelReasoningSystem",
        "info",
        "TokenEfficiencyMetrics",
        "len",
        "SessionJSONHandler",
        "MirrorDriftMonitor",
        "SessionDatabase",
        "CanonicalEpistemicAssessor",
        "time",
        "select_profile",
        "initialize_tmux_dashboard"
      ],
      "line_number": 193
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._parse_vectors_to_assessment": {
      "name": "_parse_vectors_to_assessment",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "vectors",
        "task_id",
        "phase"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Parse vectors dict from MCP into full EpistemicAssessmentSchema object\n\nArgs:\n    vectors: Dict of vector_name -> score (0.0-1.0)\n    task_id: Task identifier\n    phase: Current phase\n\nReturns:\n    Ep",
      "decorators": [],
      "calls": [
        "get",
        "EpistemicAssessmentSchema",
        "get_vector",
        "VectorState"
      ],
      "line_number": 1335
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._identify_knowledge_gaps": {
      "name": "_identify_knowledge_gaps",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Extract self-assessed knowledge gaps from canonical assessment\n\nNO HEURISTICS: AI decides what warrants investigation, not the system.\nThe AI marks vectors during assessment with:\n- warrants_investiga",
      "decorators": [],
      "calls": [
        "append",
        "items"
      ],
      "line_number": 1467
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._identify_epistemic_gaps": {
      "name": "_identify_epistemic_gaps",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Extract self-assessed epistemic gaps - NO HEURISTICS\n\nReturns gaps that AI flagged during self-assessment via warrants_investigation.\nNo threshold-based detection - trusts AI's genuine epistemic evalu",
      "decorators": [],
      "calls": [
        "append",
        "items",
        "get",
        "sort"
      ],
      "line_number": 1611
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._build_tool_capability_map": {
      "name": "_build_tool_capability_map",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "recommendations",
        "context"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "Build capability map from tool recommendations\n\nDescribes what each tool does and which vectors it improves.\nThis provides LLM with information about unknown/custom tools.",
      "decorators": [],
      "calls": [
        "_get_standard_tool_capabilities",
        "_get_empirica_tool_capabilities",
        "update",
        "items",
        "_classify_tool_type",
        "append",
        "to_capability_dict"
      ],
      "line_number": 1653
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._classify_tool_type": {
      "name": "_classify_tool_type",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "tool_name"
      ],
      "returns": "str",
      "docstring": "Classify tool into type for better understanding",
      "decorators": [],
      "calls": [
        "lower",
        "any"
      ],
      "line_number": 1695
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._get_standard_tool_capabilities": {
      "name": "_get_standard_tool_capabilities",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "Standard tools that LLM knows from training\n\nThese don't need detailed explanation, just capability mapping.",
      "decorators": [],
      "calls": [],
      "line_number": 1712
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._get_empirica_tool_capabilities": {
      "name": "_get_empirica_tool_capabilities",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "context"
      ],
      "returns": "Dict[str, Dict[str, Any]]",
      "docstring": "Empirica-specific tools that LLM doesn't know from training\n\nThese need detailed capability descriptions so LLM understands what they do.",
      "decorators": [],
      "calls": [],
      "line_number": 1760
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.update_from_tool_execution": {
      "name": "update_from_tool_execution",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "tool_name",
        "success",
        "vector_addressed",
        "strength"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "DEPRECATED: This function was part of the Bayesian Guardian feature.\nIt is no longer active.",
      "decorators": [],
      "calls": [],
      "line_number": 1862
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._verify_readiness": {
      "name": "_verify_readiness",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Verify readiness to act based on canonical assessment + Bayesian Guardian\n\nIncludes:\n- Standard canonical checks\n- Bayesian discrepancy detection (overconfidence/underconfidence)\n- Drift analysis (if ",
      "decorators": [],
      "calls": [
        "log_cascade_phase",
        "warning",
        "str",
        "log_thought",
        "items",
        "values",
        "join",
        "info",
        "append",
        "detect_drift",
        "len",
        "any",
        "upper",
        "get"
      ],
      "line_number": 1878
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._make_final_decision": {
      "name": "_make_final_decision",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment",
        "check_result",
        "investigation_rounds"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Make final decision based on canonical assessment",
      "decorators": [],
      "calls": [
        "_extract_vector_summary",
        "_generate_execution_guidance",
        "_build_decision_rationale"
      ],
      "line_number": 2023
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._build_decision_rationale": {
      "name": "_build_decision_rationale",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment",
        "investigation_rounds"
      ],
      "returns": "str",
      "docstring": "Build comprehensive decision rationale",
      "decorators": [],
      "calls": [
        "append",
        "join"
      ],
      "line_number": 2048
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._generate_execution_guidance": {
      "name": "_generate_execution_guidance",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "List[str]",
      "docstring": "Generate execution guidance from AI's self-assessed gaps - NO HEURISTICS\n\nReturns guidance based on what AI flagged as needing attention.\nNo threshold-based guidance generation.",
      "decorators": [],
      "calls": [
        "append",
        "items"
      ],
      "line_number": 2095
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._calculate_epistemic_delta": {
      "name": "_calculate_epistemic_delta",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "preflight",
        "postflight"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Calculate epistemic delta between PREFLIGHT and POSTFLIGHT\n\nPositive values = learning/confidence increased\nNegative values = uncertainty increased (sometimes good - discovered unknowns)",
      "decorators": [],
      "calls": [],
      "line_number": 2137
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._check_calibration_accuracy": {
      "name": "_check_calibration_accuracy",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "preflight",
        "postflight",
        "final_decision"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Report calibration delta - NO HEURISTICS\n\nSimply reports the raw numbers. Humans/AIs can interpret what's \"good\" calibration\nbased on context, task complexity, and their own standards.\n\nThe data speak",
      "decorators": [],
      "calls": [],
      "line_number": 2173
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._generate_task_id": {
      "name": "_generate_task_id",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "task"
      ],
      "returns": "str",
      "docstring": "Generate unique task ID",
      "decorators": [],
      "calls": [
        "isoformat",
        "hexdigest",
        "now",
        "sha256",
        "encode"
      ],
      "line_number": 2205
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._enter_phase": {
      "name": "_enter_phase",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "phase"
      ],
      "returns": "",
      "docstring": "DEPRECATED: Phase enforcement removed in Phase 2 refactoring.\n\nThis method is now a no-op for backward compatibility.\nUse self.state.work_context instead for optional logging.",
      "decorators": [],
      "calls": [],
      "line_number": 2211
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade._update_tmux_display": {
      "name": "_update_tmux_display",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "self",
        "phase",
        "assessment",
        "gaps",
        "round_num"
      ],
      "returns": "",
      "docstring": "Update tmux display with current cascade state",
      "decorators": [],
      "calls": [
        "trigger_action_update",
        "open",
        "warning",
        "hasattr",
        "_extract_vector_summary",
        "mkdir",
        "dump",
        "Path",
        "time"
      ],
      "line_number": 2221
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.get_vector": {
      "name": "get_vector",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "params": [
        "name",
        "default",
        "rationale"
      ],
      "returns": "VectorState",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get",
        "VectorState"
      ],
      "line_number": 1355
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.__init__": {
      "name": "__init__",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "custom_strategies"
      ],
      "returns": "",
      "docstring": "Initialize strategy selector with built-in and optional custom strategies\n\nArgs:\n    custom_strategies: Optional dict mapping Domain to custom strategy instances",
      "decorators": [],
      "calls": [
        "CodeAnalysisStrategy",
        "items",
        "ResearchStrategy",
        "GeneralStrategy",
        "register_strategy",
        "CollaborativeStrategy"
      ],
      "line_number": 427
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 54
    },
    "empirica.core.metacognitive_cascade.investigation_strategy._extract_gaps": {
      "name": "_extract_gaps",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Dict[str, VectorState]",
      "docstring": "Extract self-assessed gaps - NO HEURISTICS\n\nReturns dict mapping vector_name \u2192 VectorState for vectors AI flagged\nvia warrants_investigation during self-assessment.",
      "decorators": [],
      "calls": [
        "items"
      ],
      "line_number": 98
    },
    "empirica.core.metacognitive_cascade.investigation_strategy._prioritize_gaps": {
      "name": "_prioritize_gaps",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "gaps"
      ],
      "returns": "List[str]",
      "docstring": "Prioritize gaps by tier and severity\n\nPriority order:\n1. ENGAGEMENT (gate)\n2. FOUNDATION (35% weight)\n3. COMPREHENSION (25% weight)\n4. EXECUTION (25% weight)\n\nWithin tier: lower scores = higher priori",
      "decorators": [],
      "calls": [
        "append",
        "sort",
        "extend"
      ],
      "line_number": 130
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.register_strategy": {
      "name": "register_strategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "domain",
        "strategy"
      ],
      "returns": "None",
      "docstring": "Register a custom investigation strategy for a domain\n\nArgs:\n    domain: Domain enum value\n    strategy: Strategy instance implementing BaseInvestigationStrategy\n    \nExample:\n    class MedicalStrateg",
      "decorators": [],
      "calls": [
        "type",
        "isinstance",
        "TypeError"
      ],
      "line_number": 448
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.get_strategy": {
      "name": "get_strategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "domain"
      ],
      "returns": "BaseInvestigationStrategy",
      "docstring": "Get strategy for domain\n\nArgs:\n    domain: Domain to get strategy for (defaults to GENERAL)\n    \nReturns:\n    Strategy instance for domain, or GENERAL strategy if not found",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 470
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.list_domains": {
      "name": "list_domains",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self"
      ],
      "returns": "List[Domain]",
      "docstring": "List all registered domains",
      "decorators": [],
      "calls": [
        "list",
        "keys"
      ],
      "line_number": 482
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.infer_domain": {
      "name": "infer_domain",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "params": [
        "self",
        "task",
        "context",
        "profile"
      ],
      "returns": "Domain",
      "docstring": "Infer domain based on profile strategy (NO KEYWORD MATCHING).\n\nUses profile.strategy.domain_detection to determine approach:\n- DECLARED: Domain must be in context['domain']\n- REASONING: Use genuine AI",
      "decorators": [],
      "calls": [
        "get",
        "upper",
        "ValueError",
        "load_profile"
      ],
      "line_number": 486
    },
    "empirica.core.identity.signature.create_eep1_payload": {
      "name": "create_eep1_payload",
      "module": "empirica.core.identity.signature",
      "params": [
        "content",
        "epistemic_state",
        "ai_id",
        "cascade_trace_hash",
        "metadata_sources",
        "model_id",
        "session_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Create EEP-1 signature payload\n\nArgs:\n    content: Final output content to sign\n    epistemic_state: Final epistemic vectors (13-D state)\n    ai_id: AI identifier (will be replaced with public key in ",
      "decorators": [],
      "calls": [
        "isoformat",
        "hexdigest",
        "now",
        "sha256",
        "encode"
      ],
      "line_number": 36
    },
    "empirica.core.identity.signature.canonicalize_payload": {
      "name": "canonicalize_payload",
      "module": "empirica.core.identity.signature",
      "params": [
        "payload"
      ],
      "returns": "str",
      "docstring": "Canonicalize payload for signing\n\nEnsures deterministic JSON representation:\n- Sorted keys\n- No whitespace\n- Consistent encoding\n\nArgs:\n    payload: EEP-1 payload\n    \nReturns:\n    str: Canonicalized ",
      "decorators": [],
      "calls": [
        "dumps"
      ],
      "line_number": 80
    },
    "empirica.core.identity.signature.sign_assessment": {
      "name": "sign_assessment",
      "module": "empirica.core.identity.signature",
      "params": [
        "content",
        "epistemic_state",
        "identity",
        "cascade_trace_hash",
        "metadata_sources",
        "model_id",
        "session_id"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Sign assessment with EEP-1 signature\n\nArgs:\n    content: Final output content\n    epistemic_state: Final epistemic vectors\n    identity: AI identity with keypair\n    cascade_trace_hash: Git log hash\n ",
      "decorators": [],
      "calls": [
        "canonicalize_payload",
        "RuntimeError",
        "hex",
        "sign",
        "public_key_hex",
        "isoformat",
        "info",
        "create_eep1_payload",
        "now",
        "encode"
      ],
      "line_number": 98
    },
    "empirica.core.identity.signature.verify_signature": {
      "name": "verify_signature",
      "module": "empirica.core.identity.signature",
      "params": [
        "signed_package",
        "public_key_hex"
      ],
      "returns": "bool",
      "docstring": "Verify EEP-1 signature\n\nArgs:\n    signed_package: Complete signed package from sign_assessment()\n    public_key_hex: Optional public key (uses creator_id if not provided)\n    \nReturns:\n    bool: True ",
      "decorators": [],
      "calls": [
        "canonicalize_payload",
        "warning",
        "verify",
        "error",
        "info",
        "encode",
        "fromhex"
      ],
      "line_number": 181
    },
    "empirica.core.identity.signature.verify_eep1_payload": {
      "name": "verify_eep1_payload",
      "module": "empirica.core.identity.signature",
      "params": [
        "signed_package",
        "content",
        "cascade_trace_hash"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Comprehensive EEP-1 payload verification\n\nVerifies:\n1. Signature is valid (cryptographic integrity)\n2. Content hash matches (if content provided)\n3. Cascade trace hash matches (if provided)\n4. Timesta",
      "decorators": [],
      "calls": [
        "hexdigest",
        "join",
        "append",
        "now",
        "len",
        "sha256",
        "verify_signature",
        "get",
        "encode",
        "fromisoformat"
      ],
      "line_number": 237
    },
    "empirica.core.identity.signature.compute_cascade_trace_hash": {
      "name": "compute_cascade_trace_hash",
      "module": "empirica.core.identity.signature",
      "params": [
        "git_log"
      ],
      "returns": "str",
      "docstring": "Compute CASCADE trace hash from git log\n\nArgs:\n    git_log: Git log output (commit hashes)\n    \nReturns:\n    str: SHA-256 hash of git log",
      "decorators": [],
      "calls": [
        "sha256",
        "hexdigest",
        "encode"
      ],
      "line_number": 342
    },
    "empirica.core.identity.ai_identity.__init__": {
      "name": "__init__",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "identity_dir"
      ],
      "returns": "",
      "docstring": "Initialize identity manager",
      "decorators": [],
      "calls": [
        "Path"
      ],
      "line_number": 278
    },
    "empirica.core.identity.ai_identity.keypair_path": {
      "name": "keypair_path",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "Path",
      "docstring": "Path to keypair file",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 70
    },
    "empirica.core.identity.ai_identity.public_key_path": {
      "name": "public_key_path",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "Path",
      "docstring": "Path to public key file (for distribution)",
      "decorators": [
        "property"
      ],
      "calls": [],
      "line_number": 75
    },
    "empirica.core.identity.ai_identity.generate_keypair": {
      "name": "generate_keypair",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Generate new Ed25519 keypair\n\nRaises:\n    RuntimeError: If keypair already exists",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "public_key",
        "isoformat",
        "info",
        "generate",
        "now"
      ],
      "line_number": 79
    },
    "empirica.core.identity.ai_identity.save_keypair": {
      "name": "save_keypair",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "overwrite"
      ],
      "returns": "None",
      "docstring": "Save keypair to disk\n\nArgs:\n    overwrite: Allow overwriting existing keypair\n    \nRaises:\n    RuntimeError: If no keypair or file exists without overwrite",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "NoEncryption",
        "open",
        "hex",
        "mkdir",
        "dump",
        "info",
        "exists",
        "private_bytes",
        "public_bytes",
        "chmod"
      ],
      "line_number": 96
    },
    "empirica.core.identity.ai_identity.load_keypair": {
      "name": "load_keypair",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "None",
      "docstring": "Load keypair from disk\n\nRaises:\n    FileNotFoundError: If keypair file doesn't exist",
      "decorators": [],
      "calls": [
        "open",
        "FileNotFoundError",
        "info",
        "exists",
        "from_public_bytes",
        "load",
        "get",
        "ValueError",
        "from_private_bytes",
        "fromhex"
      ],
      "line_number": 160
    },
    "empirica.core.identity.ai_identity.sign": {
      "name": "sign",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "message"
      ],
      "returns": "bytes",
      "docstring": "Sign message with private key\n\nArgs:\n    message: Message to sign\n    \nReturns:\n    bytes: Signature\n    \nRaises:\n    RuntimeError: If no private key loaded",
      "decorators": [],
      "calls": [
        "sign",
        "RuntimeError"
      ],
      "line_number": 195
    },
    "empirica.core.identity.ai_identity.verify": {
      "name": "verify",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "signature",
        "message",
        "public_key_bytes"
      ],
      "returns": "bool",
      "docstring": "Verify signature with public key\n\nArgs:\n    signature: Signature to verify\n    message: Original message\n    public_key_bytes: Public key bytes\n    \nReturns:\n    bool: True if signature valid",
      "decorators": [
        "staticmethod"
      ],
      "calls": [
        "verify",
        "from_public_bytes"
      ],
      "line_number": 214
    },
    "empirica.core.identity.ai_identity.public_key_hex": {
      "name": "public_key_hex",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Get public key as hex string",
      "decorators": [],
      "calls": [
        "RuntimeError",
        "public_bytes",
        "hex"
      ],
      "line_number": 233
    },
    "empirica.core.identity.ai_identity.export_public_key": {
      "name": "export_public_key",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Export public key for sharing\n\nReturns:\n    Dict with ai_id, public_key, created_at",
      "decorators": [],
      "calls": [
        "public_key_hex",
        "RuntimeError"
      ],
      "line_number": 243
    },
    "empirica.core.identity.ai_identity.list_identities": {
      "name": "list_identities",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self"
      ],
      "returns": "list[Dict[str, Any]]",
      "docstring": "List all identities\n\nReturns:\n    List of identity summaries",
      "decorators": [],
      "calls": [
        "open",
        "glob",
        "warning",
        "str",
        "append",
        "exists",
        "load"
      ],
      "line_number": 282
    },
    "empirica.core.identity.ai_identity.load_identity": {
      "name": "load_identity",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "ai_id"
      ],
      "returns": "AIIdentity",
      "docstring": "Load existing identity\n\nArgs:\n    ai_id: AI identifier\n    \nReturns:\n    AIIdentity: Loaded identity",
      "decorators": [],
      "calls": [
        "AIIdentity",
        "load_keypair",
        "str"
      ],
      "line_number": 310
    },
    "empirica.core.identity.ai_identity.create_identity": {
      "name": "create_identity",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "ai_id",
        "overwrite"
      ],
      "returns": "AIIdentity",
      "docstring": "Create new identity\n\nArgs:\n    ai_id: AI identifier\n    overwrite: Allow overwriting existing identity\n    \nReturns:\n    AIIdentity: New identity",
      "decorators": [],
      "calls": [
        "AIIdentity",
        "generate_keypair",
        "str",
        "save_keypair"
      ],
      "line_number": 324
    },
    "empirica.core.identity.ai_identity.identity_exists": {
      "name": "identity_exists",
      "module": "empirica.core.identity.ai_identity",
      "params": [
        "self",
        "ai_id"
      ],
      "returns": "bool",
      "docstring": "Check if identity exists",
      "decorators": [],
      "calls": [
        "exists"
      ],
      "line_number": 340
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.example_uncertainty_evaluator": {
      "name": "example_uncertainty_evaluator",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "checkpoint_data"
      ],
      "returns": "SentinelDecision",
      "docstring": "Example Sentinel evaluator - routes based on uncertainty\n\nLogic:\n- UNCERTAINTY > 0.8 \u2192 INVESTIGATE\n- KNOW < 0.5 and DO < 0.5 \u2192 HANDOFF (needs different AI)\n- ENGAGEMENT < 0.6 \u2192 ESCALATE (human needed)",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 185
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.register_evaluator": {
      "name": "register_evaluator",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls",
        "evaluator"
      ],
      "returns": "None",
      "docstring": "Register Sentinel evaluator function\n\nArgs:\n    evaluator: Function that takes checkpoint data and returns SentinelDecision",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "append",
        "info"
      ],
      "line_number": 62
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.clear_evaluators": {
      "name": "clear_evaluators",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls"
      ],
      "returns": "None",
      "docstring": "Clear all evaluators (for testing)",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "clear"
      ],
      "line_number": 74
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.is_enabled": {
      "name": "is_enabled",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls"
      ],
      "returns": "bool",
      "docstring": "Check if Sentinel is enabled",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "len"
      ],
      "line_number": 80
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.evaluate_checkpoint": {
      "name": "evaluate_checkpoint",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls",
        "checkpoint_data",
        "blocking"
      ],
      "returns": "Optional[SentinelDecision]",
      "docstring": "Evaluate checkpoint with Sentinel\n\nArgs:\n    checkpoint_data: Checkpoint from git notes\n    blocking: Wait for decision (default: async)\n    \nReturns:\n    SentinelDecision: Routing decision or None if",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "warning",
        "is_enabled",
        "error",
        "info",
        "evaluator",
        "append",
        "isinstance"
      ],
      "line_number": 85
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.post_checkpoint_hook": {
      "name": "post_checkpoint_hook",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls",
        "session_id",
        "ai_id",
        "phase",
        "checkpoint_data"
      ],
      "returns": "Optional[SentinelDecision]",
      "docstring": "Hook called automatically after checkpoint creation\n\nArgs:\n    session_id: Session ID\n    ai_id: AI ID\n    phase: CASCADE phase\n    checkpoint_data: Full checkpoint data\n    \nReturns:\n    SentinelDeci",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "debug",
        "evaluate_checkpoint",
        "_log_decision",
        "is_enabled"
      ],
      "line_number": 138
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks._log_decision": {
      "name": "_log_decision",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "params": [
        "cls",
        "session_id",
        "ai_id",
        "phase",
        "decision"
      ],
      "returns": "None",
      "docstring": "Log Sentinel decision (could store in database)",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "info"
      ],
      "line_number": 170
    },
    "empirica.core.canonical.empirica_git.session_sync.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self",
        "workspace_root"
      ],
      "returns": "",
      "docstring": "Initialize session sync",
      "decorators": [],
      "calls": [
        "_check_git_repo",
        "getcwd",
        "_check_remote"
      ],
      "line_number": 33
    },
    "empirica.core.canonical.empirica_git.session_sync._check_git_repo": {
      "name": "_check_git_repo",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if we're in a git repository",
      "decorators": [],
      "calls": [
        "run"
      ],
      "line_number": 39
    },
    "empirica.core.canonical.empirica_git.session_sync._check_remote": {
      "name": "_check_remote",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if git remote is configured",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "len"
      ],
      "line_number": 53
    },
    "empirica.core.canonical.empirica_git.session_sync.pull_latest": {
      "name": "pull_latest",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self",
        "notes_only"
      ],
      "returns": "bool",
      "docstring": "Pull latest checkpoints/goals from remote\n\nArgs:\n    notes_only: Only fetch notes (faster, safer)\n    \nReturns:\n    bool: Success",
      "decorators": [],
      "calls": [
        "debug",
        "warning",
        "run",
        "info"
      ],
      "line_number": 70
    },
    "empirica.core.canonical.empirica_git.session_sync.push_checkpoint": {
      "name": "push_checkpoint",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self",
        "notes_only"
      ],
      "returns": "bool",
      "docstring": "Push checkpoint/goal to remote\n\nArgs:\n    notes_only: Only push notes (safer)\n    \nReturns:\n    bool: Success",
      "decorators": [],
      "calls": [
        "debug",
        "warning",
        "run",
        "info"
      ],
      "line_number": 118
    },
    "empirica.core.canonical.empirica_git.session_sync.auto_sync_before_resume": {
      "name": "auto_sync_before_resume",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Automatically sync before session resume\n\nReturns:\n    Dict: Sync status",
      "decorators": [],
      "calls": [
        "pull_latest"
      ],
      "line_number": 166
    },
    "empirica.core.canonical.empirica_git.session_sync.auto_sync_after_checkpoint": {
      "name": "auto_sync_after_checkpoint",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "params": [
        "self",
        "auto_push"
      ],
      "returns": "bool",
      "docstring": "Automatically sync after checkpoint creation\n\nArgs:\n    auto_push: Enable automatic push\n    \nReturns:\n    bool: Success",
      "decorators": [],
      "calls": [
        "debug",
        "push_checkpoint"
      ],
      "line_number": 188
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.auto_checkpoint": {
      "name": "auto_checkpoint",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "session_id",
        "ai_id",
        "phase",
        "vectors",
        "round_num",
        "metadata",
        "no_git_flag"
      ],
      "returns": "Optional[str]",
      "docstring": "Automatically create checkpoint if conditions met\n\nArgs:\n    session_id: Session identifier\n    ai_id: AI identifier\n    phase: CASCADE phase (PREFLIGHT, CHECK, POSTFLIGHT, etc.)\n    vectors: Epistemi",
      "decorators": [],
      "calls": [
        "warning",
        "info",
        "_create_checkpoint",
        "is_enabled"
      ],
      "line_number": 85
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "workspace_root"
      ],
      "returns": "",
      "docstring": "Initialize checkpoint manager\n\nArgs:\n    workspace_root: Root directory (defaults to cwd)",
      "decorators": [],
      "calls": [
        "_check_git_repo",
        "getcwd"
      ],
      "line_number": 36
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager._check_git_repo": {
      "name": "_check_git_repo",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if we're in a git repository",
      "decorators": [],
      "calls": [
        "run"
      ],
      "line_number": 46
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.is_enabled": {
      "name": "is_enabled",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "no_git_flag"
      ],
      "returns": "bool",
      "docstring": "Check if checkpoints are enabled\n\nLogic:\n- If --no-git flag set: disabled\n- If in git repo: enabled\n- Otherwise: disabled\n\nArgs:\n    no_git_flag: User explicitly disabled git\n    \nReturns:\n    bool: W",
      "decorators": [],
      "calls": [
        "debug"
      ],
      "line_number": 60
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager._create_checkpoint": {
      "name": "_create_checkpoint",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "session_id",
        "ai_id",
        "phase",
        "vectors",
        "round_num",
        "metadata"
      ],
      "returns": "str",
      "docstring": "Create compressed checkpoint in git notes\n\nFormat (compressed for ~85% token reduction):\n{\n    \"session_id\": \"abc123\",\n    \"ai_id\": \"claude-code\",\n    \"phase\": \"PREFLIGHT\",\n    \"round\": 1,\n    \"timest",
      "decorators": [],
      "calls": [
        "run",
        "isoformat",
        "now",
        "strip",
        "dumps"
      ],
      "line_number": 131
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.load_checkpoint": {
      "name": "load_checkpoint",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "session_id",
        "ai_id",
        "commit_hash"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load checkpoint from git notes\n\nArgs:\n    session_id: Filter by session\n    ai_id: Filter by AI\n    commit_hash: Load specific commit\n    \nReturns:\n    Dict: Checkpoint data or None if not found",
      "decorators": [],
      "calls": [
        "warning",
        "_find_latest_checkpoint",
        "_load_checkpoint_by_hash"
      ],
      "line_number": 195
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager._load_checkpoint_by_hash": {
      "name": "_load_checkpoint_by_hash",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "commit_hash"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load checkpoint from specific commit",
      "decorators": [],
      "calls": [
        "run",
        "loads"
      ],
      "line_number": 227
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.load_recent_checkpoints": {
      "name": "load_recent_checkpoints",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "session_id",
        "ai_id",
        "count"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Load recent checkpoints matching filters\n\nArgs:\n    session_id: Filter by session\n    ai_id: Filter by AI\n    count: Number of recent checkpoints to return\n\nReturns:\n    List of checkpoint dicts (most",
      "decorators": [],
      "calls": [
        "warning",
        "run",
        "split",
        "append",
        "strip",
        "len",
        "get",
        "_load_checkpoint_by_hash"
      ],
      "line_number": 241
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager._find_latest_checkpoint": {
      "name": "_find_latest_checkpoint",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "params": [
        "self",
        "session_id",
        "ai_id"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Find latest checkpoint matching filters",
      "decorators": [],
      "calls": [
        "run",
        "split",
        "strip",
        "get",
        "_load_checkpoint_by_hash"
      ],
      "line_number": 299
    },
    "empirica.core.canonical.empirica_git.goal_store.__init__": {
      "name": "__init__",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self",
        "workspace_root"
      ],
      "returns": "",
      "docstring": "Initialize git goal store",
      "decorators": [],
      "calls": [
        "_check_git_repo",
        "getcwd"
      ],
      "line_number": 54
    },
    "empirica.core.canonical.empirica_git.goal_store._check_git_repo": {
      "name": "_check_git_repo",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if we're in a git repository",
      "decorators": [],
      "calls": [
        "run"
      ],
      "line_number": 59
    },
    "empirica.core.canonical.empirica_git.goal_store.store_goal": {
      "name": "store_goal",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self",
        "goal_id",
        "session_id",
        "ai_id",
        "goal_data",
        "epistemic_state",
        "lineage"
      ],
      "returns": "bool",
      "docstring": "Store goal in git notes\n\nArgs:\n    goal_id: Goal UUID\n    session_id: Session identifier\n    ai_id: AI that created goal\n    goal_data: Complete goal data (from database)\n    epistemic_state: Current ",
      "decorators": [],
      "calls": [
        "warning",
        "debug",
        "run",
        "isoformat",
        "info",
        "now",
        "strip",
        "dumps"
      ],
      "line_number": 73
    },
    "empirica.core.canonical.empirica_git.goal_store.load_goal": {
      "name": "load_goal",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self",
        "goal_id"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Load goal from git notes\n\nArgs:\n    goal_id: Goal UUID\n    \nReturns:\n    Dict: Goal payload or None",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "warning",
        "loads"
      ],
      "line_number": 148
    },
    "empirica.core.canonical.empirica_git.goal_store.discover_goals": {
      "name": "discover_goals",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self",
        "from_ai_id",
        "session_id"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Discover goals from other AIs\n\nArgs:\n    from_ai_id: Filter by AI creator\n    session_id: Filter by session\n    \nReturns:\n    List[Dict]: Matching goals",
      "decorators": [],
      "calls": [
        "startswith",
        "warning",
        "run",
        "load_goal",
        "split",
        "append",
        "strip",
        "len",
        "get"
      ],
      "line_number": 192
    },
    "empirica.core.canonical.empirica_git.goal_store.add_lineage": {
      "name": "add_lineage",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "params": [
        "self",
        "goal_id",
        "ai_id",
        "action"
      ],
      "returns": "bool",
      "docstring": "Add lineage entry when AI resumes goal\n\nArgs:\n    goal_id: Goal UUID\n    ai_id: AI taking action\n    action: Action type (resumed, completed, modified)\n    \nReturns:\n    bool: Success",
      "decorators": [],
      "calls": [
        "store_goal",
        "load_goal",
        "isoformat",
        "append",
        "now",
        "get"
      ],
      "line_number": 260
    },
    "empirica.core.persona.harness.persona_harness.__init__": {
      "name": "__init__",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "persona_id",
        "personas_dir",
        "sentinel_endpoint",
        "enable_sentinel"
      ],
      "returns": "",
      "docstring": "Initialize PersonaHarness\n\nArgs:\n    persona_id: Persona identifier to load\n    personas_dir: Custom persona directory (default: .empirica/personas)\n    sentinel_endpoint: Sentinel communication endpo",
      "decorators": [],
      "calls": [
        "warning",
        "load_keypair",
        "PersonaManager",
        "info",
        "load_persona",
        "save_keypair",
        "AIIdentity",
        "generate_keypair",
        "get_type"
      ],
      "line_number": 57
    },
    "empirica.core.persona.harness.persona_harness._create_persona_cascade": {
      "name": "_create_persona_cascade",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Create CASCADE instance with persona-specific configuration\n\nOverrides:\n- Thresholds (uncertainty_trigger, confidence_to_proceed)\n- Weights (foundation/comprehension/execution/engagement)\n- Investigat",
      "decorators": [],
      "calls": [
        "int",
        "_create_persona_aware_assessment",
        "timestamp",
        "_select_investigation_profile",
        "info",
        "now",
        "CanonicalEpistemicCascade"
      ],
      "line_number": 189
    },
    "empirica.core.persona.harness.persona_harness._create_persona_aware_assessment": {
      "name": "_create_persona_aware_assessment",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "original_assess_method"
      ],
      "returns": "",
      "docstring": "Wrap CASCADE assessment to apply persona priors\n\nThis ensures that the persona's domain-specific knowledge is reflected\nin the initial epistemic state.",
      "decorators": [],
      "calls": [
        "original_assess_method",
        "_apply_priors"
      ],
      "line_number": 233
    },
    "empirica.core.persona.harness.persona_harness._apply_priors": {
      "name": "_apply_priors",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "assessment",
        "phase"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Apply persona priors to assessment\n\nWorks with EpistemicAssessmentSchema using prefixed field names.",
      "decorators": [],
      "calls": [
        "debug",
        "blend_vector_new",
        "calculate_tier_confidences",
        "VectorAssessment"
      ],
      "line_number": 253
    },
    "empirica.core.persona.harness.persona_harness._select_investigation_profile": {
      "name": "_select_investigation_profile",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Select CASCADE investigation profile based on persona type\n\nMaps persona types to investigation profiles:\n- security \u2192 cautious (low threshold, many rounds)\n- ux \u2192 balanced\n- performance \u2192 autonomous_",
      "decorators": [],
      "calls": [
        "get",
        "get_type"
      ],
      "line_number": 309
    },
    "empirica.core.persona.harness.persona_harness._interpret_with_persona": {
      "name": "_interpret_with_persona",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "cascade_result"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Interpret CASCADE result through persona lens\n\nAdds persona-specific findings and recommendations based on:\n- Focus domains\n- Persona type\n- Domain expertise",
      "decorators": [],
      "calls": [
        "copy",
        "get_type",
        "_extract_persona_findings",
        "_generate_persona_recommendation"
      ],
      "line_number": 334
    },
    "empirica.core.persona.harness.persona_harness._extract_persona_findings": {
      "name": "_extract_persona_findings",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "cascade_result",
        "focus_domains"
      ],
      "returns": "list",
      "docstring": "Extract findings relevant to persona focus domains\n\nExample for security persona:\n- Looks for security-related keywords in rationale\n- Flags authentication, authorization issues\n- Identifies potential",
      "decorators": [],
      "calls": [
        "get",
        "lower",
        "extend",
        "append"
      ],
      "line_number": 370
    },
    "empirica.core.persona.harness.persona_harness._generate_persona_recommendation": {
      "name": "_generate_persona_recommendation",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self",
        "cascade_result",
        "persona_type"
      ],
      "returns": "str",
      "docstring": "Generate persona-specific recommendation\n\nDifferent personas have different recommendation styles:\n- Security: Cautious, emphasizes risks\n- UX: User-focused, emphasizes usability\n- Performance: Metric",
      "decorators": [],
      "calls": [
        "upper"
      ],
      "line_number": 398
    },
    "empirica.core.persona.harness.persona_harness.get_persona_info": {
      "name": "get_persona_info",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get persona information",
      "decorators": [],
      "calls": [
        "get_type"
      ],
      "line_number": 498
    },
    "empirica.core.persona.harness.persona_harness.blend_vector_new": {
      "name": "blend_vector_new",
      "module": "empirica.core.persona.harness.persona_harness",
      "params": [
        "baseline_vector",
        "prior_value",
        "vector_name"
      ],
      "returns": "VectorAssessment",
      "docstring": "Blend baseline assessment with persona prior (NEW schema)",
      "decorators": [],
      "calls": [
        "VectorAssessment"
      ],
      "line_number": 270
    },
    "empirica.core.persona.harness.communication.send_message": {
      "name": "send_message",
      "module": "empirica.core.persona.harness.communication",
      "params": [
        "message",
        "transport",
        "destination"
      ],
      "returns": "",
      "docstring": "Send message via transport mechanism\n\nArgs:\n    message: SentinelMessage or PersonaMessage\n    transport: Transport type (\"file\", \"redis\", \"grpc\")\n    destination: Destination path/address\n\nReturns:\n ",
      "decorators": [],
      "calls": [
        "open",
        "to_dict",
        "debug",
        "NotImplementedError",
        "error",
        "mkdir",
        "dump",
        "Path",
        "isinstance",
        "ValueError"
      ],
      "line_number": 184
    },
    "empirica.core.persona.harness.communication.receive_message": {
      "name": "receive_message",
      "module": "empirica.core.persona.harness.communication",
      "params": [
        "persona_id",
        "transport",
        "source",
        "timeout"
      ],
      "returns": "",
      "docstring": "Receive message for persona\n\nArgs:\n    persona_id: Persona identifier\n    transport: Transport type (\"file\", \"redis\", \"grpc\")\n    source: Source path/address\n    timeout: Timeout in seconds (None = no",
      "decorators": [],
      "calls": [
        "glob",
        "open",
        "sleep",
        "unlink",
        "from_dict",
        "debug",
        "NotImplementedError",
        "sorted",
        "error",
        "Path",
        "exists",
        "ValueError",
        "load",
        "time"
      ],
      "line_number": 236
    },
    "empirica.core.persona.harness.communication.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.persona.harness.communication",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to dictionary for transmission",
      "decorators": [],
      "calls": [],
      "line_number": 134
    },
    "empirica.core.persona.harness.communication.from_dict": {
      "name": "from_dict",
      "module": "empirica.core.persona.harness.communication",
      "params": [
        "cls",
        "data"
      ],
      "returns": "'PersonaMessage'",
      "docstring": "Parse from dictionary",
      "decorators": [
        "classmethod"
      ],
      "calls": [
        "get",
        "cls",
        "MessageType"
      ],
      "line_number": 146
    },
    "empirica.core.persona.harness.communication.sign": {
      "name": "sign",
      "module": "empirica.core.persona.harness.communication",
      "params": [
        "self",
        "identity"
      ],
      "returns": "None",
      "docstring": "Sign message using AIIdentity (Phase 2 integration)\n\nArgs:\n    identity: AIIdentity instance with loaded keypair",
      "decorators": [],
      "calls": [
        "dumps",
        "sign_assessment",
        "to_dict",
        "pop"
      ],
      "line_number": 157
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator.__init__": {
      "name": "__init__",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "sentinel_id",
        "composition_strategy",
        "arbitration_strategy",
        "personas_dir",
        "session_id"
      ],
      "returns": "",
      "docstring": "Initialize SentinelOrchestrator\n\nArgs:\n    sentinel_id: Identifier for this orchestrator instance\n    composition_strategy: How to merge assessments\n        (\"average\", \"weighted_by_confidence\", \"weig",
      "decorators": [],
      "calls": [
        "get_composition_strategy",
        "get_arbitration_strategy",
        "PersonaManager",
        "info"
      ],
      "line_number": 54
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._load_persona_profiles": {
      "name": "_load_persona_profiles",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "personas"
      ],
      "returns": "Dict[str, PersonaProfile]",
      "docstring": "Load persona profiles for all personas",
      "decorators": [],
      "calls": [
        "ValueError",
        "load_persona"
      ],
      "line_number": 205
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._create_persona_harnesses": {
      "name": "_create_persona_harnesses",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "personas"
      ],
      "returns": "Dict[str, PersonaHarness]",
      "docstring": "Create PersonaHarness instances for all personas",
      "decorators": [],
      "calls": [
        "PersonaHarness"
      ],
      "line_number": 215
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._compose_assessments": {
      "name": "_compose_assessments",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "persona_assessments",
        "persona_profiles",
        "task",
        "context"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Apply composition strategy to merge assessments",
      "decorators": [],
      "calls": [
        "composition_strategy"
      ],
      "line_number": 318
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._extract_actions_and_confidences": {
      "name": "_extract_actions_and_confidences",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "persona_assessments"
      ],
      "returns": "tuple[Dict[str, str], Dict[str, float]]",
      "docstring": "Extract recommended actions and confidences from assessments",
      "decorators": [],
      "calls": [
        "determine_action",
        "items",
        "calculate_tier_confidences"
      ],
      "line_number": 341
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._arbitrate_conflicts": {
      "name": "_arbitrate_conflicts",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "persona_actions",
        "persona_confidences",
        "persona_assessments",
        "persona_profiles",
        "task",
        "context"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Apply arbitration strategy to resolve conflicts",
      "decorators": [],
      "calls": [
        "arbitration_strategy"
      ],
      "line_number": 361
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._calculate_agreement_score": {
      "name": "_calculate_agreement_score",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "persona_actions"
      ],
      "returns": "float",
      "docstring": "Calculate agreement score (0.0-1.0) based on action consensus",
      "decorators": [],
      "calls": [
        "len",
        "Counter",
        "values",
        "most_common"
      ],
      "line_number": 393
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator._detect_conflicts": {
      "name": "_detect_conflicts",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "self",
        "persona_actions"
      ],
      "returns": "List[str]",
      "docstring": "Detect and describe conflicts between personas",
      "decorators": [],
      "calls": [
        "items",
        "values",
        "append",
        "len",
        "Counter",
        "set"
      ],
      "line_number": 404
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator.mock_vector": {
      "name": "mock_vector",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "params": [
        "name",
        "prior_score"
      ],
      "returns": "VectorAssessment",
      "docstring": "",
      "decorators": [],
      "calls": [
        "VectorAssessment"
      ],
      "line_number": 293
    },
    "empirica.core.persona.sentinel.arbitration_strategies.majority_vote_arbitration": {
      "name": "majority_vote_arbitration",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "persona_actions",
        "persona_confidences",
        "persona_assessments"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Majority vote arbitration - simple democratic approach\n\nThe most common action wins. If tied, choose most cautious.\n\nArgs:\n    persona_actions: {persona_id: action} (\"proceed\"|\"investigate\"|\"escalate\"",
      "decorators": [],
      "calls": [
        "dict",
        "values",
        "info",
        "append",
        "ArbitrationResult",
        "_choose_most_cautious",
        "Counter",
        "most_common",
        "ValueError",
        "len"
      ],
      "line_number": 26
    },
    "empirica.core.persona.sentinel.arbitration_strategies.confidence_weighted_arbitration": {
      "name": "confidence_weighted_arbitration",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "persona_actions",
        "persona_confidences",
        "persona_assessments"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Confidence-weighted arbitration\n\nWeight each vote by the persona's confidence. Personas with higher\nconfidence have more influence.\n\nArgs:\n    persona_actions: {persona_id: action}\n    persona_confide",
      "decorators": [],
      "calls": [
        "warning",
        "items",
        "values",
        "info",
        "append",
        "majority_vote_arbitration",
        "ArbitrationResult",
        "len",
        "ValueError",
        "max",
        "get",
        "sum"
      ],
      "line_number": 87
    },
    "empirica.core.persona.sentinel.arbitration_strategies.pessimistic_arbitration": {
      "name": "pessimistic_arbitration",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "persona_actions",
        "persona_confidences",
        "persona_assessments"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Pessimistic arbitration - choose most cautious action\n\nPrioritizes safety: escalate > investigate > proceed\nIf ANY persona says escalate, we escalate.\nIf ANY persona says investigate (and none say esc",
      "decorators": [],
      "calls": [
        "items",
        "info",
        "ArbitrationResult",
        "len",
        "ValueError"
      ],
      "line_number": 153
    },
    "empirica.core.persona.sentinel.arbitration_strategies.domain_weighted_arbitration": {
      "name": "domain_weighted_arbitration",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "persona_actions",
        "persona_confidences",
        "persona_assessments",
        "persona_profiles",
        "task",
        "context"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Domain-weighted arbitration\n\nWeight votes by how relevant each persona's domain is to the task.\nFor example, for \"implement caching\", performance persona's vote\ncarries more weight.\n\nArgs:\n    persona",
      "decorators": [],
      "calls": [
        "warning",
        "items",
        "values",
        "info",
        "append",
        "ArbitrationResult",
        "len",
        "ValueError",
        "max",
        "get",
        "lower",
        "sum",
        "confidence_weighted_arbitration"
      ],
      "line_number": 222
    },
    "empirica.core.persona.sentinel.arbitration_strategies.escalate_on_conflict_arbitration": {
      "name": "escalate_on_conflict_arbitration",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "persona_actions",
        "persona_confidences",
        "persona_assessments"
      ],
      "returns": "ArbitrationResult",
      "docstring": "Escalate on conflict arbitration\n\nIf there's ANY disagreement between personas, escalate to human.\nOnly proceed if all personas unanimously agree.\n\nVery safe but may escalate frequently.\n\nArgs:\n    pe",
      "decorators": [],
      "calls": [
        "list",
        "items",
        "values",
        "info",
        "ArbitrationResult",
        "len",
        "Counter",
        "ValueError",
        "set"
      ],
      "line_number": 319
    },
    "empirica.core.persona.sentinel.arbitration_strategies._choose_most_cautious": {
      "name": "_choose_most_cautious",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "actions"
      ],
      "returns": "str",
      "docstring": "Choose most cautious action from a list\n\nCaution ranking: escalate > investigate > proceed",
      "decorators": [],
      "calls": [],
      "line_number": 377
    },
    "empirica.core.persona.sentinel.arbitration_strategies.get_arbitration_strategy": {
      "name": "get_arbitration_strategy",
      "module": "empirica.core.persona.sentinel.arbitration_strategies",
      "params": [
        "strategy_name"
      ],
      "returns": "",
      "docstring": "Get arbitration strategy function by name",
      "decorators": [],
      "calls": [
        "list",
        "keys",
        "ValueError"
      ],
      "line_number": 401
    },
    "empirica.core.persona.sentinel.composition_strategies.average_composition": {
      "name": "average_composition",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "persona_assessments",
        "persona_profiles"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Simple average composition - baseline strategy\n\nFor each vector, take the mean score across all personas and\nconcatenate rationales.\n\nArgs:\n    persona_assessments: {persona_id: EpistemicAssessmentSch",
      "decorators": [],
      "calls": [
        "list",
        "VectorAssessment",
        "compose_vector",
        "keys",
        "int",
        "EpistemicAssessmentSchema",
        "items",
        "getattr",
        "join",
        "info",
        "append",
        "mean",
        "len",
        "ValueError"
      ],
      "line_number": 27
    },
    "empirica.core.persona.sentinel.composition_strategies.weighted_by_confidence_composition": {
      "name": "weighted_by_confidence_composition",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "persona_assessments",
        "persona_profiles"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Weighted composition by persona confidence\n\nWeight each persona's contribution by their overall confidence\n(calculated as average of foundation tier scores).\n\nPersonas with higher confidence have more",
      "decorators": [],
      "calls": [
        "list",
        "VectorAssessment",
        "average_composition",
        "keys",
        "warning",
        "compose_vector_weighted",
        "int",
        "items",
        "EpistemicAssessmentSchema",
        "getattr",
        "calculate_tier_confidences",
        "values",
        "info",
        "append",
        "join",
        "len",
        "ValueError",
        "sum"
      ],
      "line_number": 94
    },
    "empirica.core.persona.sentinel.composition_strategies.weighted_by_domain_composition": {
      "name": "weighted_by_domain_composition",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "persona_assessments",
        "persona_profiles",
        "task",
        "context"
      ],
      "returns": "EpistemicAssessmentSchema",
      "docstring": "Weighted composition by domain relevance\n\nWeight each persona by how relevant their focus domains are to the task.\nFor example, for \"implement caching\", performance persona gets higher weight.\n\nArgs:\n",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "max",
        "items",
        "values",
        "len",
        "lower",
        "list",
        "VectorAssessment",
        "keys",
        "EpistemicAssessmentSchema",
        "info",
        "append",
        "sum",
        "average_composition",
        "compose_vector_weighted",
        "int",
        "join",
        "ValueError"
      ],
      "line_number": 185
    },
    "empirica.core.persona.sentinel.composition_strategies.get_composition_strategy": {
      "name": "get_composition_strategy",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "strategy_name"
      ],
      "returns": "",
      "docstring": "Get composition strategy function by name",
      "decorators": [],
      "calls": [
        "list",
        "keys",
        "ValueError"
      ],
      "line_number": 293
    },
    "empirica.core.persona.sentinel.composition_strategies.compose_vector": {
      "name": "compose_vector",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "vector_name"
      ],
      "returns": "VectorAssessment",
      "docstring": "Average a single vector across all personas",
      "decorators": [],
      "calls": [
        "VectorAssessment",
        "int",
        "items",
        "getattr",
        "join",
        "mean",
        "append",
        "len"
      ],
      "line_number": 50
    },
    "empirica.core.persona.sentinel.composition_strategies.compose_vector_weighted": {
      "name": "compose_vector_weighted",
      "module": "empirica.core.persona.sentinel.composition_strategies",
      "params": [
        "vector_name"
      ],
      "returns": "VectorAssessment",
      "docstring": "Weighted average of a single vector",
      "decorators": [],
      "calls": [
        "VectorAssessment",
        "int",
        "items",
        "getattr",
        "join",
        "append",
        "sum"
      ],
      "line_number": 236
    },
    "empirica.core.persona.sentinel.orchestration_result.to_dict": {
      "name": "to_dict",
      "module": "empirica.core.persona.sentinel.orchestration_result",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Convert to dictionary for serialization",
      "decorators": [],
      "calls": [
        "items",
        "to_dict"
      ],
      "line_number": 95
    },
    "empirica.core.persona.sentinel.orchestration_result.get_summary": {
      "name": "get_summary",
      "module": "empirica.core.persona.sentinel.orchestration_result",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Get human-readable summary of orchestration result",
      "decorators": [],
      "calls": [
        "join",
        "append",
        "len",
        "upper",
        "get"
      ],
      "line_number": 116
    },
    "empirica.api.routes.verification.verify_checkpoint": {
      "name": "verify_checkpoint",
      "module": "empirica.api.routes.verification",
      "params": [
        "session_id",
        "phase",
        "round"
      ],
      "returns": "",
      "docstring": "Verify cryptographic signature of a checkpoint.\n\nReturns verification status, signer identity, and content hash.",
      "decorators": [],
      "calls": [
        "get",
        "route",
        "jsonify"
      ],
      "line_number": 11
    },
    "empirica.api.routes.verification.list_session_signatures": {
      "name": "list_session_signatures",
      "module": "empirica.api.routes.verification",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "List all verified signatures for a session.\n\nShows verification status of all PREFLIGHT, CHECK, and POSTFLIGHT checkpoints.",
      "decorators": [],
      "calls": [
        "route",
        "jsonify"
      ],
      "line_number": 32
    },
    "empirica.api.routes.sessions.list_sessions": {
      "name": "list_sessions",
      "module": "empirica.api.routes.sessions",
      "params": [],
      "returns": "",
      "docstring": "List all sessions with filtering and pagination.\n\n**Query Parameters:**\n- `ai_id`: Filter by AI agent (e.g., \"copilot\")\n- `since`: ISO timestamp (e.g., \"2025-11-01\")\n- `limit`: Max results (1-1000, de",
      "decorators": [],
      "calls": [
        "cursor",
        "route",
        "fetchall",
        "str",
        "int",
        "error",
        "append",
        "jsonify",
        "len",
        "fetchone",
        "SessionDatabase",
        "get",
        "execute",
        "min",
        "extend"
      ],
      "line_number": 11
    },
    "empirica.api.routes.sessions.get_session": {
      "name": "get_session",
      "module": "empirica.api.routes.sessions",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "Retrieve detailed session information including epistemic timeline and git state.\n\n**Path Parameters:**\n- `session_id`: Session UUID\n\n**Response includes:**\n- Epistemic vectors (PREFLIGHT \u2192 POSTFLIGHT",
      "decorators": [],
      "calls": [
        "cursor",
        "route",
        "fetchall",
        "str",
        "int",
        "error",
        "append",
        "jsonify",
        "len",
        "fetchone",
        "SessionDatabase",
        "execute"
      ],
      "line_number": 97
    },
    "empirica.api.routes.sessions.get_session_checks": {
      "name": "get_session_checks",
      "module": "empirica.api.routes.sessions",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "Get all CHECK assessments for a session with findings/unknowns",
      "decorators": [],
      "calls": [
        "route",
        "str",
        "error",
        "close",
        "append",
        "jsonify",
        "len",
        "SessionDatabase",
        "get_vectors_by_phase",
        "get"
      ],
      "line_number": 198
    },
    "empirica.api.routes.heatmaps.get_file_uncertainty": {
      "name": "get_file_uncertainty",
      "module": "empirica.api.routes.heatmaps",
      "params": [
        "filepath"
      ],
      "returns": "",
      "docstring": "Get confidence/uncertainty metrics for a specific file.\n\nReturns:\n- Overall uncertainty and KNOW/DO metrics\n- List of changes with confidence scores\n- Aggregate confidence for file",
      "decorators": [],
      "calls": [
        "route",
        "jsonify"
      ],
      "line_number": 11
    },
    "empirica.api.routes.heatmaps.get_module_epistemic": {
      "name": "get_module_epistemic",
      "module": "empirica.api.routes.heatmaps",
      "params": [
        "module_name"
      ],
      "returns": "",
      "docstring": "Get epistemic knowledge map for a module/directory.\n\nReturns:\n- Confidence breakdown by submodule\n- Overall coverage and risk areas\n- Testing status\n- Last modification timestamp",
      "decorators": [],
      "calls": [
        "route",
        "jsonify"
      ],
      "line_number": 37
    },
    "empirica.api.routes.deltas.get_session_deltas": {
      "name": "get_session_deltas",
      "module": "empirica.api.routes.deltas",
      "params": [
        "session_id"
      ],
      "returns": "",
      "docstring": "Get epistemic changes from PREFLIGHT to POSTFLIGHT.\n\nReturns:\n- Deltas for each epistemic vector\n- Learning velocity (change per minute)\n- Git correlation data",
      "decorators": [],
      "calls": [
        "cursor",
        "route",
        "str",
        "round",
        "error",
        "enumerate",
        "jsonify",
        "float",
        "len",
        "fetchone",
        "SessionDatabase",
        "execute",
        "sum"
      ],
      "line_number": 11
    },
    "empirica.api.routes.deltas.get_commit_epistemic": {
      "name": "get_commit_epistemic",
      "module": "empirica.api.routes.deltas",
      "params": [
        "commit_sha"
      ],
      "returns": "",
      "docstring": "Get epistemic state associated with a specific git commit.\n\nReturns epistemic context (confidence, areas investigated, risk assessment)\nand learning delta at time of commit.",
      "decorators": [],
      "calls": [
        "route",
        "jsonify"
      ],
      "line_number": 122
    },
    "empirica.api.routes.comparison.get_ai_learning_curve": {
      "name": "get_ai_learning_curve",
      "module": "empirica.api.routes.comparison",
      "params": [
        "ai_id"
      ],
      "returns": "",
      "docstring": "Get learning trajectory for a specific AI over time.\n\nReturns:\n- List of sessions with epistemic vectors\n- Learning statistics and trends\n- Learning velocity",
      "decorators": [],
      "calls": [
        "route",
        "int",
        "jsonify",
        "get",
        "min"
      ],
      "line_number": 11
    },
    "empirica.api.routes.comparison.compare_ais": {
      "name": "compare_ais",
      "module": "empirica.api.routes.comparison",
      "params": [],
      "returns": "",
      "docstring": "Compare learning curves across multiple AIs.\n\nQuery Parameters:\n- `ai_ids`: Comma-separated AI identifiers (e.g., \"copilot,gemini,claude\")\n- `since`: Start date for comparison\n- `metric`: Which metric",
      "decorators": [],
      "calls": [
        "route",
        "split",
        "jsonify",
        "strip",
        "get"
      ],
      "line_number": 39
    },
    "empirica.integrations.beads.config.__init__": {
      "name": "__init__",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self",
        "config_path"
      ],
      "returns": "",
      "docstring": "Initialize BEADS configuration\n\nArgs:\n    config_path: Path to config.yaml (default: ./.empirica/config.yaml)",
      "decorators": [],
      "calls": [
        "_load_config",
        "Path"
      ],
      "line_number": 18
    },
    "empirica.integrations.beads.config._load_config": {
      "name": "_load_config",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Load configuration from YAML file",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "debug",
        "exists",
        "get",
        "_default_config",
        "safe_load"
      ],
      "line_number": 30
    },
    "empirica.integrations.beads.config._default_config": {
      "name": "_default_config",
      "module": "empirica.integrations.beads.config",
      "params": [],
      "returns": "Dict[str, Any]",
      "docstring": "Default BEADS configuration",
      "decorators": [
        "staticmethod"
      ],
      "calls": [],
      "line_number": 45
    },
    "empirica.integrations.beads.config.enabled": {
      "name": "enabled",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Is BEADS integration enabled?",
      "decorators": [
        "property"
      ],
      "calls": [
        "get"
      ],
      "line_number": 56
    },
    "empirica.integrations.beads.config.auto_detect": {
      "name": "auto_detect",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Should we auto-detect bd CLI availability?",
      "decorators": [
        "property"
      ],
      "calls": [
        "get"
      ],
      "line_number": 61
    },
    "empirica.integrations.beads.config.use_agent_mail": {
      "name": "use_agent_mail",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Use Agent Mail for multi-AI coordination?",
      "decorators": [
        "property"
      ],
      "calls": [
        "get"
      ],
      "line_number": 66
    },
    "empirica.integrations.beads.config.agent_mail_url": {
      "name": "agent_mail_url",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "str",
      "docstring": "Agent Mail server URL",
      "decorators": [
        "property"
      ],
      "calls": [
        "get"
      ],
      "line_number": 71
    },
    "empirica.integrations.beads.config.agent_name": {
      "name": "agent_name",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "Optional[str]",
      "docstring": "Agent name for Agent Mail",
      "decorators": [
        "property"
      ],
      "calls": [
        "get"
      ],
      "line_number": 76
    },
    "empirica.integrations.beads.config.save": {
      "name": "save",
      "module": "empirica.integrations.beads.config",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Save configuration to YAML file",
      "decorators": [],
      "calls": [
        "open",
        "mkdir",
        "dump",
        "info",
        "exists",
        "safe_load"
      ],
      "line_number": 80
    },
    "empirica.integrations.beads.adapter.__init__": {
      "name": "__init__",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 19
    },
    "empirica.integrations.beads.adapter.is_available": {
      "name": "is_available",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self"
      ],
      "returns": "bool",
      "docstring": "Check if bd CLI is installed and working",
      "decorators": [],
      "calls": [
        "run",
        "strip",
        "debug"
      ],
      "line_number": 22
    },
    "empirica.integrations.beads.adapter.create_issue": {
      "name": "create_issue",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "title",
        "description",
        "priority",
        "issue_type",
        "labels"
      ],
      "returns": "Optional[str]",
      "docstring": "Create BEADS issue, return hash ID (e.g., bd-a1b2)\n\nArgs:\n    title: Issue title (required)\n    description: Issue description (optional)\n    priority: Priority 1-3 (1=high, 2=medium, 3=low)\n    issue",
      "decorators": [],
      "calls": [
        "warning",
        "str",
        "run",
        "error",
        "join",
        "loads",
        "info",
        "is_available",
        "get",
        "extend"
      ],
      "line_number": 43
    },
    "empirica.integrations.beads.adapter.add_dependency": {
      "name": "add_dependency",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "child_id",
        "parent_id",
        "dep_type"
      ],
      "returns": "bool",
      "docstring": "Add dependency between BEADS issues\n\nArgs:\n    child_id: Child issue ID\n    parent_id: Parent issue ID\n    dep_type: Dependency type (blocks, related, discovered-from)\n\nReturns:\n    True if successful",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "is_available",
        "info"
      ],
      "line_number": 97
    },
    "empirica.integrations.beads.adapter.get_ready_work": {
      "name": "get_ready_work",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "limit",
        "priority"
      ],
      "returns": "List[Dict[str, Any]]",
      "docstring": "Get ready work from BEADS (issues with no open blockers)\n\nArgs:\n    limit: Maximum number of issues to return\n    priority: Filter by priority (1, 2, or 3)\n\nReturns:\n    List of issue dicts or empty l",
      "decorators": [],
      "calls": [
        "str",
        "run",
        "debug",
        "error",
        "loads",
        "len",
        "is_available",
        "isinstance",
        "extend"
      ],
      "line_number": 130
    },
    "empirica.integrations.beads.adapter.update_status": {
      "name": "update_status",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "issue_id",
        "status"
      ],
      "returns": "bool",
      "docstring": "Update BEADS issue status\n\nArgs:\n    issue_id: BEADS issue ID\n    status: Status (open, in_progress, blocked, closed)\n\nReturns:\n    True if successful, False otherwise",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "is_available",
        "info"
      ],
      "line_number": 168
    },
    "empirica.integrations.beads.adapter.close_issue": {
      "name": "close_issue",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "issue_id",
        "reason"
      ],
      "returns": "bool",
      "docstring": "Close BEADS issue\n\nArgs:\n    issue_id: BEADS issue ID\n    reason: Close reason (optional)\n\nReturns:\n    True if successful, False otherwise",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "is_available",
        "info"
      ],
      "line_number": 195
    },
    "empirica.integrations.beads.adapter.get_issue": {
      "name": "get_issue",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "issue_id"
      ],
      "returns": "Optional[Dict[str, Any]]",
      "docstring": "Get BEADS issue details\n\nArgs:\n    issue_id: BEADS issue ID\n\nReturns:\n    Issue dict or None if not found/not available",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "is_available",
        "loads"
      ],
      "line_number": 222
    },
    "empirica.integrations.beads.adapter.get_dependency_tree": {
      "name": "get_dependency_tree",
      "module": "empirica.integrations.beads.adapter",
      "params": [
        "self",
        "issue_id"
      ],
      "returns": "Optional[str]",
      "docstring": "Get dependency tree for an issue (ASCII tree output)\n\nArgs:\n    issue_id: BEADS issue ID\n\nReturns:\n    ASCII tree string or None if not available",
      "decorators": [],
      "calls": [
        "run",
        "error",
        "is_available"
      ],
      "line_number": 253
    },
    "empirica.cli.utils.config_validator.validate_config": {
      "name": "validate_config",
      "module": "empirica.cli.utils.config_validator",
      "params": [
        "config_data",
        "schema_name"
      ],
      "returns": "Tuple[bool, Optional[str]]",
      "docstring": "Validate config against JSON schema.\n\nArgs:\n    config_data: Config dictionary to validate\n    schema_name: Schema name (e.g., 'preflight_config', 'check_config')\n\nReturns:\n    (is_valid, error_messag",
      "decorators": [],
      "calls": [
        "open",
        "str",
        "join",
        "split",
        "validate",
        "exists",
        "load",
        "dirname"
      ],
      "line_number": 12
    },
    "empirica.cli.utils.config_validator.print_validation_error": {
      "name": "print_validation_error",
      "module": "empirica.cli.utils.config_validator",
      "params": [
        "error_message",
        "schema_name"
      ],
      "returns": "",
      "docstring": "Print formatted validation error with helpful info.",
      "decorators": [],
      "calls": [
        "dumps",
        "replace",
        "print"
      ],
      "line_number": 71
    },
    "empirica.cli.utils.config_validator.get_schema_name": {
      "name": "get_schema_name",
      "module": "empirica.cli.utils.config_validator",
      "params": [
        "command"
      ],
      "returns": "Optional[str]",
      "docstring": "Get schema name for a command.",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 95
    },
    "empirica.cli.utils.project_resolver.resolve_project_id": {
      "name": "resolve_project_id",
      "module": "empirica.cli.utils.project_resolver",
      "params": [
        "project_id_or_name",
        "db"
      ],
      "returns": "str",
      "docstring": "Resolve project name or UUID to UUID.\n\nArgs:\n    project_id_or_name: Either a project UUID or project name\n    db: Optional SessionDatabase instance (creates one if not provided)\n\nReturns:\n    Project",
      "decorators": [],
      "calls": [
        "resolve_project_id",
        "exit",
        "close",
        "SessionDatabase",
        "print"
      ],
      "line_number": 12
    },
    "empirica.cli.utils.project_resolver.get_project_name": {
      "name": "get_project_name",
      "module": "empirica.cli.utils.project_resolver",
      "params": [
        "project_id",
        "db"
      ],
      "returns": "Optional[str]",
      "docstring": "Get project name from UUID (for display purposes).\n\nArgs:\n    project_id: Project UUID\n    db: Optional SessionDatabase instance\n\nReturns:\n    Project name or None if not found",
      "decorators": [],
      "calls": [
        "get",
        "get_project",
        "SessionDatabase",
        "close"
      ],
      "line_number": 58
    },
    "empirica.cli.command_handlers.cascade_commands.handle_decision_command": {
      "name": "handle_decision_command",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle decision-making command with uncertainty assessment",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "info",
        "run_epistemic_cascade",
        "get",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 22
    },
    "empirica.cli.command_handlers.cascade_commands.handle_preflight_command": {
      "name": "handle_preflight_command",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Execute preflight epistemic assessment before task",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "load_keypair",
        "SessionDatabase",
        "sign_assessment",
        "print",
        "read",
        "create_cascade",
        "open",
        "run",
        "GitEnhancedReflexLogger",
        "hasattr",
        "items",
        "utcnow",
        "isfile",
        "parse_llm_response",
        "strip",
        "_interpret_score",
        "upper",
        "sha256",
        "get",
        "create_session",
        "handle_cli_error",
        "input",
        "isoformat",
        "_get_recommendation",
        "hexdigest",
        "public_key_hex",
        "error",
        "assess",
        "info",
        "append",
        "isinstance",
        "CanonicalEpistemicAssessor",
        "AIIdentity",
        "encode",
        "dumps",
        "print_header",
        "str",
        "debug",
        "auto_checkpoint",
        "join",
        "close",
        "loads",
        "add_checkpoint",
        "uuid4"
      ],
      "line_number": 79
    },
    "empirica.cli.command_handlers.cascade_commands.handle_postflight_command": {
      "name": "handle_postflight_command",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "DEPRECATED: This handler is no longer used.\n\nPostflight is now integrated into the non-blocking MCP v2 workflow.\nUse 'empirica postflight' which calls handle_postflight_submit_command.\n\nThis function ",
      "decorators": [],
      "calls": [
        "print"
      ],
      "line_number": 416
    },
    "empirica.cli.command_handlers.cascade_commands.handle_workflow_command": {
      "name": "handle_workflow_command",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Execute full workflow: preflight \u2192 work \u2192 postflight",
      "decorators": [],
      "calls": [
        "input",
        "handle_cli_error",
        "str",
        "getattr",
        "join",
        "get",
        "_summarize_learning",
        "uuid4",
        "print",
        "print_header"
      ],
      "line_number": 429
    },
    "empirica.cli.command_handlers.cascade_commands._get_cascade_profile_thresholds": {
      "name": "_get_cascade_profile_thresholds",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [],
      "returns": "",
      "docstring": "Get cascade-specific thresholds from investigation profiles",
      "decorators": [],
      "calls": [
        "ProfileLoader",
        "get",
        "getattr",
        "get_profile"
      ],
      "line_number": 509
    },
    "empirica.cli.command_handlers.cascade_commands._interpret_score": {
      "name": "_interpret_score",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "score",
        "category"
      ],
      "returns": "",
      "docstring": "Interpret a vector score with human-friendly description using profile-based thresholds",
      "decorators": [],
      "calls": [
        "_get_cascade_profile_thresholds"
      ],
      "line_number": 535
    },
    "empirica.cli.command_handlers.cascade_commands._get_recommendation": {
      "name": "_get_recommendation",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "vectors"
      ],
      "returns": "",
      "docstring": "Get recommendation based on epistemic vectors.\n\nDelegates to centralized decision_utils.get_recommendation_from_vectors()\nfor single source of truth.",
      "decorators": [],
      "calls": [
        "get_recommendation_from_vectors"
      ],
      "line_number": 553
    },
    "empirica.cli.command_handlers.cascade_commands._calculate_vector_delta": {
      "name": "_calculate_vector_delta",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "preflight",
        "postflight"
      ],
      "returns": "",
      "docstring": "Calculate epistemic delta between preflight and postflight",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 563
    },
    "empirica.cli.command_handlers.cascade_commands._assess_calibration": {
      "name": "_assess_calibration",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "preflight",
        "postflight"
      ],
      "returns": "",
      "docstring": "Assess calibration quality",
      "decorators": [],
      "calls": [
        "get",
        "calc_confidence",
        "round"
      ],
      "line_number": 573
    },
    "empirica.cli.command_handlers.cascade_commands._summarize_learning": {
      "name": "_summarize_learning",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "delta"
      ],
      "returns": "",
      "docstring": "Summarize learning from delta",
      "decorators": [],
      "calls": [
        "append",
        "items"
      ],
      "line_number": 616
    },
    "empirica.cli.command_handlers.cascade_commands._print_vector_with_delta": {
      "name": "_print_vector_with_delta",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "name",
        "value",
        "delta"
      ],
      "returns": "",
      "docstring": "Print vector with delta if available",
      "decorators": [],
      "calls": [
        "_interpret_score",
        "lower",
        "print"
      ],
      "line_number": 633
    },
    "empirica.cli.command_handlers.cascade_commands.calc_confidence": {
      "name": "calc_confidence",
      "module": "empirica.cli.command_handlers.cascade_commands",
      "params": [
        "v"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "get"
      ],
      "line_number": 576
    },
    "empirica.cli.command_handlers.investigation_commands._get_profile_thresholds": {
      "name": "_get_profile_thresholds",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [],
      "returns": "",
      "docstring": "Get thresholds from investigation profiles instead of using hardcoded values",
      "decorators": [],
      "calls": [
        "ProfileLoader",
        "getattr",
        "get_profile"
      ],
      "line_number": 10
    },
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_command": {
      "name": "handle_investigate_command",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle investigation command (consolidates investigate + analyze)",
      "decorators": [],
      "calls": [
        "handle_analyze_command",
        "_investigate_file",
        "items",
        "getattr",
        "isfile",
        "_investigate_directory",
        "exists",
        "_investigate_concept",
        "get",
        "handle_cli_error",
        "print",
        "isdir"
      ],
      "line_number": 44
    },
    "empirica.cli.command_handlers.investigation_commands.handle_analyze_command": {
      "name": "handle_analyze_command",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle comprehensive analysis (called from investigate --type=comprehensive)",
      "decorators": [],
      "calls": [
        "_get_profile_thresholds",
        "items",
        "getattr",
        "isinstance",
        "get",
        "analyze",
        "handle_cli_error",
        "EmpiricalPerformanceAnalyzer",
        "print",
        "parse_json_safely"
      ],
      "line_number": 111
    },
    "empirica.cli.command_handlers.investigation_commands._investigate_file": {
      "name": "_investigate_file",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "file_path",
        "verbose"
      ],
      "returns": "dict",
      "docstring": "Investigate a specific file",
      "decorators": [],
      "calls": [
        "CodeIntelligenceAnalyzer",
        "str",
        "analyze_file",
        "basename",
        "get"
      ],
      "line_number": 165
    },
    "empirica.cli.command_handlers.investigation_commands._investigate_directory": {
      "name": "_investigate_directory",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "dir_path",
        "verbose"
      ],
      "returns": "dict",
      "docstring": "Investigate a directory structure",
      "decorators": [],
      "calls": [
        "str",
        "basename",
        "WorkspaceAwareness",
        "analyze_directory",
        "get"
      ],
      "line_number": 185
    },
    "empirica.cli.command_handlers.investigation_commands._investigate_concept": {
      "name": "_investigate_concept",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "concept",
        "context",
        "verbose"
      ],
      "returns": "dict",
      "docstring": "Investigate a concept or abstract idea",
      "decorators": [],
      "calls": [
        "get",
        "CanonicalEpistemicAssessor",
        "str",
        "parse_json_safely"
      ],
      "line_number": 205
    },
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_create_branch_command": {
      "name": "handle_investigate_create_branch_command",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle investigate-create-branch command - Create parallel investigation path",
      "decorators": [],
      "calls": [
        "hasattr",
        "getattr",
        "close",
        "create_branch",
        "isinstance",
        "SessionDatabase",
        "ValueError",
        "dumps",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 236
    },
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_checkpoint_branch_command": {
      "name": "handle_investigate_checkpoint_branch_command",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle investigate-checkpoint-branch command - Checkpoint branch after investigation",
      "decorators": [],
      "calls": [
        "dumps",
        "int",
        "hasattr",
        "calculate_branch_merge_score",
        "getattr",
        "close",
        "checkpoint_branch",
        "isinstance",
        "SessionDatabase",
        "ValueError",
        "get",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 294
    },
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_merge_branches_command": {
      "name": "handle_investigate_merge_branches_command",
      "module": "empirica.cli.command_handlers.investigation_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle investigate-merge-branches command - Auto-merge best branch based on epistemic scores",
      "decorators": [],
      "calls": [
        "dumps",
        "int",
        "hasattr",
        "merge_branches",
        "getattr",
        "close",
        "len",
        "SessionDatabase",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 354
    },
    "empirica.cli.command_handlers.identity_commands.handle_identity_create_command": {
      "name": "handle_identity_create_command",
      "module": "empirica.cli.command_handlers.identity_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Create new AI identity with Ed25519 keypair",
      "decorators": [],
      "calls": [
        "create_identity",
        "str",
        "hasattr",
        "public_key_hex",
        "getattr",
        "Path",
        "identity_exists",
        "IdentityManager",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 21
    },
    "empirica.cli.command_handlers.identity_commands.handle_identity_list_command": {
      "name": "handle_identity_list_command",
      "module": "empirica.cli.command_handlers.identity_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List all AI identities",
      "decorators": [],
      "calls": [
        "str",
        "hasattr",
        "getattr",
        "enumerate",
        "list_identities",
        "len",
        "IdentityManager",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 87
    },
    "empirica.cli.command_handlers.identity_commands.handle_identity_export_command": {
      "name": "handle_identity_export_command",
      "module": "empirica.cli.command_handlers.identity_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Export public key for sharing",
      "decorators": [],
      "calls": [
        "export_public_key",
        "dumps",
        "str",
        "hasattr",
        "items",
        "getattr",
        "load_identity",
        "IdentityManager",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 135
    },
    "empirica.cli.command_handlers.identity_commands.handle_identity_verify_command": {
      "name": "handle_identity_verify_command",
      "module": "empirica.cli.command_handlers.identity_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Verify signed session",
      "decorators": [],
      "calls": [
        "get_session",
        "str",
        "hasattr",
        "getattr",
        "close",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 194
    },
    "empirica.cli.command_handlers.workflow_commands.handle_preflight_submit_command": {
      "name": "handle_preflight_submit_command",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle preflight-submit command - AI-first with config file support",
      "decorators": [],
      "calls": [
        "getattr",
        "SessionDatabase",
        "execute",
        "print",
        "read",
        "open",
        "hasattr",
        "GitEnhancedReflexLogger",
        "len",
        "get",
        "handle_cli_error",
        "error",
        "commit",
        "isinstance",
        "time",
        "dumps",
        "str",
        "exit",
        "close",
        "add_checkpoint",
        "exists",
        "ValueError",
        "_extract_all_vectors",
        "uuid4",
        "parse_json_safely"
      ],
      "line_number": 20
    },
    "empirica.cli.command_handlers.workflow_commands.handle_check_command": {
      "name": "handle_check_command",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle check command - AI-first with config file support",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "print",
        "read",
        "open",
        "hasattr",
        "GitEnhancedReflexLogger",
        "len",
        "upper",
        "get",
        "isinstance",
        "dumps",
        "time",
        "str",
        "calculate_decision",
        "exit",
        "type",
        "add_checkpoint",
        "exists",
        "ValueError",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 163
    },
    "empirica.cli.command_handlers.workflow_commands.handle_check_submit_command": {
      "name": "handle_check_submit_command",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle check-submit command",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "print",
        "hasattr",
        "GitEnhancedReflexLogger",
        "items",
        "run",
        "len",
        "upper",
        "get",
        "error",
        "append",
        "isinstance",
        "dumps",
        "str",
        "add_checkpoint",
        "ValueError",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 341
    },
    "empirica.cli.command_handlers.workflow_commands._extract_numeric_value": {
      "name": "_extract_numeric_value",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "value"
      ],
      "returns": "",
      "docstring": "Extract numeric value from vector data.\n\nHandles multiple formats:\n- Simple float: 0.85\n- Nested dict: {\"score\": 0.85, \"rationale\": \"...\", \"evidence\": \"...\"}\n- String numbers: \"0.85\"\n\nReturns:\n    flo",
      "decorators": [],
      "calls": [
        "isdigit",
        "items",
        "values",
        "float",
        "replace",
        "isinstance"
      ],
      "line_number": 487
    },
    "empirica.cli.command_handlers.workflow_commands._extract_all_vectors": {
      "name": "_extract_all_vectors",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "vectors"
      ],
      "returns": "",
      "docstring": "Extract all numeric values from vectors dict, handling nested structures.\n\nArgs:\n    vectors: Dict containing vector data (simple or nested)\n\nReturns:\n    Dict with all vector names mapped to numeric ",
      "decorators": [],
      "calls": [
        "_extract_numeric_value",
        "items"
      ],
      "line_number": 530
    },
    "empirica.cli.command_handlers.workflow_commands.handle_postflight_submit_command": {
      "name": "handle_postflight_submit_command",
      "module": "empirica.cli.command_handlers.workflow_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle postflight-submit command - AI-first with config file support",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "enumerate",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "read",
        "open",
        "hasattr",
        "GitEnhancedReflexLogger",
        "run",
        "len",
        "get",
        "bootstrap_project_breadcrumbs",
        "error",
        "append",
        "isinstance",
        "dumps",
        "get_last_checkpoint",
        "abs",
        "cursor",
        "str",
        "round",
        "exit",
        "debug",
        "close",
        "add_checkpoint",
        "compute_doc_plan",
        "exists",
        "ValueError",
        "_extract_all_vectors",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 552
    },
    "empirica.cli.command_handlers.goals_ready_command.handle_goals_ready_command": {
      "name": "handle_goals_ready_command",
      "module": "empirica.cli.command_handlers.goals_ready_command",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Query BEADS ready work + filter by Empirica epistemic criteria\n\nReturns tasks that are:\n1. Dependency-ready (BEADS: no open blockers)\n2. Epistemically-ready (Empirica: confidence/uncertainty threshold",
      "decorators": [],
      "calls": [
        "BeadsAdapter",
        "dumps",
        "str",
        "getattr",
        "error",
        "close",
        "append",
        "loads",
        "get_ready_work",
        "len",
        "is_available",
        "fetchone",
        "SessionDatabase",
        "get",
        "execute",
        "print"
      ],
      "line_number": 15
    },
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_command": {
      "name": "handle_monitor_command",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Unified monitor handler (consolidates all 4 monitor commands).\n\nShows current usage statistics with optional live updates.",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "UsageMonitor",
        "print",
        "get_adapter_costs",
        "items",
        "get_config",
        "handle_monitor_export_command",
        "len",
        "upper",
        "get",
        "reversed",
        "info",
        "handle_monitor_reset_command",
        "health_check_all",
        "handle_monitor_cost_command",
        "debug",
        "get_registry",
        "get_stats",
        "handle_cli_error"
      ],
      "line_number": 148
    },
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_export_command": {
      "name": "handle_monitor_export_command",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Export monitoring data to file.\n\nSupports JSON and CSV formats.",
      "decorators": [],
      "calls": [
        "open",
        "writerow",
        "writeheader",
        "getattr",
        "dump",
        "UsageMonitor",
        "DictWriter",
        "len",
        "get_stats",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 257
    },
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_reset_command": {
      "name": "handle_monitor_reset_command",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Reset monitoring statistics.\n\nClears all recorded data.",
      "decorators": [],
      "calls": [
        "handle_cli_error",
        "input",
        "getattr",
        "reset_stats",
        "UsageMonitor",
        "strip",
        "lower",
        "print"
      ],
      "line_number": 307
    },
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_cost_command": {
      "name": "handle_monitor_cost_command",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Display cost analysis.\n\nShows detailed cost breakdown by adapter and time period.",
      "decorators": [],
      "calls": [
        "items",
        "sorted",
        "getattr",
        "UsageMonitor",
        "upper",
        "get_stats",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 335
    },
    "empirica.cli.command_handlers.monitor_commands.handle_check_drift_command": {
      "name": "handle_check_drift_command",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Check for epistemic drift by comparing current state to historical baselines.\n\nUses MirrorDriftMonitor to detect unexpected drops in epistemic vectors\nthat indicate memory corruption, context loss, or",
      "decorators": [],
      "calls": [
        "setattr",
        "dumps",
        "items",
        "type",
        "getattr",
        "MockAssessment",
        "load_recent_checkpoints",
        "replace",
        "CheckpointManager",
        "detect_drift",
        "MirrorDriftMonitor",
        "upper",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 393
    },
    "empirica.cli.command_handlers.monitor_commands.__init__": {
      "name": "__init__",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self",
        "vectors"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "items",
        "setattr",
        "type"
      ],
      "line_number": 429
    },
    "empirica.cli.command_handlers.monitor_commands._load_stats": {
      "name": "_load_stats",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Load existing stats or create new.",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "isoformat",
        "now",
        "exists",
        "load"
      ],
      "line_number": 54
    },
    "empirica.cli.command_handlers.monitor_commands._save_stats": {
      "name": "_save_stats",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Save stats to file.",
      "decorators": [],
      "calls": [
        "open",
        "dump"
      ],
      "line_number": 78
    },
    "empirica.cli.command_handlers.monitor_commands.record_request": {
      "name": "record_request",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self",
        "adapter",
        "success",
        "tokens",
        "cost",
        "latency"
      ],
      "returns": "",
      "docstring": "Record a request.",
      "decorators": [],
      "calls": [
        "warning",
        "debug",
        "isoformat",
        "append",
        "now",
        "len",
        "_save_stats"
      ],
      "line_number": 83
    },
    "empirica.cli.command_handlers.monitor_commands.get_stats": {
      "name": "get_stats",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self"
      ],
      "returns": "Dict[str, Any]",
      "docstring": "Get current statistics.",
      "decorators": [],
      "calls": [],
      "line_number": 126
    },
    "empirica.cli.command_handlers.monitor_commands.reset_stats": {
      "name": "reset_stats",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "Reset all statistics.",
      "decorators": [],
      "calls": [
        "isoformat",
        "now",
        "_save_stats",
        "info"
      ],
      "line_number": 130
    },
    "empirica.cli.command_handlers.project_commands.handle_project_create_command": {
      "name": "handle_project_create_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle project-create command",
      "decorators": [],
      "calls": [
        "hasattr",
        "create_project",
        "getattr",
        "join",
        "loads",
        "close",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 14
    },
    "empirica.cli.command_handlers.project_commands.handle_project_handoff_command": {
      "name": "handle_project_handoff_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle project-handoff command",
      "decorators": [],
      "calls": [
        "hasattr",
        "items",
        "getattr",
        "create_project_handoff",
        "close",
        "loads",
        "aggregate_project_learning_deltas",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 64
    },
    "empirica.cli.command_handlers.project_commands.handle_project_list_command": {
      "name": "handle_project_list_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle project-list command",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "dict",
        "hasattr",
        "getattr",
        "enumerate",
        "close",
        "len",
        "SessionDatabase",
        "dumps",
        "execute",
        "handle_cli_error",
        "print"
      ],
      "line_number": 123
    },
    "empirica.cli.command_handlers.project_commands.handle_project_bootstrap_command": {
      "name": "handle_project_bootstrap_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle project-bootstrap command - show epistemic breadcrumbs",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "get_current_subject",
        "SessionDatabase",
        "print",
        "title",
        "hasattr",
        "len",
        "upper",
        "get",
        "bootstrap_project_breadcrumbs",
        "detect_gaps",
        "append",
        "replace",
        "dumps",
        "get_latest_vectors",
        "MemoryGapDetector",
        "join",
        "close",
        "loads",
        "handle_cli_error"
      ],
      "line_number": 167
    },
    "empirica.cli.command_handlers.project_commands.handle_finding_log_command": {
      "name": "handle_finding_log_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle finding-log command - AI-first with config file support",
      "decorators": [],
      "calls": [
        "read",
        "open",
        "dumps",
        "resolve_project_id",
        "hasattr",
        "exit",
        "log_finding",
        "getattr",
        "close",
        "get_current_subject",
        "exists",
        "SessionDatabase",
        "get",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 469
    },
    "empirica.cli.command_handlers.project_commands.handle_unknown_log_command": {
      "name": "handle_unknown_log_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle unknown-log command",
      "decorators": [],
      "calls": [
        "resolve_project_id",
        "log_unknown",
        "hasattr",
        "getattr",
        "close",
        "get_current_subject",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 570
    },
    "empirica.cli.command_handlers.project_commands.handle_deadend_log_command": {
      "name": "handle_deadend_log_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle deadend-log command",
      "decorators": [],
      "calls": [
        "log_dead_end",
        "resolve_project_id",
        "hasattr",
        "getattr",
        "close",
        "get_current_subject",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 622
    },
    "empirica.cli.command_handlers.project_commands.handle_refdoc_add_command": {
      "name": "handle_refdoc_add_command",
      "module": "empirica.cli.command_handlers.project_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle refdoc-add command",
      "decorators": [],
      "calls": [
        "resolve_project_id",
        "hasattr",
        "getattr",
        "close",
        "SessionDatabase",
        "dumps",
        "add_reference_doc",
        "handle_cli_error",
        "print"
      ],
      "line_number": 676
    },
    "empirica.cli.command_handlers.component_commands.handle_list_command": {
      "name": "handle_list_command",
      "module": "empirica.cli.command_handlers.component_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle list components command",
      "decorators": [],
      "calls": [
        "get_components",
        "items",
        "getattr",
        "sorted",
        "append",
        "get_component_registry",
        "len",
        "format_component_list",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 9
    },
    "empirica.cli.command_handlers.component_commands.handle_explain_command": {
      "name": "handle_explain_command",
      "module": "empirica.cli.command_handlers.component_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle explain component command",
      "decorators": [],
      "calls": [
        "handle_cli_error",
        "getattr",
        "get_component_registry",
        "get_component",
        "get",
        "find_similar_components",
        "print"
      ],
      "line_number": 71
    },
    "empirica.cli.command_handlers.component_commands.handle_demo_command": {
      "name": "handle_demo_command",
      "module": "empirica.cli.command_handlers.component_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle demo component command",
      "decorators": [],
      "calls": [
        "handle_cli_error",
        "getattr",
        "enumerate",
        "choice",
        "run_component_demo",
        "get_component_registry",
        "get_component",
        "get",
        "get_working_components",
        "print"
      ],
      "line_number": 139
    },
    "empirica.cli.command_handlers.goal_discovery_commands.handle_goals_discover_command": {
      "name": "handle_goals_discover_command",
      "module": "empirica.cli.command_handlers.goal_discovery_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Discover goals from other AIs via git notes",
      "decorators": [],
      "calls": [
        "discover_goals",
        "str",
        "hasattr",
        "getattr",
        "enumerate",
        "GitGoalStore",
        "len",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 18
    },
    "empirica.cli.command_handlers.goal_discovery_commands.handle_goals_resume_command": {
      "name": "handle_goals_resume_command",
      "module": "empirica.cli.command_handlers.goal_discovery_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Resume another AI's goal with epistemic handoff",
      "decorators": [],
      "calls": [
        "GoalRepository",
        "dumps",
        "str",
        "add_lineage",
        "load_goal",
        "hasattr",
        "items",
        "getattr",
        "close",
        "GitGoalStore",
        "isinstance",
        "upper",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 83
    },
    "empirica.cli.command_handlers.skill_commands._load_skill_sources": {
      "name": "_load_skill_sources",
      "module": "empirica.cli.command_handlers.skill_commands",
      "params": [
        "root"
      ],
      "returns": "List[Dict]",
      "docstring": "",
      "decorators": [],
      "calls": [
        "open",
        "join",
        "exists",
        "get",
        "safe_load"
      ],
      "line_number": 14
    },
    "empirica.cli.command_handlers.skill_commands.handle_skill_suggest_command": {
      "name": "handle_skill_suggest_command",
      "module": "empirica.cli.command_handlers.skill_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "listdir",
        "open",
        "getcwd",
        "safe_load",
        "get",
        "getattr",
        "join",
        "_load_skill_sources",
        "append",
        "replace",
        "exists",
        "endswith",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 24
    },
    "empirica.cli.command_handlers.skill_commands.handle_skill_fetch_command": {
      "name": "handle_skill_fetch_command",
      "module": "empirica.cli.command_handlers.skill_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "ZipFile",
        "namelist",
        "parse_markdown_to_skill",
        "getcwd",
        "FileNotFoundError",
        "getattr",
        "_save_skill",
        "print",
        "read",
        "open",
        "strip",
        "get",
        "lower",
        "replace",
        "endswith",
        "decode",
        "dumps",
        "raise_for_status",
        "makedirs",
        "join",
        "split",
        "safe_dump",
        "loads",
        "exists",
        "ValueError",
        "handle_cli_error",
        "safe_load"
      ],
      "line_number": 69
    },
    "empirica.cli.command_handlers.skill_commands._save_skill": {
      "name": "_save_skill",
      "module": "empirica.cli.command_handlers.skill_commands",
      "params": [
        "skill_obj"
      ],
      "returns": "dict",
      "docstring": "",
      "decorators": [],
      "calls": [
        "open",
        "getcwd",
        "makedirs",
        "join",
        "safe_dump"
      ],
      "line_number": 81
    },
    "empirica.cli.command_handlers.onboard_handler.handle_onboard_command": {
      "name": "handle_onboard_command",
      "module": "empirica.cli.command_handlers.onboard_handler",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle 'empirica onboard' command for first-time AI setup.\n\nRuns interactive onboarding wizard that teaches:\n- 4 core epistemic vectors (KNOW, DO, CONTEXT, UNCERTAINTY)\n- 7-phase cascade workflow\n- Ca",
      "decorators": [],
      "calls": [
        "EmpericaOnboardingWizard",
        "run",
        "exit",
        "getattr",
        "run_interactive",
        "handle_cli_error",
        "print"
      ],
      "line_number": 14
    },
    "empirica.cli.command_handlers.onboard_handler.check_if_onboarded": {
      "name": "check_if_onboarded",
      "module": "empirica.cli.command_handlers.onboard_handler",
      "params": [
        "ai_id"
      ],
      "returns": "bool",
      "docstring": "Check if AI has completed onboarding.\n\nArgs:\n    ai_id: AI identifier\n\nReturns:\n    True if onboarding session exists, False otherwise",
      "decorators": [],
      "calls": [
        "list",
        "glob",
        "len",
        "exists",
        "home"
      ],
      "line_number": 68
    },
    "empirica.cli.command_handlers.onboard_handler.get_onboarding_status": {
      "name": "get_onboarding_status",
      "module": "empirica.cli.command_handlers.onboard_handler",
      "params": [
        "ai_id"
      ],
      "returns": "dict",
      "docstring": "Get onboarding status for an AI.\n\nArgs:\n    ai_id: AI identifier\n\nReturns:\n    Dict with onboarding status info",
      "decorators": [],
      "calls": [
        "open",
        "glob",
        "str",
        "sorted",
        "len",
        "exists",
        "load",
        "home",
        "get"
      ],
      "line_number": 89
    },
    "empirica.cli.command_handlers.session_commands.handle_sessions_list_command": {
      "name": "handle_sessions_list_command",
      "module": "empirica.cli.command_handlers.session_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List all sessions with summary information",
      "decorators": [],
      "calls": [
        "getattr",
        "strftime",
        "SessionDatabase",
        "execute",
        "print",
        "fetchall",
        "hasattr",
        "len",
        "format_timestamp",
        "fromtimestamp",
        "fromisoformat",
        "info",
        "append",
        "isinstance",
        "dumps",
        "print_header",
        "cursor",
        "str",
        "close",
        "bool",
        "handle_cli_error"
      ],
      "line_number": 19
    },
    "empirica.cli.command_handlers.session_commands.handle_sessions_show_command": {
      "name": "handle_sessions_show_command",
      "module": "empirica.cli.command_handlers.session_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Show detailed session information including epistemic vectors",
      "decorators": [],
      "calls": [
        "abs",
        "warning",
        "str",
        "items",
        "getattr",
        "enumerate",
        "sorted",
        "close",
        "resolve_session_id",
        "isinstance",
        "get_session_summary",
        "SessionDatabase",
        "get",
        "upper",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 132
    },
    "empirica.cli.command_handlers.session_commands.handle_session_snapshot_command": {
      "name": "handle_session_snapshot_command",
      "module": "empirica.cli.command_handlers.session_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle session-snapshot command - show where you left off",
      "decorators": [],
      "calls": [
        "abs",
        "dumps",
        "get_session_snapshot",
        "items",
        "sorted",
        "close",
        "len",
        "resolve_session_id",
        "SessionDatabase",
        "get",
        "print"
      ],
      "line_number": 279
    },
    "empirica.cli.command_handlers.session_commands.handle_sessions_export_command": {
      "name": "handle_sessions_export_command",
      "module": "empirica.cli.command_handlers.session_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Export session data to JSON file",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "dumps",
        "str",
        "getattr",
        "dump",
        "info",
        "close",
        "len",
        "resolve_session_id",
        "get_session_summary",
        "SessionDatabase",
        "get",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 356
    },
    "empirica.cli.command_handlers.session_commands.format_timestamp": {
      "name": "format_timestamp",
      "module": "empirica.cli.command_handlers.session_commands",
      "params": [
        "ts"
      ],
      "returns": "",
      "docstring": "Format timestamp handling str, datetime, or numeric timestamp",
      "decorators": [],
      "calls": [
        "str",
        "hasattr",
        "strftime",
        "isinstance",
        "fromtimestamp",
        "fromisoformat"
      ],
      "line_number": 80
    },
    "empirica.cli.command_handlers.utility_commands._get_utility_profile_thresholds": {
      "name": "_get_utility_profile_thresholds",
      "module": "empirica.cli.command_handlers.utility_commands",
      "params": [],
      "returns": "",
      "docstring": "Get utility command thresholds from investigation profiles",
      "decorators": [],
      "calls": [
        "ProfileLoader",
        "getattr",
        "get_profile"
      ],
      "line_number": 14
    },
    "empirica.cli.command_handlers.utility_commands.handle_goal_analysis_command": {
      "name": "handle_goal_analysis_command",
      "module": "empirica.cli.command_handlers.utility_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goal analysis command",
      "decorators": [],
      "calls": [
        "items",
        "getattr",
        "info",
        "_get_utility_profile_thresholds",
        "run_epistemic_cascade",
        "get",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 47
    },
    "empirica.cli.command_handlers.utility_commands.handle_sessions_list_command": {
      "name": "handle_sessions_list_command",
      "module": "empirica.cli.command_handlers.utility_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List all sessions",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "getattr",
        "strftime",
        "close",
        "len",
        "SessionDatabase",
        "dumps",
        "execute",
        "total_seconds",
        "handle_cli_error",
        "print",
        "print_header",
        "fromisoformat"
      ],
      "line_number": 85
    },
    "empirica.cli.command_handlers.utility_commands.handle_sessions_show_command": {
      "name": "handle_sessions_show_command",
      "module": "empirica.cli.command_handlers.utility_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Show detailed session information",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "strftime",
        "fetchone",
        "SessionDatabase",
        "execute",
        "total_seconds",
        "print",
        "fetchall",
        "items",
        "len",
        "get",
        "fromisoformat",
        "isinstance",
        "dumps",
        "print_header",
        "cursor",
        "close",
        "loads",
        "handle_cli_error"
      ],
      "line_number": 187
    },
    "empirica.cli.command_handlers.utility_commands.handle_sessions_export_command": {
      "name": "handle_sessions_export_command",
      "module": "empirica.cli.command_handlers.utility_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Export session to JSON file",
      "decorators": [],
      "calls": [
        "absolute",
        "getattr",
        "dump",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "fetchall",
        "open",
        "Path",
        "len",
        "stat",
        "lower",
        "append",
        "print_header",
        "cursor",
        "close",
        "loads",
        "handle_cli_error"
      ],
      "line_number": 339
    },
    "empirica.cli.command_handlers.mistake_commands.handle_mistake_log_command": {
      "name": "handle_mistake_log_command",
      "module": "empirica.cli.command_handlers.mistake_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle mistake-log command",
      "decorators": [],
      "calls": [
        "hasattr",
        "log_mistake",
        "getattr",
        "close",
        "SessionDatabase",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 13
    },
    "empirica.cli.command_handlers.mistake_commands.handle_mistake_query_command": {
      "name": "handle_mistake_query_command",
      "module": "empirica.cli.command_handlers.mistake_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle mistake-query command",
      "decorators": [],
      "calls": [
        "handle_cli_error",
        "hasattr",
        "getattr",
        "enumerate",
        "close",
        "len",
        "SessionDatabase",
        "dumps",
        "get_mistakes",
        "print"
      ],
      "line_number": 65
    },
    "empirica.cli.command_handlers.modality_commands.handle_modality_route_command": {
      "name": "handle_modality_route_command",
      "module": "empirica.cli.command_handlers.modality_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle modality routing command - routes to optimal LLM adapter (EXPERIMENTAL)",
      "decorators": [],
      "calls": [
        "get_usage_stats",
        "warning",
        "input",
        "hasattr",
        "items",
        "route_request",
        "RoutingPreferences",
        "getattr",
        "error",
        "update",
        "info",
        "float",
        "len",
        "execute_with_routing",
        "ModalitySwitcher",
        "handle_cli_error",
        "lower",
        "parse_json_safely"
      ],
      "line_number": 15
    },
    "empirica.cli.command_handlers.modality_commands.handle_decision_command": {
      "name": "handle_decision_command",
      "module": "empirica.cli.command_handlers.modality_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle decision-making command with uncertainty assessment (EXPERIMENTAL)",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "enumerate",
        "info",
        "run_epistemic_cascade",
        "get",
        "handle_cli_error",
        "print",
        "parse_json_safely"
      ],
      "line_number": 177
    },
    "empirica.cli.command_handlers.onboard.handle_onboard_command": {
      "name": "handle_onboard_command",
      "module": "empirica.cli.command_handlers.onboard",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Interactive onboarding wizard for new users",
      "decorators": [],
      "calls": [
        "exit",
        "handle_cli_error",
        "getattr",
        "print"
      ],
      "line_number": 12
    },
    "empirica.cli.command_handlers.goal_claim_command.handle_goals_claim_command": {
      "name": "handle_goals_claim_command",
      "module": "empirica.cli.command_handlers.goal_claim_command",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-claim command - Claim goal and create git branch",
      "decorators": [],
      "calls": [
        "get_by_id",
        "warning",
        "get_branch_mapping",
        "getattr",
        "fetchone",
        "SessionDatabase",
        "handle_preflight_command",
        "execute",
        "print",
        "GoalRepository",
        "update_status",
        "run",
        "get",
        "MockArgs",
        "dumps",
        "add_mapping",
        "BeadsAdapter",
        "str",
        "exit",
        "close",
        "is_available",
        "handle_cli_error"
      ],
      "line_number": 18
    },
    "empirica.cli.command_handlers.goal_claim_command.__init__": {
      "name": "__init__",
      "module": "empirica.cli.command_handlers.goal_claim_command",
      "params": [
        "self",
        "session_id",
        "prompt"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 145
    },
    "empirica.cli.command_handlers.config_commands.handle_config_command": {
      "name": "handle_config_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Unified config handler (consolidates all 5 config commands)",
      "decorators": [],
      "calls": [
        "handle_config_set_command",
        "getattr",
        "handle_config_init_command",
        "handle_config_get_command",
        "handle_config_show_command",
        "handle_config_validate_command"
      ],
      "line_number": 15
    },
    "empirica.cli.command_handlers.config_commands.handle_config_init_command": {
      "name": "handle_config_init_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Initialize Empirica configuration.\n\nCreates user config file at ~/.empirica/config.yaml with default values.",
      "decorators": [],
      "calls": [
        "to_dict",
        "save_user_config",
        "ConfigLoader",
        "getattr",
        "exists",
        "home",
        "handle_cli_error",
        "print"
      ],
      "line_number": 33
    },
    "empirica.cli.command_handlers.config_commands.handle_config_show_command": {
      "name": "handle_config_show_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Show current Empirica configuration.\n\nDisplays merged configuration from all sources with priority.",
      "decorators": [],
      "calls": [
        "dumps",
        "to_dict",
        "getattr",
        "dump",
        "get_config",
        "exists",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 70
    },
    "empirica.cli.command_handlers.config_commands.handle_config_validate_command": {
      "name": "handle_config_validate_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Validate Empirica configuration.\n\nChecks for errors and warns about potential issues.",
      "decorators": [],
      "calls": [
        "getenv",
        "items",
        "getattr",
        "Path",
        "get_config",
        "append",
        "get_routing_config",
        "len",
        "exists",
        "expanduser",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 121
    },
    "empirica.cli.command_handlers.config_commands.handle_config_get_command": {
      "name": "handle_config_get_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Get a specific configuration value.\n\nUses dot notation to access nested values.",
      "decorators": [],
      "calls": [
        "getattr",
        "get_config",
        "get",
        "handle_cli_error",
        "print"
      ],
      "line_number": 207
    },
    "empirica.cli.command_handlers.config_commands.handle_config_set_command": {
      "name": "handle_config_set_command",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Set a configuration value in user config.\n\nNote: Only updates user config file, not environment or project config.",
      "decorators": [],
      "calls": [
        "open",
        "save_user_config",
        "safe_load",
        "ConfigLoader",
        "split",
        "getattr",
        "_parse_value",
        "exists",
        "home",
        "handle_cli_error",
        "print"
      ],
      "line_number": 229
    },
    "empirica.cli.command_handlers.config_commands._parse_value": {
      "name": "_parse_value",
      "module": "empirica.cli.command_handlers.config_commands",
      "params": [
        "value"
      ],
      "returns": "Any",
      "docstring": "Parse string value to appropriate type.",
      "decorators": [],
      "calls": [
        "float",
        "lower",
        "int",
        "loads"
      ],
      "line_number": 280
    },
    "empirica.cli.command_handlers.handoff_commands.handle_handoff_create_command": {
      "name": "handle_handoff_create_command",
      "module": "empirica.cli.command_handlers.handoff_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle handoff-create command\n\nSupports two modes:\n1. Epistemic handoff (requires PREFLIGHT/POSTFLIGHT assessments)\n2. Planning handoff (documentation-only, no CASCADE workflow needed)",
      "decorators": [],
      "calls": [
        "warning",
        "getattr",
        "SessionDatabase",
        "get_preflight_assessment",
        "print",
        "EpistemicHandoffReportGenerator",
        "hasattr",
        "len",
        "get",
        "generate_planning_handoff",
        "isinstance",
        "dumps",
        "HybridHandoffStorage",
        "get_postflight_assessment",
        "get_check_phase_assessments",
        "generate_handoff_report",
        "loads",
        "store_handoff",
        "handle_cli_error"
      ],
      "line_number": 15
    },
    "empirica.cli.command_handlers.handoff_commands.handle_handoff_query_command": {
      "name": "handle_handoff_query_command",
      "module": "empirica.cli.command_handlers.handoff_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle handoff-query command",
      "decorators": [],
      "calls": [
        "hasattr",
        "get",
        "getattr",
        "enumerate",
        "query_handoffs",
        "load_handoff",
        "len",
        "dumps",
        "handle_cli_error",
        "print",
        "HybridHandoffStorage"
      ],
      "line_number": 211
    },
    "empirica.cli.command_handlers.action_commands.handle_investigate_log_command": {
      "name": "handle_investigate_log_command",
      "module": "empirica.cli.command_handlers.action_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Log investigation findings during INVESTIGATE phase\n\nStorage: SQLite (cascade context_json) + Git notes (optional)",
      "decorators": [],
      "calls": [
        "getattr",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "run",
        "hasattr",
        "utcnow",
        "len",
        "list",
        "keys",
        "isoformat",
        "append",
        "commit",
        "setdefault",
        "isinstance",
        "dumps",
        "cursor",
        "debug",
        "close",
        "loads",
        "ValueError",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 18
    },
    "empirica.cli.command_handlers.action_commands.handle_act_log_command": {
      "name": "handle_act_log_command",
      "module": "empirica.cli.command_handlers.action_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Log actions taken during ACT phase\n\nStorage: SQLite (cascade context_json + final_action) + Git notes (optional)",
      "decorators": [],
      "calls": [
        "getattr",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "run",
        "hasattr",
        "utcnow",
        "len",
        "isoformat",
        "append",
        "commit",
        "setdefault",
        "isinstance",
        "dumps",
        "cursor",
        "debug",
        "join",
        "close",
        "loads",
        "ValueError",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 100
    },
    "empirica.cli.command_handlers.ask_handler.handle_ask_command": {
      "name": "handle_ask_command",
      "module": "empirica.cli.command_handlers.ask_handler",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle 'empirica ask' command for human users.\n\nSimple query interface that routes through modality switcher to appropriate AI model.\nOptionally tracks conversation in session for history.",
      "decorators": [],
      "calls": [
        "str",
        "uuid4",
        "hasattr",
        "RoutingPreferences",
        "get",
        "exit",
        "getattr",
        "split",
        "strip",
        "SessionDatabase",
        "execute_with_routing",
        "ModalitySwitcher",
        "handle_cli_error",
        "print"
      ],
      "line_number": 16
    },
    "empirica.cli.command_handlers.ask_handler._format_response": {
      "name": "_format_response",
      "module": "empirica.cli.command_handlers.ask_handler",
      "params": [
        "content",
        "max_width"
      ],
      "returns": "str",
      "docstring": "Format response for terminal display",
      "decorators": [],
      "calls": [],
      "line_number": 114
    },
    "empirica.cli.command_handlers.checkpoint_commands._get_checkpoint_profile_thresholds": {
      "name": "_get_checkpoint_profile_thresholds",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [],
      "returns": "",
      "docstring": "Get checkpoint display and diff thresholds from investigation profiles",
      "decorators": [],
      "calls": [
        "ProfileLoader",
        "getattr",
        "get_profile"
      ],
      "line_number": 17
    },
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_create_command": {
      "name": "handle_checkpoint_create_command",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Create git checkpoint for session\n\nUsage:\n    empirica checkpoint-create --session-id abc123 --phase PREFLIGHT --round 1",
      "decorators": [],
      "calls": [
        "warning",
        "print_exc",
        "hasattr",
        "GitEnhancedReflexLogger",
        "exit",
        "error",
        "info",
        "close",
        "loads",
        "add_checkpoint",
        "len",
        "SessionDatabase",
        "print",
        "get_latest_vectors"
      ],
      "line_number": 56
    },
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_load_command": {
      "name": "handle_checkpoint_load_command",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Load latest checkpoint for session\n\nUsage:\n    empirica checkpoint-load --session-id abc123\n    empirica checkpoint-load --session-id abc123 --phase PREFLIGHT",
      "decorators": [],
      "calls": [
        "dumps",
        "print_exc",
        "_get_checkpoint_profile_thresholds",
        "hasattr",
        "GitEnhancedReflexLogger",
        "exit",
        "items",
        "getattr",
        "sorted",
        "error",
        "info",
        "print",
        "get",
        "get_last_checkpoint"
      ],
      "line_number": 129
    },
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_list_command": {
      "name": "handle_checkpoint_list_command",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List checkpoints for session\n\nUsage:\n    empirica checkpoint-list --session-id abc123\n    empirica checkpoint-list --session-id abc123 --limit 5\n    empirica checkpoint-list --session-id abc123 --outp",
      "decorators": [],
      "calls": [
        "print_exc",
        "str",
        "list_checkpoints",
        "hasattr",
        "GitEnhancedReflexLogger",
        "exit",
        "get",
        "getattr",
        "error",
        "enumerate",
        "info",
        "len",
        "dumps",
        "print"
      ],
      "line_number": 213
    },
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_diff_command": {
      "name": "handle_checkpoint_diff_command",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Show vector differences from last checkpoint\n\nUsage:\n    empirica checkpoint-diff --session-id abc123\n    empirica checkpoint-diff --session-id abc123 --threshold 0.15",
      "decorators": [],
      "calls": [
        "dumps",
        "_get_checkpoint_profile_thresholds",
        "print_exc",
        "hasattr",
        "GitEnhancedReflexLogger",
        "items",
        "exit",
        "getattr",
        "get_last_checkpoint",
        "info",
        "show_tier",
        "get",
        "print"
      ],
      "line_number": 288
    },
    "empirica.cli.command_handlers.checkpoint_commands.handle_efficiency_report_command": {
      "name": "handle_efficiency_report_command",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Generate token efficiency report\n\nUsage:\n    empirica efficiency-report --session-id abc123\n    empirica efficiency-report --session-id abc123 --format json\n    empirica efficiency-report --session-id",
      "decorators": [],
      "calls": [
        "print_exc",
        "hasattr",
        "exit",
        "export_report",
        "TokenEfficiencyMetrics",
        "compare_efficiency",
        "get",
        "print"
      ],
      "line_number": 369
    },
    "empirica.cli.command_handlers.checkpoint_commands.show_tier": {
      "name": "show_tier",
      "module": "empirica.cli.command_handlers.checkpoint_commands",
      "params": [
        "name",
        "tier_vectors"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "items",
        "_get_checkpoint_profile_thresholds",
        "print"
      ],
      "line_number": 343
    },
    "empirica.cli.command_handlers.project_search.handle_project_search_command": {
      "name": "handle_project_search_command",
      "module": "empirica.cli.command_handlers.project_search",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "init_collections",
        "search",
        "get",
        "getattr",
        "enumerate",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 12
    },
    "empirica.cli.command_handlers.performance_commands._get_profile_performance_thresholds": {
      "name": "_get_profile_performance_thresholds",
      "module": "empirica.cli.command_handlers.performance_commands",
      "params": [],
      "returns": "",
      "docstring": "Get performance thresholds from investigation profiles",
      "decorators": [],
      "calls": [
        "ProfileLoader",
        "getattr",
        "get_profile"
      ],
      "line_number": 10
    },
    "empirica.cli.command_handlers.performance_commands.handle_benchmark_command": {
      "name": "handle_benchmark_command",
      "module": "empirica.cli.command_handlers.performance_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle benchmark command for performance testing",
      "decorators": [],
      "calls": [
        "run_benchmark",
        "items",
        "_get_profile_performance_thresholds",
        "format_execution_time",
        "getattr",
        "print",
        "isinstance",
        "get",
        "handle_cli_error",
        "EmpiricalPerformanceAnalyzer",
        "time"
      ],
      "line_number": 41
    },
    "empirica.cli.command_handlers.performance_commands.handle_performance_command": {
      "name": "handle_performance_command",
      "module": "empirica.cli.command_handlers.performance_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle performance command (consolidates performance + benchmark)",
      "decorators": [],
      "calls": [
        "handle_benchmark_command",
        "analyze_performance",
        "_get_profile_performance_thresholds",
        "items",
        "getattr",
        "get",
        "handle_cli_error",
        "EmpiricalPerformanceAnalyzer",
        "print",
        "parse_json_safely"
      ],
      "line_number": 115
    },
    "empirica.cli.command_handlers.decision_commands.handle_decision_command": {
      "name": "handle_decision_command",
      "module": "empirica.cli.command_handlers.decision_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle decision command with epistemic assessment and ModalitySwitcher routing.\n\nSupports:\n- Interactive epistemic assessment\n- Batch mode from JSON/flags\n- Strategy selection\n- Adapter forcing\n- Mode",
      "decorators": [],
      "calls": [
        "warning",
        "isatty",
        "RoutingPreferences",
        "route_request",
        "getattr",
        "enumerate",
        "get_available_models",
        "get_default_model",
        "interactive_epistemic_assessment",
        "print",
        "hasattr",
        "items",
        "strip",
        "len",
        "get",
        "ModalitySwitcher",
        "lower",
        "load_epistemic_state_from_file",
        "input",
        "get_credentials_loader",
        "load_epistemic_state_from_flags",
        "sorted",
        "info",
        "isinstance",
        "int",
        "exit",
        "join",
        "execute_with_routing",
        "handle_cli_error"
      ],
      "line_number": 42
    },
    "empirica.cli.command_handlers.decision_commands.interactive_epistemic_assessment": {
      "name": "interactive_epistemic_assessment",
      "module": "empirica.cli.command_handlers.decision_commands",
      "params": [],
      "returns": "Dict[str, float]",
      "docstring": "Conduct interactive epistemic assessment for all 13 vectors.\n\nReturns:\n    Dict mapping vector names to scores (0.0-1.0)",
      "decorators": [],
      "calls": [
        "input",
        "enumerate",
        "info",
        "float",
        "strip",
        "lower",
        "print"
      ],
      "line_number": 225
    },
    "empirica.cli.command_handlers.decision_commands.load_epistemic_state_from_file": {
      "name": "load_epistemic_state_from_file",
      "module": "empirica.cli.command_handlers.decision_commands",
      "params": [
        "filepath"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Load epistemic state from JSON file.",
      "decorators": [],
      "calls": [
        "open",
        "FileNotFoundError",
        "ValueError",
        "load",
        "print"
      ],
      "line_number": 269
    },
    "empirica.cli.command_handlers.decision_commands.load_epistemic_state_from_flags": {
      "name": "load_epistemic_state_from_flags",
      "module": "empirica.cli.command_handlers.decision_commands",
      "params": [
        "args"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Load epistemic state from command-line flags.",
      "decorators": [],
      "calls": [
        "hasattr",
        "getattr"
      ],
      "line_number": 291
    },
    "empirica.cli.command_handlers.decision_commands.handle_decision_batch_command": {
      "name": "handle_decision_batch_command",
      "module": "empirica.cli.command_handlers.decision_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle batch decision processing from file.\n\nExpected format:\n[\n    {\"query\": \"...\", \"epistemic_state\": {...}},\n    {\"query\": \"...\", \"epistemic_state\": {...}}\n]",
      "decorators": [],
      "calls": [
        "open",
        "RoutingPreferences",
        "getattr",
        "enumerate",
        "dump",
        "append",
        "replace",
        "len",
        "isinstance",
        "load",
        "execute_with_routing",
        "ModalitySwitcher",
        "handle_cli_error",
        "print"
      ],
      "line_number": 305
    },
    "empirica.cli.command_handlers.session_create.handle_session_create_command": {
      "name": "handle_session_create_command",
      "module": "empirica.cli.command_handlers.session_create",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Create a new session - AI-first with config file support",
      "decorators": [],
      "calls": [
        "getattr",
        "get_current_subject",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "read",
        "open",
        "hasattr",
        "run",
        "strip",
        "bootstrap_project_breadcrumbs",
        "get",
        "create_session",
        "commit",
        "dumps",
        "cursor",
        "str",
        "exit",
        "join",
        "close",
        "exists",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 10
    },
    "empirica.cli.command_handlers.chat_handler.render_markdown": {
      "name": "render_markdown",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [
        "text",
        "use_glow"
      ],
      "returns": "str",
      "docstring": "Render markdown text with glow for beautiful terminal output.\n\nArgs:\n    text: Markdown text to render\n    use_glow: Whether to use glow for rendering (requires glow installed)\n\nReturns:\n    Rendered ",
      "decorators": [],
      "calls": [
        "run",
        "strip"
      ],
      "line_number": 31
    },
    "empirica.cli.command_handlers.chat_handler.handle_chat_command": {
      "name": "handle_chat_command",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle 'empirica chat' command for interactive conversations.\n\nProvides REPL-style interface with:\n- Multi-turn conversation\n- Conversation history\n- Model switching during chat\n- Session persistence",
      "decorators": [],
      "calls": [
        "uuid4",
        "RoutingPreferences",
        "getattr",
        "_load_chat_session",
        "locals",
        "print",
        "open",
        "format_uvl_response",
        "hasattr",
        "mkdir",
        "Path",
        "_handle_chat_command",
        "strip",
        "len",
        "get",
        "ModalitySwitcher",
        "lower",
        "render_markdown",
        "input",
        "format_uvl_stream_message",
        "format_routing_decision",
        "_save_chat_session",
        "append",
        "write",
        "get_agent_emoji",
        "dumps",
        "startswith",
        "str",
        "exit",
        "split",
        "any",
        "execute_with_routing",
        "handle_cli_error"
      ],
      "line_number": 77
    },
    "empirica.cli.command_handlers.chat_handler._handle_chat_command": {
      "name": "_handle_chat_command",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [
        "command",
        "history",
        "session_id",
        "switcher",
        "local_vars"
      ],
      "returns": "bool",
      "docstring": "Handle special chat commands (starting with /).\nReturns True if command was handled, False otherwise.",
      "decorators": [],
      "calls": [
        "_list_chat_sessions",
        "split",
        "enumerate",
        "len",
        "clear",
        "lower",
        "print"
      ],
      "line_number": 303
    },
    "empirica.cli.command_handlers.chat_handler._save_chat_session": {
      "name": "_save_chat_session",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [
        "session_id",
        "history"
      ],
      "returns": "",
      "docstring": "Save chat session to database",
      "decorators": [],
      "calls": [
        "create_session",
        "open",
        "isoformat",
        "mkdir",
        "dump",
        "Path",
        "utcnow",
        "len",
        "SessionDatabase",
        "print"
      ],
      "line_number": 379
    },
    "empirica.cli.command_handlers.chat_handler._load_chat_session": {
      "name": "_load_chat_session",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [
        "session_id"
      ],
      "returns": "List[Dict]",
      "docstring": "Load chat session from database",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "info",
        "Path",
        "len",
        "exists",
        "load",
        "get",
        "print"
      ],
      "line_number": 417
    },
    "empirica.cli.command_handlers.chat_handler._list_chat_sessions": {
      "name": "_list_chat_sessions",
      "module": "empirica.cli.command_handlers.chat_handler",
      "params": [],
      "returns": "",
      "docstring": "List available chat sessions",
      "decorators": [],
      "calls": [
        "list",
        "glob",
        "open",
        "sorted",
        "Path",
        "next",
        "exists",
        "load",
        "stat",
        "get",
        "print"
      ],
      "line_number": 443
    },
    "empirica.cli.command_handlers.project_embed._load_semantic_index": {
      "name": "_load_semantic_index",
      "module": "empirica.cli.command_handlers.project_embed",
      "params": [
        "root"
      ],
      "returns": "Dict",
      "docstring": "",
      "decorators": [],
      "calls": [
        "safe_load",
        "open",
        "join"
      ],
      "line_number": 15
    },
    "empirica.cli.command_handlers.project_embed._read_file": {
      "name": "_read_file",
      "module": "empirica.cli.command_handlers.project_embed",
      "params": [
        "path"
      ],
      "returns": "str",
      "docstring": "",
      "decorators": [],
      "calls": [
        "read",
        "open"
      ],
      "line_number": 22
    },
    "empirica.cli.command_handlers.project_embed.handle_project_embed_command": {
      "name": "handle_project_embed_command",
      "module": "empirica.cli.command_handlers.project_embed",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "getcwd",
        "upsert_memory",
        "getattr",
        "SessionDatabase",
        "execute",
        "print",
        "get_project_unknowns",
        "fetchall",
        "dict",
        "items",
        "len",
        "upsert_docs",
        "get",
        "_read_file",
        "init_collections",
        "append",
        "dumps",
        "cursor",
        "startswith",
        "join",
        "split",
        "close",
        "get_project_findings",
        "handle_cli_error",
        "_load_semantic_index"
      ],
      "line_number": 30
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_create_command": {
      "name": "handle_goals_create_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-create command - AI-first with legacy flag support",
      "decorators": [],
      "calls": [
        "create",
        "to_dict",
        "warning",
        "uuid4",
        "getattr",
        "enumerate",
        "create_issue",
        "float",
        "SessionDatabase",
        "execute",
        "save_goal",
        "print",
        "read",
        "GoalRepository",
        "ScopeVector",
        "open",
        "hasattr",
        "GitGoalStore",
        "len",
        "strip",
        "get",
        "SuccessCriterion",
        "info",
        "append",
        "commit",
        "isinstance",
        "dumps",
        "BeadsAdapter",
        "startswith",
        "store_goal",
        "str",
        "exit",
        "debug",
        "close",
        "is_available",
        "exists",
        "bool",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 24
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_add_subtask_command": {
      "name": "handle_goals_add_subtask_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-add-subtask command",
      "decorators": [],
      "calls": [
        "create",
        "warning",
        "getattr",
        "create_issue",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "hasattr",
        "save_subtask",
        "TaskRepository",
        "upper",
        "get",
        "add_dependency",
        "info",
        "commit",
        "dumps",
        "BeadsAdapter",
        "close",
        "is_available",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "line_number": 291
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_complete_subtask_command": {
      "name": "handle_goals_complete_subtask_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-complete-subtask command",
      "decorators": [],
      "calls": [
        "hasattr",
        "time",
        "getattr",
        "close",
        "update_subtask_status",
        "TaskRepository",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 424
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_progress_command": {
      "name": "handle_goals_progress_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-progress command",
      "decorators": [],
      "calls": [
        "GoalRepository",
        "dumps",
        "hasattr",
        "get_goal_subtasks",
        "time",
        "getattr",
        "close",
        "TaskRepository",
        "len",
        "get",
        "get_goal",
        "handle_cli_error",
        "print",
        "sum"
      ],
      "line_number": 472
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_list_command": {
      "name": "handle_goals_list_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-list command",
      "decorators": [],
      "calls": [
        "to_dict",
        "getattr",
        "enumerate",
        "print",
        "title",
        "GoalRepository",
        "hasattr",
        "get_goal_subtasks",
        "items",
        "TaskRepository",
        "len",
        "get_session_goals",
        "append",
        "replace",
        "dumps",
        "time",
        "sum",
        "join",
        "close",
        "handle_cli_error"
      ],
      "line_number": 536
    },
    "empirica.cli.command_handlers.goal_commands.handle_goals_get_subtasks_command": {
      "name": "handle_goals_get_subtasks_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-get-subtasks command - get detailed subtask information",
      "decorators": [],
      "calls": [
        "dumps",
        "hasattr",
        "get_goal_subtasks",
        "time",
        "enumerate",
        "getattr",
        "close",
        "append",
        "TaskRepository",
        "len",
        "get",
        "handle_cli_error",
        "print",
        "sum"
      ],
      "line_number": 676
    },
    "empirica.cli.command_handlers.goal_commands.handle_sessions_resume_command": {
      "name": "handle_sessions_resume_command",
      "module": "empirica.cli.command_handlers.goal_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle sessions-resume command",
      "decorators": [],
      "calls": [
        "cursor",
        "fetchall",
        "str",
        "dict",
        "hasattr",
        "getattr",
        "enumerate",
        "close",
        "append",
        "print",
        "len",
        "fetchone",
        "SessionDatabase",
        "dumps",
        "execute",
        "handle_cli_error",
        "time"
      ],
      "line_number": 759
    },
    "empirica.cli.command_handlers.goal_complete_command.handle_goals_complete_command": {
      "name": "handle_goals_complete_command",
      "module": "empirica.cli.command_handlers.goal_complete_command",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Handle goals-complete command - Complete goal, merge branch, close BEADS",
      "decorators": [],
      "calls": [
        "get_by_id",
        "close_issue",
        "warning",
        "get_branch_mapping",
        "getattr",
        "fetchone",
        "SessionDatabase",
        "execute",
        "print",
        "GoalRepository",
        "run",
        "handle_postflight_command",
        "strip",
        "get",
        "get_branch_for_goal",
        "MockArgs",
        "dumps",
        "BeadsAdapter",
        "str",
        "exit",
        "handle_handoff_create_command",
        "close",
        "is_available",
        "remove_mapping",
        "handle_cli_error"
      ],
      "line_number": 18
    },
    "empirica.cli.command_handlers.goal_complete_command.__init__": {
      "name": "__init__",
      "module": "empirica.cli.command_handlers.goal_complete_command",
      "params": [
        "self",
        "session_id",
        "task_summary"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 184
    },
    "empirica.cli.command_handlers.doc_commands.handle_doc_check_command": {
      "name": "handle_doc_check_command",
      "module": "empirica.cli.command_handlers.doc_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "getattr",
        "enumerate",
        "compute_doc_plan",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 9
    },
    "empirica.cli.command_handlers.doc_commands.handle_doc_plan_suggest_command": {
      "name": "handle_doc_plan_suggest_command",
      "module": "empirica.cli.command_handlers.doc_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "getattr",
        "print",
        "compute_doc_plan",
        "handle_cli_error",
        "dumps"
      ],
      "line_number": 30
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_start_command": {
      "name": "handle_mcp_start_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Start MCP server in background",
      "decorators": [],
      "calls": [
        "Popen",
        "open",
        "sleep",
        "str",
        "_get_mcp_pid",
        "mkdir",
        "getattr",
        "write",
        "_is_mcp_running",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 26
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_stop_command": {
      "name": "handle_mcp_stop_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Stop MCP server",
      "decorators": [],
      "calls": [
        "unlink",
        "sleep",
        "_get_mcp_pid",
        "getattr",
        "kill",
        "_is_mcp_running",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 72
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_status_command": {
      "name": "handle_mcp_status_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Check MCP server status",
      "decorators": [],
      "calls": [
        "localtime",
        "cpu_percent",
        "_get_mcp_pid",
        "getattr",
        "strftime",
        "create_time",
        "Process",
        "num_threads",
        "memory_info",
        "get",
        "_is_mcp_running",
        "handle_cli_error",
        "lower",
        "print",
        "print_header"
      ],
      "line_number": 110
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_test_command": {
      "name": "handle_mcp_test_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Test MCP server connection",
      "decorators": [],
      "calls": [
        "str",
        "run",
        "getattr",
        "_is_mcp_running",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 145
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_list_tools_command": {
      "name": "handle_mcp_list_tools_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List available MCP tools",
      "decorators": [],
      "calls": [
        "getattr",
        "print",
        "len",
        "get",
        "handle_cli_error",
        "lower",
        "print_header"
      ],
      "line_number": 189
    },
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_call_command": {
      "name": "handle_mcp_call_command",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Call MCP tool directly (for testing)",
      "decorators": [],
      "calls": [
        "getattr",
        "loads",
        "dumps",
        "handle_cli_error",
        "print",
        "print_header"
      ],
      "line_number": 299
    },
    "empirica.cli.command_handlers.mcp_commands._is_mcp_running": {
      "name": "_is_mcp_running",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [],
      "returns": "",
      "docstring": "Check if MCP server is running",
      "decorators": [],
      "calls": [
        "unlink",
        "_get_mcp_pid",
        "exists",
        "kill"
      ],
      "line_number": 327
    },
    "empirica.cli.command_handlers.mcp_commands._get_mcp_pid": {
      "name": "_get_mcp_pid",
      "module": "empirica.cli.command_handlers.mcp_commands",
      "params": [],
      "returns": "",
      "docstring": "Get MCP server PID",
      "decorators": [],
      "calls": [
        "read",
        "strip",
        "open",
        "int"
      ],
      "line_number": 342
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_sign_command": {
      "name": "handle_checkpoint_sign_command",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Sign a checkpoint with AI identity",
      "decorators": [],
      "calls": [
        "CheckpointSigner",
        "exit",
        "get",
        "getattr",
        "sign_checkpoint",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 25
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_verify_command": {
      "name": "handle_checkpoint_verify_command",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "Verify a signed checkpoint",
      "decorators": [],
      "calls": [
        "exit",
        "verify_checkpoint",
        "public_key_hex",
        "get",
        "getattr",
        "load_keypair",
        "cwd",
        "VerificationSigner",
        "dumps",
        "AIIdentity",
        "handle_cli_error",
        "print"
      ],
      "line_number": 89
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_signatures_command": {
      "name": "handle_checkpoint_signatures_command",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "params": [
        "args"
      ],
      "returns": "",
      "docstring": "List all signed checkpoints",
      "decorators": [],
      "calls": [
        "list_signed_checkpoints",
        "exit",
        "getattr",
        "enumerate",
        "cwd",
        "len",
        "ListSigner",
        "dumps",
        "handle_cli_error",
        "print"
      ],
      "line_number": 167
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.__init__": {
      "name": "__init__",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "params": [
        "self",
        "git_repo_path"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [
        "cwd"
      ],
      "line_number": 181
    },
    "empirica.cli.command_handlers.decision_utils.load_feedback_loops_config": {
      "name": "load_feedback_loops_config",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [],
      "returns": "dict",
      "docstring": "Load feedback loops configuration from YAML.\n\nReturns:\n    Dict with feedback loops config, or empty dict if file not found",
      "decorators": [],
      "calls": [
        "open",
        "warning",
        "join",
        "dirname",
        "safe_load"
      ],
      "line_number": 16
    },
    "empirica.cli.command_handlers.decision_utils.get_agent_feedback_loop_config": {
      "name": "get_agent_feedback_loop_config",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [
        "ai_id"
      ],
      "returns": "dict",
      "docstring": "Get feedback loop configuration for a specific AI agent.\n\nLoads the agent-specific config, falling back to defaults as needed.\n\nArgs:\n    ai_id: Agent identifier (e.g., 'claude-code', 'claude-sonnet')",
      "decorators": [],
      "calls": [
        "get",
        "load_feedback_loops_config"
      ],
      "line_number": 40
    },
    "empirica.cli.command_handlers.decision_utils.evaluate_cognitive_load": {
      "name": "evaluate_cognitive_load",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [
        "density",
        "ai_id"
      ],
      "returns": "dict",
      "docstring": "Evaluate cognitive load based on DENSITY vector and feedback loop config.\n\nUses actual DENSITY epistemic measurement, not heuristics.\n\nArgs:\n    density: DENSITY epistemic vector (0.0-1.0)\n    ai_id: ",
      "decorators": [],
      "calls": [
        "get",
        "get_agent_feedback_loop_config"
      ],
      "line_number": 63
    },
    "empirica.cli.command_handlers.decision_utils.get_cognitive_load_decision_impact": {
      "name": "get_cognitive_load_decision_impact",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [
        "density",
        "ai_id"
      ],
      "returns": "dict",
      "docstring": "Determine how cognitive load should affect CHECK phase decision gate.\n\nArgs:\n    density: DENSITY epistemic vector (0.0-1.0)\n    ai_id: Agent identifier for agent-specific config\n\nReturns:\n    Dict wi",
      "decorators": [],
      "calls": [
        "evaluate_cognitive_load"
      ],
      "line_number": 131
    },
    "empirica.cli.command_handlers.decision_utils.calculate_decision": {
      "name": "calculate_decision",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [
        "confidence"
      ],
      "returns": "str",
      "docstring": "Determine next action based on confidence assessment.\n\nArgs:\n    confidence: Confidence score (0.0-1.0)\n\nReturns:\n    Decision string: \"proceed\", \"investigate\", or \"proceed_with_caution\"",
      "decorators": [],
      "calls": [],
      "line_number": 167
    },
    "empirica.cli.command_handlers.decision_utils.get_recommendation_from_vectors": {
      "name": "get_recommendation_from_vectors",
      "module": "empirica.cli.command_handlers.decision_utils",
      "params": [
        "vectors"
      ],
      "returns": "dict",
      "docstring": "Get recommendation based on epistemic vectors (multi-factor decision).\n\nUsed when multiple epistemic vectors are available for nuanced decisions.\n\nArgs:\n    vectors: Dict with epistemic vector scores ",
      "decorators": [],
      "calls": [
        "get",
        "append"
      ],
      "line_number": 185
    },
    "empirica.components.edit_verification.confidence_assessor.__init__": {
      "name": "__init__",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 26
    },
    "empirica.components.edit_verification.confidence_assessor.assess": {
      "name": "assess",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "file_path",
        "old_str",
        "context_source",
        "last_read_turn",
        "current_turn"
      ],
      "returns": "Dict[str, float]",
      "docstring": "Assess confidence for an edit operation.\n\nArgs:\n    file_path: Path to file being edited\n    old_str: String to be replaced\n    context_source: \"memory\" | \"view_output\" | \"fresh_read\"\n    last_read_tu",
      "decorators": [],
      "calls": [
        "_assess_truncation_risk",
        "_assess_match_uniqueness",
        "_assess_whitespace_confidence",
        "_assess_context_freshness"
      ],
      "line_number": 32
    },
    "empirica.components.edit_verification.confidence_assessor.recommend_strategy": {
      "name": "recommend_strategy",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "assessment"
      ],
      "returns": "Tuple[str, str]",
      "docstring": "Recommend edit strategy based on assessment.\n\nReturns:\n    (strategy, reasoning) where strategy is:\n    - \"atomic_edit\": High confidence, use native edit tool\n    - \"bash_fallback\": Medium confidence,",
      "decorators": [],
      "calls": [
        "_context_age_description"
      ],
      "line_number": 81
    },
    "empirica.components.edit_verification.confidence_assessor._assess_context_freshness": {
      "name": "_assess_context_freshness",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "file_path",
        "context_source",
        "last_read_turn",
        "current_turn"
      ],
      "returns": "float",
      "docstring": "Assess how recently the file was read.\n\nReturns:\n    1.0: Fresh read (view_output in current turn)\n    0.9: Very recent (1-2 turns ago)\n    0.7: Recent (3-5 turns ago)\n    0.5: Stale (6-10 turns ago)\n",
      "decorators": [],
      "calls": [],
      "line_number": 137
    },
    "empirica.components.edit_verification.confidence_assessor._assess_whitespace_confidence": {
      "name": "_assess_whitespace_confidence",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "old_str",
        "context_source"
      ],
      "returns": "float",
      "docstring": "Assess uncertainty about exact whitespace match.\n\nReturns (uncertainty, higher = more uncertain):\n    0.1: Low uncertainty (view output, consistent spacing)\n    0.3: Moderate (view output, mixed tabs/",
      "decorators": [],
      "calls": [],
      "line_number": 177
    },
    "empirica.components.edit_verification.confidence_assessor._assess_match_uniqueness": {
      "name": "_assess_match_uniqueness",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "file_path",
        "old_str"
      ],
      "returns": "float",
      "docstring": "Assess how unique the pattern is in the file.\n\nReturns:\n    0.9: Unique (1 occurrence)\n    0.7: Somewhat unique (2-3 occurrences)\n    0.4: Ambiguous (4+ occurrences)\n    0.0: No match (will fail)",
      "decorators": [],
      "calls": [
        "read",
        "count",
        "open"
      ],
      "line_number": 212
    },
    "empirica.components.edit_verification.confidence_assessor._assess_truncation_risk": {
      "name": "_assess_truncation_risk",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "old_str"
      ],
      "returns": "float",
      "docstring": "Assess risk that old_str is truncated in context window.\n\nReturns (clarity, lower = more truncation risk):\n    0.9: No truncation indicators\n    0.6: Possible truncation (long lines)\n    0.3: Likely t",
      "decorators": [],
      "calls": [
        "len",
        "split",
        "max"
      ],
      "line_number": 240
    },
    "empirica.components.edit_verification.confidence_assessor._context_age_description": {
      "name": "_context_age_description",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "params": [
        "self",
        "context_score"
      ],
      "returns": "str",
      "docstring": "Get human-readable description of context age.",
      "decorators": [],
      "calls": [],
      "line_number": 262
    },
    "empirica.components.edit_verification.strategy_executor.__init__": {
      "name": "__init__",
      "module": "empirica.components.edit_verification.strategy_executor",
      "params": [
        "self"
      ],
      "returns": "",
      "docstring": "",
      "decorators": [],
      "calls": [],
      "line_number": 25
    },
    "empirica.components.edit_verification.strategy_executor._make_flexible_pattern": {
      "name": "_make_flexible_pattern",
      "module": "empirica.components.edit_verification.strategy_executor",
      "params": [
        "self",
        "old_str"
      ],
      "returns": "str",
      "docstring": "Convert exact string to regex with flexible whitespace.\n\nExample: \"def  my_func():\" -> r\"def\\s+my_func\\(\\):\"",
      "decorators": [],
      "calls": [
        "escape",
        "replace"
      ],
      "line_number": 226
    }
  },
  "classes": {
    "empirica.cli.simple_session_server.SessionManager": {
      "name": "SessionManager",
      "module": "empirica.cli.simple_session_server",
      "docstring": "Manages stateful AI collaboration sessions",
      "methods": [
        "__init__",
        "create",
        "execute_command",
        "_list_files",
        "_read_file",
        "_move_file",
        "_run_bash",
        "_prompt_assessment",
        "_store_assessment",
        "_handle_plan_proposal",
        "_get_guidance",
        "_dashboard",
        "_get_available_actions",
        "_get_recommended",
        "_get_status_summary"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 27
    },
    "empirica.cli.simple_session_server.SessionCreate": {
      "name": "SessionCreate",
      "module": "empirica.cli.simple_session_server",
      "docstring": "",
      "methods": [],
      "bases": [
        "BaseModel"
      ],
      "decorators": [],
      "line_number": 486
    },
    "empirica.cli.simple_session_server.CommandExecute": {
      "name": "CommandExecute",
      "module": "empirica.cli.simple_session_server",
      "docstring": "",
      "methods": [],
      "bases": [
        "BaseModel"
      ],
      "decorators": [],
      "line_number": 492
    },
    "empirica.integrations.branch_mapping.BranchMapping": {
      "name": "BranchMapping",
      "module": "empirica.integrations.branch_mapping",
      "docstring": "Manages branch-to-goal mapping in .empirica/branch_mapping.json",
      "methods": [
        "__init__",
        "_find_repo_root",
        "_load_mappings",
        "_save_mappings",
        "add_mapping",
        "get_mapping",
        "get_branch_for_goal",
        "remove_mapping",
        "list_active_mappings",
        "get_history"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 20
    },
    "empirica.reasoning.types.DeprecationJudgment": {
      "name": "DeprecationJudgment",
      "module": "empirica.reasoning.types",
      "docstring": "Result of deprecation analysis",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 9
    },
    "empirica.reasoning.types.RelationshipAnalysis": {
      "name": "RelationshipAnalysis",
      "module": "empirica.reasoning.types",
      "docstring": "Result of doc-code relationship analysis",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 20
    },
    "empirica.reasoning.types.ImplementationGap": {
      "name": "ImplementationGap",
      "module": "empirica.reasoning.types",
      "docstring": "Result of implementation gap analysis",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 33
    },
    "empirica.reasoning.ollama_adapter.OllamaReasoningModel": {
      "name": "OllamaReasoningModel",
      "module": "empirica.reasoning.ollama_adapter",
      "docstring": "Adapter for Ollama-hosted reasoning models",
      "methods": [
        "__init__",
        "_call_ollama",
        "_build_deprecation_prompt",
        "_parse_deprecation_response",
        "analyze_deprecation",
        "_build_relationship_prompt",
        "_parse_relationship_response",
        "analyze_relationship",
        "_build_implementation_gap_prompt",
        "_parse_implementation_gap_response",
        "analyze_implementation_gap"
      ],
      "bases": [
        "ReasoningService"
      ],
      "decorators": [],
      "line_number": 18
    },
    "empirica.reasoning.epistemic_cascade.EpistemicCascade": {
      "name": "EpistemicCascade",
      "module": "empirica.reasoning.epistemic_cascade",
      "docstring": "Uncertainty-driven cascade through model tiers\n\nTiers:\n1. Fast (7B): 2-5s per analysis, handles 70-80% of cases\n2. Powerful (32B): 30s per analysis, handles uncertain cases\n3. Human: Final escalation ",
      "methods": [
        "__init__",
        "analyze_with_cascade",
        "_create_human_review_judgment",
        "analyze_batch_with_cascade"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 22
    },
    "empirica.reasoning.service.ReasoningService": {
      "name": "ReasoningService",
      "module": "empirica.reasoning.service",
      "docstring": "Abstract interface for AI reasoning services",
      "methods": [
        "analyze_deprecation",
        "analyze_relationship",
        "analyze_implementation_gap"
      ],
      "bases": [
        "ABC"
      ],
      "decorators": [],
      "line_number": 12
    },
    "empirica.config.credentials_loader.CredentialsLoader": {
      "name": "CredentialsLoader",
      "module": "empirica.config.credentials_loader",
      "docstring": "Load and manage AI adapter credentials",
      "methods": [
        "__new__",
        "__init__",
        "_find_config_file",
        "_load_credentials",
        "_interpolate_env_vars",
        "_load_from_dotfiles",
        "get_provider_config",
        "get_api_key",
        "get_base_url",
        "get_headers",
        "get_default_model",
        "get_available_models",
        "validate_model",
        "get_auth_method",
        "list_providers",
        "reload"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 32
    },
    "empirica.config.project_config_loader.ProjectConfig": {
      "name": "ProjectConfig",
      "module": "empirica.config.project_config_loader",
      "docstring": "Project configuration with subject mappings",
      "methods": [
        "__init__",
        "get_subject_for_path",
        "get_subject_info",
        "list_subjects"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 16
    },
    "empirica.config.memory_gap_policy_loader.MemoryGapPolicyLoader": {
      "name": "MemoryGapPolicyLoader",
      "module": "empirica.config.memory_gap_policy_loader",
      "docstring": "Memory gap policy loader for configurable enforcement.\n\nDesign:\n- Loads policies from epistemic_conduct.yaml\n- Provides enforcement mode configuration\n- Supports per-category policy overrides\n- Includ",
      "methods": [
        "__init__",
        "_load_configurations",
        "_load_hardcoded_defaults",
        "get_policy",
        "get_enforcement_for_gap",
        "list_enforcement_modes",
        "list_scope_policies"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 41
    },
    "empirica.config.goal_scope_loader.GoalScopeLoader": {
      "name": "GoalScopeLoader",
      "module": "empirica.config.goal_scope_loader",
      "docstring": "Goal scope recommendation engine based on epistemic vectors.\n\nDesign:\n- Loads scope recommendations from goal_scopes.yaml\n- Maps epistemic patterns to scope vectors\n- Provides advisory recommendations",
      "methods": [
        "__init__",
        "_load_configurations",
        "_load_hardcoded_defaults",
        "get_scope_recommendations",
        "_calculate_pattern_match",
        "_apply_context_adjustments",
        "_get_conservative_defaults",
        "validate_scope_coherence",
        "list_available_patterns"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 48
    },
    "empirica.config.profile_loader.ToolSuggestionMode": {
      "name": "ToolSuggestionMode",
      "module": "empirica.config.profile_loader",
      "docstring": "How tools are suggested to AI",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 16
    },
    "empirica.config.profile_loader.DomainDetection": {
      "name": "DomainDetection",
      "module": "empirica.config.profile_loader",
      "docstring": "How domain is detected",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 25
    },
    "empirica.config.profile_loader.PostflightMode": {
      "name": "PostflightMode",
      "module": "empirica.config.profile_loader",
      "docstring": "How postflight assessment works",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 34
    },
    "empirica.config.profile_loader.InvestigationConstraints": {
      "name": "InvestigationConstraints",
      "module": "empirica.config.profile_loader",
      "docstring": "Investigation phase constraints",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 43
    },
    "empirica.config.profile_loader.ActionThresholds": {
      "name": "ActionThresholds",
      "module": "empirica.config.profile_loader",
      "docstring": "Thresholds for action determination",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 55
    },
    "empirica.config.profile_loader.TuningParameters": {
      "name": "TuningParameters",
      "module": "empirica.config.profile_loader",
      "docstring": "Confidence calculation tuning",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 66
    },
    "empirica.config.profile_loader.StrategyConfig": {
      "name": "StrategyConfig",
      "module": "empirica.config.profile_loader",
      "docstring": "Investigation strategy configuration",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 76
    },
    "empirica.config.profile_loader.LearningConfig": {
      "name": "LearningConfig",
      "module": "empirica.config.profile_loader",
      "docstring": "Learning and postflight configuration",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 84
    },
    "empirica.config.profile_loader.InvestigationProfile": {
      "name": "InvestigationProfile",
      "module": "empirica.config.profile_loader",
      "docstring": "Complete investigation profile",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 92
    },
    "empirica.config.profile_loader.UniversalConstraints": {
      "name": "UniversalConstraints",
      "module": "empirica.config.profile_loader",
      "docstring": "Universal constraints enforced by Sentinel",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 145
    },
    "empirica.config.profile_loader.ProfileLoader": {
      "name": "ProfileLoader",
      "module": "empirica.config.profile_loader",
      "docstring": "Loads and manages investigation profiles",
      "methods": [
        "__init__",
        "load_config",
        "_parse_profile",
        "get_profile",
        "select_profile",
        "list_profiles",
        "validate_constraints",
        "export_profile",
        "import_profile"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 157
    },
    "empirica.config.threshold_loader.ThresholdLoader": {
      "name": "ThresholdLoader",
      "module": "empirica.config.threshold_loader",
      "docstring": "Dynamic threshold configuration loader with singleton pattern.\n\nLoads threshold profiles from cascade_styles.yaml and provides:\n- Profile switching (default, exploratory, rigorous, rapid, expert, novi",
      "methods": [
        "__init__",
        "get_instance",
        "reset_instance",
        "_load_profiles",
        "_load_hardcoded_defaults",
        "load_profile",
        "get",
        "override",
        "clear_overrides",
        "create_custom_profile",
        "_set_nested_value",
        "get_profile_info",
        "list_profiles",
        "get_all_thresholds",
        "export_for_handoff"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 43
    },
    "empirica.dashboard.cascade_monitor.CascadeMonitor": {
      "name": "CascadeMonitor",
      "module": "empirica.dashboard.cascade_monitor",
      "docstring": "Minimalist CASCADE monitor for tmux dashboard",
      "methods": [
        "__init__",
        "get_active_cascade",
        "get_latest_cascade",
        "get_assessments",
        "format_vector_state",
        "format_phase_progress",
        "calculate_delta",
        "format_delta_indicator",
        "render_markdown",
        "render_with_glow",
        "display",
        "watch_for_updates"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 30
    },
    "empirica.dashboard.snapshot_monitor.SnapshotMonitor": {
      "name": "SnapshotMonitor",
      "module": "empirica.dashboard.snapshot_monitor",
      "docstring": "Terminal-based snapshot monitoring dashboard",
      "methods": [
        "__init__",
        "get_color_for_reliability",
        "get_status_label",
        "format_bar",
        "draw_header",
        "draw_compression_status",
        "draw_snapshot_timeline",
        "draw_commands",
        "draw_details",
        "export_snapshot",
        "main_loop"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 46
    },
    "empirica.core.epistemic_bus.EpistemicEvent": {
      "name": "EpistemicEvent",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Simple epistemic event structure\n\nEvents are just data - no behavior, no routing logic",
      "methods": [
        "__init__",
        "to_dict",
        "__repr__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 22
    },
    "empirica.core.epistemic_bus.EpistemicObserver": {
      "name": "EpistemicObserver",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Interface for external systems that observe epistemic events\n\nExamples:\n- RoutingSentinel: Suggests routing based on epistemic state\n- MCO: Coordinates multiple agents\n- Monitor: Logs/visualizes epist",
      "methods": [
        "handle_event"
      ],
      "bases": [
        "ABC"
      ],
      "decorators": [],
      "line_number": 56
    },
    "empirica.core.epistemic_bus.EpistemicBus": {
      "name": "EpistemicBus",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Simple pub/sub bus for epistemic events\n\nDesign principles:\n- Synchronous and simple (no queues, no async complexity)\n- Observers are called in order\n- Errors in observers are logged but don't block\n-",
      "methods": [
        "__init__",
        "subscribe",
        "unsubscribe",
        "publish",
        "get_observer_count",
        "get_event_count",
        "clear_observers"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 80
    },
    "empirica.core.epistemic_bus.EventTypes": {
      "name": "EventTypes",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Standard event types published by Empirica components",
      "methods": [],
      "bases": [],
      "decorators": [],
      "line_number": 160
    },
    "empirica.core.epistemic_bus.LoggingObserver": {
      "name": "LoggingObserver",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Simple observer that logs all events\n\nUseful for debugging and development",
      "methods": [
        "__init__",
        "handle_event"
      ],
      "bases": [
        "EpistemicObserver"
      ],
      "decorators": [],
      "line_number": 193
    },
    "empirica.core.epistemic_bus.CallbackObserver": {
      "name": "CallbackObserver",
      "module": "empirica.core.epistemic_bus",
      "docstring": "Observer that calls a function for each event\n\nUseful for testing and simple integrations",
      "methods": [
        "__init__",
        "handle_event"
      ],
      "bases": [
        "EpistemicObserver"
      ],
      "decorators": [],
      "line_number": 211
    },
    "empirica.core.memory_gap_detector.MemoryGap": {
      "name": "MemoryGap",
      "module": "empirica.core.memory_gap_detector",
      "docstring": "A detected gap between claimed and realistic knowledge.",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 38
    },
    "empirica.core.memory_gap_detector.MemoryGapReport": {
      "name": "MemoryGapReport",
      "module": "empirica.core.memory_gap_detector",
      "docstring": "Complete memory gap analysis.",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 52
    },
    "empirica.core.memory_gap_detector.MemoryGapDetector": {
      "name": "MemoryGapDetector",
      "module": "empirica.core.memory_gap_detector",
      "docstring": "Detect memory gaps with configurable enforcement.\n\nModes:\n- inform: Show gaps, no penalty (default)\n- warn: Show gaps + recommendations\n- strict: Show gaps + adjust vectors to realistic\n- block: Show ",
      "methods": [
        "__init__",
        "detect_gaps",
        "_check_findings",
        "_check_unknowns",
        "_check_file_awareness",
        "_check_compaction",
        "_calculate_expected_knowledge",
        "_calculate_signal_confidence",
        "_determine_enforcement",
        "_suggest_actions",
        "apply_enforcement",
        "_referenced_in_session",
        "_incorporated_in_session",
        "_mentioned_in_session"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 63
    },
    "empirica.core.context_load_balancer.ContextLoadBalancer": {
      "name": "ContextLoadBalancer",
      "module": "empirica.core.context_load_balancer",
      "docstring": "Decides what context to inject based on task characteristics.\n\nUses rule-based heuristics for:\n- Uncertainty-driven depth selection\n- Tag-based skill matching\n- Workflow-specific MCO config selection\n",
      "methods": [
        "__init__",
        "calculate_context_budget",
        "_calculate_dynamic_budget",
        "_select_mco_configs",
        "_match_skills_to_task",
        "estimate_tokens",
        "validate_budget"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 32
    },
    "empirica.core.checkpoint_signer.CheckpointSigner": {
      "name": "CheckpointSigner",
      "module": "empirica.core.checkpoint_signer",
      "docstring": "Signs and verifies git checkpoint notes using Ed25519\n\nProvides cryptographic proof that checkpoints haven't been tampered with\nand were created by a specific AI identity.",
      "methods": [
        "__init__",
        "sign_checkpoint",
        "verify_checkpoint",
        "list_signed_checkpoints"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 50
    },
    "empirica.utils.doc_code_integrity.DocCodeIntegrityAnalyzer": {
      "name": "DocCodeIntegrityAnalyzer",
      "module": "empirica.utils.doc_code_integrity",
      "docstring": "Analyze integrity between documentation and codebase",
      "methods": [
        "__init__",
        "analyze_cli_commands",
        "_get_actual_cli_commands",
        "_get_documented_cli_commands",
        "_calculate_integrity_score",
        "get_detailed_gaps",
        "_find_command_mentions"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 21
    },
    "empirica.utils.deprecation_detector.DeprecationDetector": {
      "name": "DeprecationDetector",
      "module": "empirica.utils.deprecation_detector",
      "docstring": "Detect deprecated features using multiple signals",
      "methods": [
        "__init__",
        "detect_explicit_deprecation",
        "_extract_feature_from_context",
        "detect_unused_features",
        "_is_core_feature",
        "detect_stale_code",
        "generate_deprecation_report"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 16
    },
    "empirica.plugins.dashboard_spawner.DashboardSpawner": {
      "name": "DashboardSpawner",
      "module": "empirica.plugins.dashboard_spawner",
      "docstring": "Spawns Empirica dashboard for AI orchestration visibility\n\nDesign Philosophy:\n- Non-intrusive: Works silently, fails gracefully\n- AI-friendly: Simple API for AI orchestration\n- Optional: Empirica work",
      "methods": [
        "__init__",
        "_find_empirica_root",
        "is_tmux_available",
        "is_libtmux_available",
        "get_dashboard_status",
        "_get_current_session_name",
        "spawn_dashboard"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 38
    },
    "empirica.plugins.base_plugin.BasePlugin": {
      "name": "BasePlugin",
      "module": "empirica.plugins.base_plugin",
      "docstring": "Base class for all Empirica plugins.",
      "methods": [
        "initialize",
        "health_check",
        "get_metadata",
        "cleanup"
      ],
      "bases": [
        "ABC"
      ],
      "decorators": [],
      "line_number": 11
    },
    "empirica.investigation.investigation_plugin.InvestigationPlugin": {
      "name": "InvestigationPlugin",
      "module": "empirica.investigation.investigation_plugin",
      "docstring": "Plugin interface for custom investigation tools\n\nAttributes:\n    name: Unique identifier for the tool\n    description: Clear explanation of what the tool does (shown to LLM)\n    improves_vectors: Whic",
      "methods": [
        "__post_init__",
        "to_capability_dict",
        "__repr__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 30
    },
    "empirica.investigation.investigation_plugin.PluginRegistry": {
      "name": "PluginRegistry",
      "module": "empirica.investigation.investigation_plugin",
      "docstring": "Registry for managing investigation plugins\n\nProvides convenient methods for registering, discovering, and using plugins.",
      "methods": [
        "__init__",
        "register",
        "unregister",
        "get",
        "list_plugins",
        "get_all_capabilities",
        "find_by_vector",
        "__len__",
        "__repr__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 129
    },
    "empirica.metrics.token_efficiency.TokenMeasurement": {
      "name": "TokenMeasurement",
      "module": "empirica.metrics.token_efficiency",
      "docstring": "Single token usage measurement",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 43
    },
    "empirica.metrics.token_efficiency.TokenEfficiencyMetrics": {
      "name": "TokenEfficiencyMetrics",
      "module": "empirica.metrics.token_efficiency",
      "docstring": "Track and analyze token efficiency for Empirica workflows.\n\nCompares git-based checkpoint loading (target) vs prompt-based full history\nloading (baseline) to validate token reduction hypothesis.",
      "methods": [
        "__init__",
        "measure_context_load",
        "_count_tokens",
        "get_phase_total",
        "get_session_total",
        "calculate_reduction",
        "compare_efficiency",
        "export_report",
        "_format_markdown_report",
        "_format_csv_report",
        "save_measurements",
        "load_measurements"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 53
    },
    "empirica.integration.empirica_action_hooks.EmpiricaActionHooks": {
      "name": "EmpiricaActionHooks",
      "module": "empirica.integration.empirica_action_hooks",
      "docstring": "Action hooks that feed tmux panels in real-time",
      "methods": [
        "update_12d_monitor",
        "update_cascade_status",
        "update_chain_of_thought",
        "update_snapshot_status",
        "update_statusline_cache"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 27
    },
    "empirica.data.session_json_handler.SessionJSONHandler": {
      "name": "SessionJSONHandler",
      "module": "empirica.data.session_json_handler",
      "docstring": "Manages JSON exports and caching from SQLite database",
      "methods": [
        "__init__",
        "export_session",
        "export_cascade_graph",
        "load_session_context",
        "read_synthesis_history",
        "_extract_reasoning_summary",
        "create_compact_summary",
        "_get_cascade_assessments_summary"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 24
    },
    "empirica.data.session_database.SessionDatabase": {
      "name": "SessionDatabase",
      "module": "empirica.data.session_database",
      "docstring": "Central SQLite database for all session data",
      "methods": [
        "__init__",
        "_validate_session_id",
        "_create_tables",
        "_migrate_legacy_tables_to_reflexes",
        "create_session",
        "end_session",
        "create_cascade",
        "update_cascade_phase",
        "complete_cascade",
        "log_epistemic_assessment",
        "log_divergence",
        "log_bayesian_belief",
        "log_tool_execution",
        "get_session",
        "get_session_cascades",
        "get_cascade_assessments",
        "log_preflight_assessment",
        "log_check_phase_assessment",
        "log_postflight_assessment",
        "log_investigation_round",
        "log_act_phase",
        "_export_to_reflex_logs",
        "_determine_action",
        "get_preflight_assessment",
        "get_check_phase_assessments",
        "get_postflight_assessment",
        "get_preflight_vectors",
        "get_check_vectors",
        "get_postflight_vectors",
        "get_vectors_by_phase",
        "store_epistemic_delta",
        "get_last_session_by_ai",
        "get_session_snapshot",
        "get_session_summary",
        "get_git_checkpoint",
        "list_git_checkpoints",
        "get_checkpoint_diff",
        "_get_checkpoint_from_reflexes",
        "_get_latest_vectors",
        "store_vectors",
        "get_latest_vectors",
        "get_findings_by_file",
        "get_findings_by_commit",
        "create_goal",
        "create_subtask",
        "update_subtask_findings",
        "update_subtask_unknowns",
        "update_subtask_dead_ends",
        "complete_subtask",
        "get_all_sessions",
        "get_goal_tree",
        "query_unknowns_summary",
        "create_branch",
        "checkpoint_branch",
        "calculate_branch_merge_score",
        "merge_branches",
        "create_project",
        "get_project",
        "resolve_project_id",
        "link_session_to_project",
        "get_project_sessions",
        "aggregate_project_learning_deltas",
        "create_project_handoff",
        "get_latest_project_handoff",
        "bootstrap_project_breadcrumbs",
        "_generate_context_markdown",
        "log_finding",
        "log_unknown",
        "resolve_unknown",
        "log_dead_end",
        "add_reference_doc",
        "get_project_findings",
        "get_project_unknowns",
        "get_project_dead_ends",
        "get_project_reference_docs",
        "add_epistemic_source",
        "get_epistemic_sources",
        "log_mistake",
        "get_mistakes",
        "close"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 50
    },
    "empirica.data.repositories.goals.GoalRepository": {
      "name": "GoalRepository",
      "module": "empirica.data.repositories.goals",
      "docstring": "Repository for goal and subtask management",
      "methods": [
        "create_goal",
        "create_subtask",
        "update_subtask_findings",
        "update_subtask_unknowns",
        "update_subtask_dead_ends",
        "complete_subtask",
        "get_goal_tree",
        "query_unknowns_summary"
      ],
      "bases": [
        "BaseRepository"
      ],
      "decorators": [],
      "line_number": 16
    },
    "empirica.data.repositories.branches.BranchRepository": {
      "name": "BranchRepository",
      "module": "empirica.data.repositories.branches",
      "docstring": "Repository for investigation branch management (Phase 2 branching)",
      "methods": [
        "create_branch",
        "checkpoint_branch",
        "calculate_branch_merge_score",
        "merge_branches"
      ],
      "bases": [
        "BaseRepository"
      ],
      "decorators": [],
      "line_number": 16
    },
    "empirica.data.repositories.base.BaseRepository": {
      "name": "BaseRepository",
      "module": "empirica.data.repositories.base",
      "docstring": "Base class for all domain repositories",
      "methods": [
        "__init__",
        "_execute",
        "_execute_many",
        "commit",
        "rollback"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 17
    },
    "empirica.data.repositories.breadcrumbs.BreadcrumbRepository": {
      "name": "BreadcrumbRepository",
      "module": "empirica.data.repositories.breadcrumbs",
      "docstring": "Repository for knowledge artifact management (breadcrumbs for continuity)",
      "methods": [
        "log_finding",
        "log_unknown",
        "resolve_unknown",
        "log_dead_end",
        "add_reference_doc",
        "get_project_findings",
        "get_project_unknowns",
        "get_project_dead_ends",
        "get_project_reference_docs",
        "log_mistake",
        "get_mistakes"
      ],
      "bases": [
        "BaseRepository"
      ],
      "decorators": [],
      "line_number": 19
    },
    "empirica.data.repositories.projects.ProjectRepository": {
      "name": "ProjectRepository",
      "module": "empirica.data.repositories.projects",
      "docstring": "Repository for project-level management and context",
      "methods": [
        "create_project",
        "get_project",
        "get_project_by_name",
        "resolve_project_id",
        "link_session_to_project",
        "get_project_sessions",
        "aggregate_project_learning_deltas",
        "create_project_handoff",
        "get_latest_project_handoff"
      ],
      "bases": [
        "BaseRepository"
      ],
      "decorators": [],
      "line_number": 21
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.InvestigationStatus": {
      "name": "InvestigationStatus",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Investigation status types",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 26
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.EvidenceType": {
      "name": "EvidenceType",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Types of evidence",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 36
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.Evidence": {
      "name": "Evidence",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Represents a piece of evidence",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 47
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.InvestigationProtocol": {
      "name": "InvestigationProtocol",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Investigation protocol configuration",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 59
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.AdvancedInvestigationEngine": {
      "name": "AdvancedInvestigationEngine",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Enterprise-grade investigation engine for deep AI behavioral analysis\nProvides multi-source investigation and sophisticated evidence correlation",
      "methods": [
        "__init__",
        "initiate_investigation",
        "collect_evidence",
        "get_investigation_status",
        "get_investigation_report",
        "_execute_investigation",
        "_execute_investigation_step",
        "_collect_behavioral_evidence",
        "_analyze_performance_evidence",
        "_analyze_evidence_correlations",
        "_correlate_all_evidence",
        "_generate_findings",
        "_perform_final_analysis",
        "_assess_investigation_quality",
        "_generate_investigation_summary",
        "_generate_recommendations",
        "_initialize_default_protocols"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 70
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.CorrelationEngine": {
      "name": "CorrelationEngine",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Engine for evidence correlation analysis",
      "methods": [
        "find_correlations",
        "correlate_evidence_set",
        "_calculate_correlation"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 370
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.AnalysisEngine": {
      "name": "AnalysisEngine",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Engine for evidence analysis and finding generation",
      "methods": [
        "generate_findings"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 429
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.SourceType": {
      "name": "SourceType",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Types of investigation sources",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 476
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.MultiSourceAnalyzer": {
      "name": "MultiSourceAnalyzer",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Analyzer for correlating data from multiple sources",
      "methods": [
        "__init__",
        "register_source",
        "analyze_multi_source_data",
        "_convert_source_data_to_evidence"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 485
    },
    "empirica.investigation.advanced_investigation.advanced_investigation.SourceCorrelator": {
      "name": "SourceCorrelator",
      "module": "empirica.investigation.advanced_investigation.advanced_investigation",
      "docstring": "Correlates evidence from different sources",
      "methods": [
        "__init__",
        "add_correlation_rule",
        "correlate_sources",
        "_apply_correlation_rule"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 552
    },
    "empirica.plugins.modality_switcher.genuine_self_assessment.SelfAssessmentPrompt": {
      "name": "SelfAssessmentPrompt",
      "module": "empirica.plugins.modality_switcher.genuine_self_assessment",
      "docstring": "Structured prompt for AI self-assessment",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 38
    },
    "empirica.plugins.modality_switcher.auth_manager.TokenRequest": {
      "name": "TokenRequest",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "docstring": "Request for authentication token",
      "methods": [
        "__post_init__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 24
    },
    "empirica.plugins.modality_switcher.auth_manager.TokenResponse": {
      "name": "TokenResponse",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "docstring": "Response containing authentication token",
      "methods": [
        "__post_init__",
        "is_expired"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 38
    },
    "empirica.plugins.modality_switcher.auth_manager.AuthManager": {
      "name": "AuthManager",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "docstring": "Manages authentication tokens via Sentinel/Cognitive Vault.\n\nPhase 0: Graceful fallback to environment variables when Sentinel unavailable.\nFuture: Full integration with Sentinel API for device flow, ",
      "methods": [
        "__init__",
        "_check_sentinel_availability",
        "get_token",
        "_request_from_sentinel",
        "_request_from_env",
        "revoke_token",
        "clear_cache"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 58
    },
    "empirica.plugins.modality_switcher.auth_manager.AuthenticationError": {
      "name": "AuthenticationError",
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "docstring": "Raised when authentication fails",
      "methods": [],
      "bases": [
        "Exception"
      ],
      "decorators": [],
      "line_number": 295
    },
    "empirica.plugins.modality_switcher.snapshot_provider.EpistemicSnapshotProvider": {
      "name": "EpistemicSnapshotProvider",
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "docstring": "Creates and manages epistemic snapshots\n\nIntegrates with:\n- EmpericaTracker (session state access)\n- SessionDatabase (persistence)\n- epistemic_snapshot.py (data structures)",
      "methods": [
        "__init__",
        "create_snapshot_from_session",
        "save_snapshot",
        "get_latest_snapshot",
        "get_snapshot_by_id",
        "get_snapshot_history",
        "export_snapshot_to_file",
        "import_snapshot_from_file",
        "_extract_vectors_from_assessment",
        "_get_default_vectors",
        "_estimate_original_context_tokens",
        "_estimate_snapshot_tokens",
        "_estimate_fidelity",
        "_estimate_information_loss",
        "_row_to_snapshot"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 48
    },
    "empirica.plugins.modality_switcher.epistemic_router.Modality": {
      "name": "Modality",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "docstring": "Available modalities for routing",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 19
    },
    "empirica.plugins.modality_switcher.epistemic_router.Action": {
      "name": "Action",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "docstring": "Epistemic actions from assessment",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 30
    },
    "empirica.plugins.modality_switcher.epistemic_router.RoutingDecision": {
      "name": "RoutingDecision",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "docstring": "Result of routing decision",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 40
    },
    "empirica.plugins.modality_switcher.epistemic_router.EpistemicRouter": {
      "name": "EpistemicRouter",
      "module": "empirica.plugins.modality_switcher.epistemic_router",
      "docstring": "Routes requests based on 13-vector epistemic assessment\n\nUses:\n- ENGAGEMENT (gate): Must be \u2265 0.60\n- KNOW: Domain knowledge\n- DO: Capability  \n- CONTEXT: Situational awareness\n- CLARITY: Task clarity\n",
      "methods": [
        "__init__",
        "route",
        "_route_by_action",
        "_estimate_cost",
        "_create_decision"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 50
    },
    "empirica.plugins.modality_switcher.config_loader.ConfigLoader": {
      "name": "ConfigLoader",
      "module": "empirica.plugins.modality_switcher.config_loader",
      "docstring": "Load and manage Empirica modality configuration.\n\nConfiguration priority (highest to lowest):\n1. Environment variables (EMPIRICA_*)\n2. User config file (~/.empirica/config.yaml)\n3. Project config file",
      "methods": [
        "__init__",
        "load_config",
        "_load_yaml",
        "_merge_configs",
        "_apply_env_overrides",
        "_parse_env_value",
        "_get_minimal_defaults",
        "get",
        "get_adapter_config",
        "get_routing_config",
        "is_adapter_enabled",
        "get_adapter_costs",
        "get_adapter_latencies",
        "get_adapter_quality",
        "save_user_config",
        "to_dict"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 16
    },
    "empirica.plugins.modality_switcher.usage_monitor.CallRecord": {
      "name": "CallRecord",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "docstring": "Record of a single model call",
      "methods": [
        "__post_init__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 25
    },
    "empirica.plugins.modality_switcher.usage_monitor.BudgetPolicy": {
      "name": "BudgetPolicy",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "docstring": "Budget policy for a provider",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 42
    },
    "empirica.plugins.modality_switcher.usage_monitor.UsageMonitor": {
      "name": "UsageMonitor",
      "module": "empirica.plugins.modality_switcher.usage_monitor",
      "docstring": "Tracks usage and enforces budget policies.\n\nPersists state to JSON file for continuity across sessions.\nConservative defaults prevent runaway costs.",
      "methods": [
        "__init__",
        "_load_state",
        "_save_state",
        "record_call",
        "check_budget",
        "get_usage_summary",
        "reset_stop_flag",
        "set_policy",
        "cleanup_old_records"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 53
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.ContextSummary": {
      "name": "ContextSummary",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "docstring": "Hybrid semantic + narrative context summary",
      "methods": [
        "to_dict",
        "from_dict",
        "to_prompt"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 33
    },
    "empirica.plugins.modality_switcher.epistemic_snapshot.EpistemicStateSnapshot": {
      "name": "EpistemicStateSnapshot",
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "docstring": "Universal epistemic state representation for cross-AI transfer\n\nCore Innovation: Compress full conversation context into epistemic essence\n- 13 universal vectors (0.0-1.0 scale)\n- Delta tracking (what",
      "methods": [
        "to_dict",
        "to_json",
        "from_dict",
        "from_json",
        "to_context_prompt",
        "_minimal_prompt",
        "_standard_prompt",
        "_full_prompt",
        "_format_vectors",
        "_format_delta",
        "_format_domain_vectors",
        "_score_to_bar",
        "calculate_delta",
        "increment_transfer_count",
        "estimate_memory_reliability",
        "should_refresh",
        "get_refresh_reason"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 81
    },
    "empirica.plugins.modality_switcher.modality_switcher.RoutingStrategy": {
      "name": "RoutingStrategy",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "docstring": "Available routing strategies",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 39
    },
    "empirica.plugins.modality_switcher.modality_switcher.RoutingDecision": {
      "name": "RoutingDecision",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "docstring": "Result of routing decision",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 49
    },
    "empirica.plugins.modality_switcher.modality_switcher.RoutingPreferences": {
      "name": "RoutingPreferences",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "docstring": "User preferences for routing",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 60
    },
    "empirica.plugins.modality_switcher.modality_switcher.ModalitySwitcher": {
      "name": "ModalitySwitcher",
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "docstring": "Intelligent adapter routing based on epistemic state and preferences.\n\nRoutes requests to the best adapter (MiniMax, Qwen, Local) considering:\n- Epistemic vectors (KNOW, DO, CONTEXT, UNCERTAINTY)\n- Co",
      "methods": [
        "__init__",
        "route_request",
        "_epistemic_route",
        "_cost_route",
        "_latency_route",
        "_quality_route",
        "_balanced_route",
        "_force_adapter_route",
        "execute_with_routing",
        "_try_fallback",
        "get_usage_stats",
        "reset_usage_stats"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 70
    },
    "empirica.plugins.modality_switcher.plugin_registry.AdapterPayload": {
      "name": "AdapterPayload",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "docstring": "Standard payload sent to all adapters",
      "methods": [
        "__post_init__",
        "get_augmented_prompt"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 25
    },
    "empirica.plugins.modality_switcher.plugin_registry.AdapterResponse": {
      "name": "AdapterResponse",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "docstring": "Standard response from adapters (PersonaEnforcer RESPONSE_SCHEMA)",
      "methods": [
        "__post_init__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 62
    },
    "empirica.plugins.modality_switcher.plugin_registry.AdapterError": {
      "name": "AdapterError",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "docstring": "Error response from adapter",
      "methods": [
        "__post_init__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 87
    },
    "empirica.plugins.modality_switcher.plugin_registry.AdapterInterface": {
      "name": "AdapterInterface",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "docstring": "Protocol defining the required adapter interface.\n\nAll adapters must implement these methods to be registered.",
      "methods": [
        "health_check",
        "authenticate",
        "call"
      ],
      "bases": [
        "Protocol"
      ],
      "decorators": [],
      "line_number": 100
    },
    "empirica.plugins.modality_switcher.plugin_registry.PluginRegistry": {
      "name": "PluginRegistry",
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "docstring": "Manages dynamic adapter discovery and registration.\n\nDiscovers Python modules in adapter directories and validates\nthey conform to the AdapterInterface protocol.",
      "methods": [
        "__init__",
        "register",
        "_validates_interface",
        "discover_adapters",
        "_load_adapter_module",
        "get_adapter",
        "list_adapters",
        "health_check_all"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 145
    },
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.OpenRouterAdapter": {
      "name": "OpenRouterAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "docstring": "Adapter for OpenRouter API calls.\n\nWraps the OpenRouter API and transforms responses to RESPONSE_SCHEMA format.",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 37
    },
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.MinimaxAdapter": {
      "name": "MinimaxAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.minimax_adapter",
      "docstring": "Adapter for MiniMax M2 API via Anthropic SDK",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "stream_call",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 36
    },
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.QodoAdapter": {
      "name": "QodoAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "docstring": "Adapter for Qodo CLI calls.\n\nWraps the Qodo CLI and transforms responses to RESPONSE_SCHEMA format.",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 37
    },
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.RovodevAdapter": {
      "name": "RovodevAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "docstring": "Adapter for Atlassian Rovo Dev CLI via server mode.\n\nUses `acli rovodev serve` to start an HTTP server and communicate via REST API.",
      "methods": [
        "__init__",
        "_start_server",
        "_stop_server",
        "health_check",
        "authenticate",
        "call",
        "_transform_to_schema",
        "__del__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 49
    },
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.GeminiAdapter": {
      "name": "GeminiAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "docstring": "Adapter for Gemini CLI calls.\n\nWraps the Gemini CLI and transforms responses to RESPONSE_SCHEMA format.",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 37
    },
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.CopilotAdapter": {
      "name": "CopilotAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "docstring": "Adapter for GitHub Copilot CLI calls.\n\nWraps the Copilot CLI and transforms responses to RESPONSE_SCHEMA format.\nProvides multi-model access through single subscription.",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "_parse_token_usage",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 51
    },
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.QwenAdapter": {
      "name": "QwenAdapter",
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "docstring": "Adapter for Qwen CLI calls.\n\nWraps the Qwen CLI and transforms responses to RESPONSE_SCHEMA format.",
      "methods": [
        "__init__",
        "health_check",
        "authenticate",
        "call",
        "_transform_to_schema"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 39
    },
    "empirica.core.git_ops.signed_operations.SignedGitOperations": {
      "name": "SignedGitOperations",
      "module": "empirica.core.git_ops.signed_operations",
      "docstring": "Store and verify signed epistemic states in Git\n\nCreates an immutable, verifiable audit trail of AI reasoning by:\n1. Signing epistemic states with persona's Ed25519 key\n2. Storing signatures in git no",
      "methods": [
        "__init__",
        "commit_signed_state",
        "get_signed_state_from_commit",
        "verify_cascade_chain",
        "export_cascade_report",
        "_validate_cascade_phase",
        "_get_last_cascade_phase",
        "get_cascade_timeline"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 53
    },
    "empirica.core.persona.signing_persona.SigningPersona": {
      "name": "SigningPersona",
      "module": "empirica.core.persona.signing_persona",
      "docstring": "Bind a Persona Profile to a Cryptographic Identity\n\nThis class creates the connection between:\n- PersonaProfile: The epistemic behavior definition (13 vectors)\n- AIIdentity: The Ed25519 keypair for si",
      "methods": [
        "__init__",
        "_create_canonical_state",
        "sign_epistemic_state",
        "verify_signature",
        "get_persona_info",
        "export_public_persona"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 39
    },
    "empirica.core.persona.persona_manager.PersonaManager": {
      "name": "PersonaManager",
      "module": "empirica.core.persona.persona_manager",
      "docstring": "Manages persona lifecycle: create, load, save, validate\n\nUsage:\n    manager = PersonaManager()\n\n    # Create new persona\n    profile = manager.create_persona(\n        persona_id=\"security_expert\",\n   ",
      "methods": [
        "__init__",
        "create_persona",
        "save_persona",
        "load_persona",
        "list_personas",
        "delete_persona",
        "get_persona_type",
        "_get_or_create_signing_identity",
        "_get_default_priors",
        "_create_from_template"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 22
    },
    "empirica.core.persona.persona_profile.SigningIdentityConfig": {
      "name": "SigningIdentityConfig",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "Configuration for persona's cryptographic identity (Phase 2 integration)",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 18
    },
    "empirica.core.persona.persona_profile.EpistemicConfig": {
      "name": "EpistemicConfig",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "Epistemic configuration for a persona",
      "methods": [
        "__post_init__",
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 29
    },
    "empirica.core.persona.persona_profile.CapabilitiesConfig": {
      "name": "CapabilitiesConfig",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "What this persona can/cannot do",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 80
    },
    "empirica.core.persona.persona_profile.EscalationTrigger": {
      "name": "EscalationTrigger",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "Condition that triggers Sentinel intervention",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 94
    },
    "empirica.core.persona.persona_profile.SentinelConfig": {
      "name": "SentinelConfig",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "How Sentinel should manage this persona",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 104
    },
    "empirica.core.persona.persona_profile.PersonaMetadata": {
      "name": "PersonaMetadata",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "Metadata about the persona",
      "methods": [
        "__post_init__",
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 119
    },
    "empirica.core.persona.persona_profile.PersonaProfile": {
      "name": "PersonaProfile",
      "module": "empirica.core.persona.persona_profile",
      "docstring": "Complete persona profile for Phase 3 multi-persona intelligence\n\nA persona is a specialized AI agent with:\n- Domain-specific epistemic priors (starting knowledge)\n- Custom thresholds and weights\n- Foc",
      "methods": [
        "__post_init__",
        "to_dict",
        "_parse_sentinel_config",
        "from_dict",
        "get_type"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 141
    },
    "empirica.core.persona.validation.ValidationError": {
      "name": "ValidationError",
      "module": "empirica.core.persona.validation",
      "docstring": "Raised when persona profile validation fails",
      "methods": [],
      "bases": [
        "Exception"
      ],
      "decorators": [],
      "line_number": 15
    },
    "empirica.core.goals.repository.GoalRepository": {
      "name": "GoalRepository",
      "module": "empirica.core.goals.repository",
      "docstring": "Database operations for Goal persistence",
      "methods": [
        "__init__",
        "_ensure_tables",
        "save_goal",
        "get_goal",
        "get_session_goals",
        "update_goal_completion",
        "query_goals",
        "close"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 20
    },
    "empirica.core.goals.types.ScopeVector": {
      "name": "ScopeVector",
      "module": "empirica.core.goals.types",
      "docstring": "Goal scope as epistemic vectors (AI self-assesses, Sentinel validates coherence)\n\nReplaces categorical enum with numeric dimensions for genuine AI assessment.",
      "methods": [
        "__post_init__",
        "to_dict",
        "from_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 17
    },
    "empirica.core.goals.types.DependencyType": {
      "name": "DependencyType",
      "module": "empirica.core.goals.types",
      "docstring": "Dependency relationship types",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 54
    },
    "empirica.core.goals.types.SuccessCriterion": {
      "name": "SuccessCriterion",
      "module": "empirica.core.goals.types",
      "docstring": "Measurable success criterion for goal completion",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 62
    },
    "empirica.core.goals.types.Dependency": {
      "name": "Dependency",
      "module": "empirica.core.goals.types",
      "docstring": "Goal dependency specification",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 73
    },
    "empirica.core.goals.types.Goal": {
      "name": "Goal",
      "module": "empirica.core.goals.types",
      "docstring": "Structured goal representation\n\nMVP Design: AI creates goals explicitly via MCP tools.\nNo automatic parsing - keeps it simple and heuristic-free.",
      "methods": [
        "create",
        "to_dict",
        "from_dict",
        "get_subtasks",
        "calculate_progress",
        "is_ready_for_completion"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 82
    },
    "empirica.core.goals.decision_logic.GoalDecision": {
      "name": "GoalDecision",
      "module": "empirica.core.goals.decision_logic",
      "docstring": "Result of goal creation decision logic\n\nThis is GUIDANCE, not prescription. AI can override.",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 22
    },
    "empirica.core.goals.validation.ValidationError": {
      "name": "ValidationError",
      "module": "empirica.core.goals.validation",
      "docstring": "Custom exception for validation errors",
      "methods": [],
      "bases": [
        "Exception"
      ],
      "decorators": [],
      "line_number": 16
    },
    "empirica.core.drift.mirror_drift_monitor.DriftReport": {
      "name": "DriftReport",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "docstring": "Result of drift detection with pattern-aware analysis",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 21
    },
    "empirica.core.drift.mirror_drift_monitor.MirrorDriftMonitor": {
      "name": "MirrorDriftMonitor",
      "module": "empirica.core.drift.mirror_drift_monitor",
      "docstring": "Drift detection using temporal self-validation\n\nCompares current epistemic state to historical baselines from\nGit checkpoints. Detects unexpected drops in epistemic vectors\nthat indicate memory corrup",
      "methods": [
        "__init__",
        "detect_drift",
        "_load_recent_checkpoints",
        "_calculate_baseline",
        "_compare_states",
        "_extract_vectors",
        "_classify_drift_severity",
        "_classify_overall_severity",
        "_recommend_action",
        "_log_drift",
        "_classify_drift_pattern"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 34
    },
    "empirica.core.schemas.epistemic_assessment.AssessmentType": {
      "name": "AssessmentType",
      "module": "empirica.core.schemas.epistemic_assessment",
      "docstring": "Explicit epistemic assessment checkpoints.\n\nThese represent the three explicit assessment moments in the CASCADE workflow:\n- PRE: Baseline epistemic state at session start (was PREFLIGHT)\n- CHECK: Dec",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 21
    },
    "empirica.core.schemas.epistemic_assessment.CascadePhase": {
      "name": "CascadePhase",
      "module": "empirica.core.schemas.epistemic_assessment",
      "docstring": "DEPRECATED: Use AssessmentType instead.\n\nCASCADE workflow phases. This enum is deprecated in favor of AssessmentType\nwhich distinguishes explicit assessment checkpoints (PRE/CHECK/POST) from\nimplicit ",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 38
    },
    "empirica.core.schemas.epistemic_assessment.VectorAssessment": {
      "name": "VectorAssessment",
      "module": "empirica.core.schemas.epistemic_assessment",
      "docstring": "Single epistemic vector assessment\n\nAttributes:\n    score: Confidence/assessment value (0.0-1.0)\n    rationale: GENUINE reasoning (not template, not heuristic)\n    evidence: Optional supporting facts\n",
      "methods": [
        "__post_init__",
        "to_dict",
        "from_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 63
    },
    "empirica.core.schemas.epistemic_assessment.EpistemicAssessmentSchema": {
      "name": "EpistemicAssessmentSchema",
      "module": "empirica.core.schemas.epistemic_assessment",
      "docstring": "Canonical 13-vector epistemic assessment\n\nThis is THE format for all epistemic assessments across:\n- PREFLIGHT, THINK, INVESTIGATE, CHECK, ACT, POSTFLIGHT phases\n- CLI commands, MCP tools, PersonaHarn",
      "methods": [
        "to_nested_dict",
        "to_flat_dict",
        "from_nested_dict",
        "apply_persona_priors",
        "calculate_tier_confidences",
        "determine_action",
        "know",
        "do",
        "context",
        "clarity",
        "coherence",
        "signal",
        "density",
        "state",
        "change",
        "completion",
        "impact",
        "engagement_gate_passed",
        "assessment_id",
        "foundation_confidence",
        "comprehension_confidence",
        "execution_confidence",
        "overall_confidence",
        "recommended_action",
        "coherence_critical",
        "density_critical",
        "change_critical"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 111
    },
    "empirica.core.canonical.canonical_epistemic_assessment.CanonicalEpistemicAssessor": {
      "name": "CanonicalEpistemicAssessor",
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "docstring": "Canonical LLM-powered epistemic self-assessor\n\nThis assessor uses genuine AI reasoning to evaluate epistemic state\nacross 12 vectors organized into 4 tiers.\n\nNO HEURISTICS. NO KEYWORD MATCHING. NO CON",
      "methods": [
        "__init__",
        "_generate_assessment_id",
        "_build_self_assessment_prompt",
        "_format_context",
        "_build_self_assessment_template_for_mapping",
        "parse_llm_response",
        "_determine_action"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 50
    },
    "empirica.core.canonical.git_enhanced_reflex_logger.GitEnhancedReflexLogger": {
      "name": "GitEnhancedReflexLogger",
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "docstring": "Epistemic checkpoint logger with 3-layer storage.\n\nStorage Architecture:\n- SQLite: Queryable checkpoints (fallback)\n- Git Notes: Compressed (~450 tokens), distributed, signable\n- JSON Logs: Full audit",
      "methods": [
        "__init__",
        "git_enabled",
        "_check_git_available",
        "add_checkpoint",
        "_create_checkpoint",
        "_estimate_token_count",
        "_capture_git_state",
        "_get_commits_since_last_checkpoint",
        "_get_uncommitted_changes",
        "_calculate_learning_delta",
        "_save_checkpoint_to_sqlite",
        "_git_add_note",
        "_git_add_signed_note",
        "get_last_checkpoint",
        "_git_get_latest_note",
        "_git_get_latest_note_new",
        "_load_checkpoint_from_sqlite",
        "_is_fresh",
        "list_checkpoints",
        "get_vector_diff"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 49
    },
    "empirica.core.canonical.goal_orchestrator_bridge.GoalOrchestratorBridge": {
      "name": "GoalOrchestratorBridge",
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "docstring": "Bridge between LLM-driven goal generation and structured goal management\n\nAllows autonomous agents to generate goals via LLM, then track them\nwith the new structured architecture.",
      "methods": [
        "__init__",
        "_convert_to_structured_goal",
        "_map_priority_to_complexity",
        "create_goal_from_decision",
        "close"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 31
    },
    "empirica.core.canonical.reflex_frame.Action": {
      "name": "Action",
      "module": "empirica.core.canonical.reflex_frame",
      "docstring": "Metacognitive action decisions",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 29
    },
    "empirica.core.canonical.reflex_frame.VectorState": {
      "name": "VectorState",
      "module": "empirica.core.canonical.reflex_frame",
      "docstring": "Individual epistemic vector measurement\n\nRepresents a single dimension of self-awareness with:\n- score: 0.0-1.0 measurement\n- rationale: genuine AI reasoning (NOT heuristics)\n- evidence: supporting co",
      "methods": [
        "__post_init__",
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 39
    },
    "empirica.core.canonical.canonical_goal_orchestrator.GoalPriority": {
      "name": "GoalPriority",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "Goal priority levels",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 54
    },
    "empirica.core.canonical.canonical_goal_orchestrator.GoalAutonomyLevel": {
      "name": "GoalAutonomyLevel",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "How much autonomy AI has for this goal",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 63
    },
    "empirica.core.canonical.canonical_goal_orchestrator.Goal": {
      "name": "Goal",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "A single goal with LLM-generated reasoning",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 72
    },
    "empirica.core.canonical.canonical_goal_orchestrator.CanonicalGoalOrchestrator": {
      "name": "CanonicalGoalOrchestrator",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "LLM-powered goal orchestration with ENGAGEMENT-driven autonomy\n\nNO heuristics, NO keyword matching, NO hardcoded templates.\nPure LLM reasoning based on epistemic assessment.",
      "methods": [
        "__init__",
        "_build_goal_orchestration_prompt",
        "_format_epistemic_state",
        "_get_goal_generation_instructions",
        "_placeholder_goal_generation",
        "_parse_llm_goal_response"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 104
    },
    "empirica.core.canonical.canonical_goal_orchestrator.MockAssessment": {
      "name": "MockAssessment",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "",
      "methods": [
        "__init__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 501
    },
    "empirica.core.canonical.canonical_goal_orchestrator.Vector": {
      "name": "Vector",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "",
      "methods": [],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 506
    },
    "empirica.core.canonical.canonical_goal_orchestrator.ActionEnum": {
      "name": "ActionEnum",
      "module": "empirica.core.canonical.canonical_goal_orchestrator",
      "docstring": "",
      "methods": [],
      "bases": [],
      "decorators": [],
      "line_number": 524
    },
    "empirica.core.canonical.reflex_logger.ReflexLogger": {
      "name": "ReflexLogger",
      "module": "empirica.core.canonical.reflex_logger",
      "docstring": "Temporal logger for Reflex Frames - JSON logging only.\n\nLogs epistemic assessments to JSON files, enabling temporal separation\nbetween current reasoning and historical analysis.\n\nFor 3-layer storage, ",
      "methods": [
        "__init__",
        "_ensure_log_directory",
        "_get_agent_log_dir",
        "_generate_log_filename",
        "log_frame_sync",
        "get_recent_frames_sync",
        "get_assessment_history",
        "cleanup_old_logs"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 36
    },
    "empirica.core.completion.git_query.GitProgressQuery": {
      "name": "GitProgressQuery",
      "module": "empirica.core.completion.git_query",
      "docstring": "Query git notes for team progress tracking\n\nLead AI can query git to see what agents accomplished, when, and why.\nCombines task metadata with commit history for unified timeline.",
      "methods": [
        "__init__",
        "_check_git_available",
        "get_goal_timeline",
        "_get_task_note",
        "get_team_progress",
        "get_unified_timeline",
        "get_recent_activity"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 20
    },
    "empirica.core.completion.types.CompletionRecord": {
      "name": "CompletionRecord",
      "module": "empirica.core.completion.types",
      "docstring": "Completion status for a goal\n\nTracks progress, completed/remaining tasks, and evidence.",
      "methods": [
        "to_dict",
        "from_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 15
    },
    "empirica.core.completion.types.CompletionMetrics": {
      "name": "CompletionMetrics",
      "module": "empirica.core.completion.types",
      "docstring": "Aggregate completion metrics across goals\n\nUseful for session-level or project-level tracking.",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 62
    },
    "empirica.core.completion.tracker.CompletionTracker": {
      "name": "CompletionTracker",
      "module": "empirica.core.completion.tracker",
      "docstring": "Track goal and task completion with evidence mapping\n\nMVP: Simple completion percentage calculation based on task status.\nPhase 2: Git notes integration for task metadata storage.",
      "methods": [
        "__init__",
        "track_progress",
        "auto_update_completion",
        "record_subtask_completion",
        "get_session_metrics",
        "auto_update_from_recent_commits",
        "_check_git_available",
        "_add_task_note",
        "close"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 25
    },
    "empirica.core.handoff.report_generator.EpistemicHandoffReportGenerator": {
      "name": "EpistemicHandoffReportGenerator",
      "module": "empirica.core.handoff.report_generator",
      "docstring": "Generate compressed epistemic handoff reports for session resumption\n\nCombines:\n- Vector deltas (what changed epistemically)\n- Key learnings (what was discovered)\n- Context (what next AI needs to know",
      "methods": [
        "__init__",
        "generate_handoff_report",
        "generate_planning_handoff",
        "_get_preflight_assessment",
        "_get_postflight_assessment",
        "_calculate_deltas",
        "_check_calibration",
        "_heuristic_calibration_check",
        "_identify_filled_gaps",
        "_extract_investigation_tools",
        "_generate_recommendations",
        "_get_session_metadata",
        "_calculate_duration",
        "_generate_markdown",
        "_build_delta_table",
        "_format_gaps",
        "_compress_report",
        "_compress_planning_handoff"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 28
    },
    "empirica.core.handoff.storage.GitHandoffStorage": {
      "name": "GitHandoffStorage",
      "module": "empirica.core.handoff.storage",
      "docstring": "Store handoff reports in git notes",
      "methods": [
        "__init__",
        "store_handoff",
        "load_handoff",
        "list_handoffs",
        "_get_note_sha"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 25
    },
    "empirica.core.handoff.storage.DatabaseHandoffStorage": {
      "name": "DatabaseHandoffStorage",
      "module": "empirica.core.handoff.storage",
      "docstring": "Store handoff reports in session database",
      "methods": [
        "__init__",
        "_create_table",
        "store_handoff",
        "load_handoff",
        "query_handoffs",
        "_row_to_dict",
        "list_handoffs"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 202
    },
    "empirica.core.handoff.storage.HybridHandoffStorage": {
      "name": "HybridHandoffStorage",
      "module": "empirica.core.handoff.storage",
      "docstring": "Dual storage for handoff reports: Git notes + Database\n\nStrategy:\n- Git notes: Distributed, repo-portable, survives repo clones\n- Database: Fast queries, AI ID indexing, relational integrity\n\nBoth sto",
      "methods": [
        "__init__",
        "store_handoff",
        "load_handoff",
        "query_handoffs",
        "list_handoffs",
        "check_sync_status"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 411
    },
    "empirica.core.qdrant.persona_registry.PersonaRegistry": {
      "name": "PersonaRegistry",
      "module": "empirica.core.qdrant.persona_registry",
      "docstring": "Store and discover personas in Qdrant vector database\n\nUses 13D epistemic vectors for semantic search and filtering.\nEach persona is registered with:\n- Epistemic priors (13 vectors)\n- Public key (for ",
      "methods": [
        "__init__",
        "_ensure_collection",
        "register_persona",
        "find_personas_by_domain",
        "find_personas_by_tag",
        "find_similar_personas",
        "get_persona_by_id",
        "list_all_personas",
        "get_personas_by_type",
        "get_personas_by_reputation",
        "delete_persona",
        "get_registry_stats",
        "_persona_id_to_point_id",
        "_point_to_persona_dict"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 42
    },
    "empirica.core.qdrant.embeddings.EmbeddingsProvider": {
      "name": "EmbeddingsProvider",
      "module": "empirica.core.qdrant.embeddings",
      "docstring": "",
      "methods": [
        "__init__",
        "embed"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 22
    },
    "empirica.core.tasks.repository.TaskRepository": {
      "name": "TaskRepository",
      "module": "empirica.core.tasks.repository",
      "docstring": "Database operations for Task persistence",
      "methods": [
        "__init__",
        "_ensure_tables",
        "save_subtask",
        "get_subtask",
        "get_goal_subtasks",
        "update_subtask_status",
        "save_decomposition",
        "get_decomposition",
        "query_subtasks",
        "close"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 20
    },
    "empirica.core.tasks.types.EpistemicImportance": {
      "name": "EpistemicImportance",
      "module": "empirica.core.tasks.types",
      "docstring": "Task importance from epistemic perspective",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 16
    },
    "empirica.core.tasks.types.TaskStatus": {
      "name": "TaskStatus",
      "module": "empirica.core.tasks.types",
      "docstring": "Task completion status",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 24
    },
    "empirica.core.tasks.types.SubTask": {
      "name": "SubTask",
      "module": "empirica.core.tasks.types",
      "docstring": "Individual subtask within a goal\n\nMVP Design: AI creates these explicitly via MCP tools.",
      "methods": [
        "create",
        "to_dict",
        "from_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 34
    },
    "empirica.core.tasks.types.TaskDecomposition": {
      "name": "TaskDecomposition",
      "module": "empirica.core.tasks.types",
      "docstring": "Complete task breakdown for a goal\n\nMVP: Simple container for manually created subtasks.\nFuture: Add automatic decomposition, critical path analysis, etc.",
      "methods": [
        "to_dict",
        "from_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 120
    },
    "empirica.core.validation.rehydration.EpistemicRehydration": {
      "name": "EpistemicRehydration",
      "module": "empirica.core.validation.rehydration",
      "docstring": "Next AI rehydrates context from previous checkpoint",
      "methods": [
        "__init__",
        "rehydrate_from_checkpoint",
        "_identify_rehydration_warnings",
        "_format_rehydration_message",
        "calculate_adjusted_preflight"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 23
    },
    "empirica.core.validation.coherence_validator.CoherenceValidator": {
      "name": "CoherenceValidator",
      "module": "empirica.core.validation.coherence_validator",
      "docstring": "Validates AI's work coherence before handing off",
      "methods": [
        "__init__",
        "validate_before_handoff",
        "_check_scope_match",
        "_check_trajectory",
        "_check_findings_honesty",
        "_format_message"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 21
    },
    "empirica.core.validation.handoff_validator.HandoffValidator": {
      "name": "HandoffValidator",
      "module": "empirica.core.validation.handoff_validator",
      "docstring": "Validates incoming checkpoint quality and coherence",
      "methods": [
        "__init__",
        "validate_handoff",
        "_check_claim_vs_reality",
        "_check_findings_credibility",
        "_check_unknowns_reasonableness",
        "_check_overall_coherence",
        "_format_validation_message"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 23
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.InvestigationPlugin": {
      "name": "InvestigationPlugin",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "docstring": "Plugin interface for custom investigation tools\n\nAttributes:\n    name: Unique identifier for the tool\n    description: Clear explanation of what the tool does (shown to LLM)\n    improves_vectors: Whic",
      "methods": [
        "__post_init__",
        "to_capability_dict",
        "__repr__"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 34
    },
    "empirica.core.metacognitive_cascade.investigation_plugin.PluginRegistry": {
      "name": "PluginRegistry",
      "module": "empirica.core.metacognitive_cascade.investigation_plugin",
      "docstring": "Registry for managing investigation plugins\n\nProvides convenient methods for registering, discovering, and using plugins.",
      "methods": [
        "__init__",
        "register",
        "unregister",
        "get",
        "list_plugins",
        "get_all_capabilities",
        "find_by_vector",
        "__len__",
        "__repr__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 133
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.CascadePhase": {
      "name": "CascadePhase",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "docstring": "DEPRECATED: Use AssessmentType from epistemic_assessment.py instead.\n\nEnhanced 7-phase cascade workflow. This enum is deprecated in favor of \nAssessmentType which distinguishes explicit assessment che",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 91
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.CanonicalCascadeState": {
      "name": "CanonicalCascadeState",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "docstring": "Current state in the canonical epistemic cascade.\n\nPhase 1 Migration: Both old (current_phase) and new (current_assessment) fields\nare maintained for backward compatibility. New code should use curren",
      "methods": [
        "to_json",
        "_extract_vector_summary"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 117
    },
    "empirica.core.metacognitive_cascade.metacognitive_cascade.CanonicalEpistemicCascade": {
      "name": "CanonicalEpistemicCascade",
      "module": "empirica.core.metacognitive_cascade.metacognitive_cascade",
      "docstring": "Canonical adaptive cascade using genuine LLM-powered self-assessment\n\nArchitecture:\n- ENGAGEMENT gate enforced (\u22650.60)\n- Canonical weights: 35/25/25/15\n- Reflex Frame logging for temporal separation\n-",
      "methods": [
        "__init__",
        "_parse_vectors_to_assessment",
        "_identify_knowledge_gaps",
        "_identify_epistemic_gaps",
        "_build_tool_capability_map",
        "_classify_tool_type",
        "_get_standard_tool_capabilities",
        "_get_empirica_tool_capabilities",
        "update_from_tool_execution",
        "_verify_readiness",
        "_make_final_decision",
        "_build_decision_rationale",
        "_extract_vector_summary",
        "_generate_execution_guidance",
        "_calculate_epistemic_delta",
        "_check_calibration_accuracy",
        "_generate_task_id",
        "_enter_phase",
        "_update_tmux_display"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 179
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.Domain": {
      "name": "Domain",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Task domain categories",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 28
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.ToolRecommendation": {
      "name": "ToolRecommendation",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Tool recommendation with reasoning",
      "methods": [
        "__init__",
        "to_dict"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 37
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.BaseInvestigationStrategy": {
      "name": "BaseInvestigationStrategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Base class for investigation strategies\n\nSubclasses implement domain-specific tool recommendation logic.",
      "methods": [
        "__init__",
        "_extract_gaps",
        "_prioritize_gaps"
      ],
      "bases": [
        "ABC"
      ],
      "decorators": [],
      "line_number": 64
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.CodeAnalysisStrategy": {
      "name": "CodeAnalysisStrategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Investigation strategy for code analysis tasks\n\nMaps gaps to code-specific tools:\n- know \u2192 search, documentation, codebase exploration\n- do \u2192 tool availability checks\n- context \u2192 workspace scanning, g",
      "methods": [],
      "bases": [
        "BaseInvestigationStrategy"
      ],
      "decorators": [],
      "line_number": 166
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.ResearchStrategy": {
      "name": "ResearchStrategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Investigation strategy for research tasks\n\nMaps gaps to research-specific tools:\n- know \u2192 web search, documentation fetch, knowledge retrieval\n- context \u2192 historical context, related work\n- clarity \u2192 ",
      "methods": [],
      "bases": [
        "BaseInvestigationStrategy"
      ],
      "decorators": [],
      "line_number": 250
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.CollaborativeStrategy": {
      "name": "CollaborativeStrategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Investigation strategy for collaborative tasks\n\nMaps gaps to collaboration-specific tools:\n- engagement \u2192 goal creation, shared understanding\n- clarity \u2192 interactive clarification\n- coherence \u2192 contex",
      "methods": [],
      "bases": [
        "BaseInvestigationStrategy"
      ],
      "decorators": [],
      "line_number": 305
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.GeneralStrategy": {
      "name": "GeneralStrategy",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "General-purpose investigation strategy\n\nFalls back to standard gap\u2192tool mapping when domain is unclear.",
      "methods": [],
      "bases": [
        "BaseInvestigationStrategy"
      ],
      "decorators": [],
      "line_number": 360
    },
    "empirica.core.metacognitive_cascade.investigation_strategy.StrategySelector": {
      "name": "StrategySelector",
      "module": "empirica.core.metacognitive_cascade.investigation_strategy",
      "docstring": "Selects appropriate investigation strategy based on domain\n\nSupports plugin-based extension: register custom strategies for new domains.\n\nUsage:\n    selector = StrategySelector()\n    \n    # Use built-",
      "methods": [
        "__init__",
        "register_strategy",
        "get_strategy",
        "list_domains",
        "infer_domain"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 409
    },
    "empirica.core.identity.ai_identity.AIIdentity": {
      "name": "AIIdentity",
      "module": "empirica.core.identity.ai_identity",
      "docstring": "AI Identity with Ed25519 keypair\n\nUsage:\n    # Create new identity\n    identity = AIIdentity(ai_id=\"claude-code\")\n    identity.generate_keypair()\n    identity.save_keypair()\n    \n    # Load existing i",
      "methods": [
        "__init__",
        "keypair_path",
        "public_key_path",
        "generate_keypair",
        "save_keypair",
        "load_keypair",
        "sign",
        "verify",
        "public_key_hex",
        "export_public_key"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 35
    },
    "empirica.core.identity.ai_identity.IdentityManager": {
      "name": "IdentityManager",
      "module": "empirica.core.identity.ai_identity",
      "docstring": "Manage multiple AI identities\n\nUsage:\n    manager = IdentityManager()\n    \n    # List identities\n    identities = manager.list_identities()\n    \n    # Load identity\n    identity = manager.load_identit",
      "methods": [
        "__init__",
        "list_identities",
        "load_identity",
        "create_identity",
        "identity_exists"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 261
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.SentinelDecision": {
      "name": "SentinelDecision",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "docstring": "Sentinel routing decisions",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 26
    },
    "empirica.core.canonical.empirica_git.sentinel_hooks.SentinelHooks": {
      "name": "SentinelHooks",
      "module": "empirica.core.canonical.empirica_git.sentinel_hooks",
      "docstring": "Sentinel integration hooks for epistemic decision-making\n\nUsage:\n    # In cognitive_vault Sentinel service\n    from empirica.core.canonical.empirica_git import SentinelHooks\n    \n    def my_sentinel_e",
      "methods": [
        "register_evaluator",
        "clear_evaluators",
        "is_enabled",
        "evaluate_checkpoint",
        "post_checkpoint_hook",
        "_log_decision"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 35
    },
    "empirica.core.canonical.empirica_git.session_sync.SessionSync": {
      "name": "SessionSync",
      "module": "empirica.core.canonical.empirica_git.session_sync",
      "docstring": "Git synchronization for session state\n\nDesign:\n- Pull latest checkpoints before resume\n- Push checkpoints after creation (optional)\n- Detect and handle conflicts\n- Safe degradation if git unavailable",
      "methods": [
        "__init__",
        "_check_git_repo",
        "_check_remote",
        "pull_latest",
        "push_checkpoint",
        "auto_sync_before_resume",
        "auto_sync_after_checkpoint"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 22
    },
    "empirica.core.canonical.empirica_git.checkpoint_manager.CheckpointManager": {
      "name": "CheckpointManager",
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "docstring": "Manages automatic git checkpoints for CASCADE phases\n\nDesign:\n- Detects git repo automatically\n- Creates checkpoints in git notes (refs/notes/empirica/checkpoints)\n- Compresses epistemic state (~85% t",
      "methods": [
        "__init__",
        "_check_git_repo",
        "is_enabled",
        "auto_checkpoint",
        "_create_checkpoint",
        "load_checkpoint",
        "_load_checkpoint_by_hash",
        "load_recent_checkpoints",
        "_find_latest_checkpoint"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 25
    },
    "empirica.core.canonical.empirica_git.goal_store.GitGoalStore": {
      "name": "GitGoalStore",
      "module": "empirica.core.canonical.empirica_git.goal_store",
      "docstring": "Git-based goal storage for cross-AI coordination\n\nStorage Format (git notes):\n    refs/notes/empirica/goals/<goal-id>\n    \nGoal Data:\n    {\n        \"goal_id\": \"uuid\",\n        \"session_id\": \"abc123\",\n ",
      "methods": [
        "__init__",
        "_check_git_repo",
        "store_goal",
        "load_goal",
        "discover_goals",
        "add_lineage"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 24
    },
    "empirica.core.persona.harness.persona_harness.PersonaHarness": {
      "name": "PersonaHarness",
      "module": "empirica.core.persona.harness.persona_harness",
      "docstring": "Runtime container for persona execution\n\nWraps CASCADE with persona-specific:\n- Priors (initial epistemic state)\n- Thresholds (uncertainty_trigger, confidence_to_proceed)\n- Weights (foundation/compreh",
      "methods": [
        "__init__",
        "_create_persona_cascade",
        "_create_persona_aware_assessment",
        "_apply_priors",
        "_select_investigation_profile",
        "_interpret_with_persona",
        "_extract_persona_findings",
        "_generate_persona_recommendation",
        "get_persona_info"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 45
    },
    "empirica.core.persona.harness.communication.MessageType": {
      "name": "MessageType",
      "module": "empirica.core.persona.harness.communication",
      "docstring": "Types of messages in Persona-Sentinel communication",
      "methods": [],
      "bases": [
        "Enum"
      ],
      "decorators": [],
      "line_number": 21
    },
    "empirica.core.persona.harness.communication.SentinelMessage": {
      "name": "SentinelMessage",
      "module": "empirica.core.persona.harness.communication",
      "docstring": "Message from SentinelOrchestrator to PersonaHarness\n\nExample:\n    msg = SentinelMessage(\n        message_type=MessageType.TASK_ASSIGNMENT,\n        persona_id=\"security_expert\",\n        payload={\n     ",
      "methods": [
        "to_dict",
        "from_dict",
        "sign"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 38
    },
    "empirica.core.persona.harness.communication.PersonaMessage": {
      "name": "PersonaMessage",
      "module": "empirica.core.persona.harness.communication",
      "docstring": "Message from PersonaHarness to SentinelOrchestrator\n\nExample:\n    msg = PersonaMessage(\n        message_type=MessageType.STATUS_REPORT,\n        persona_id=\"security_expert\",\n        payload={\n        ",
      "methods": [
        "to_dict",
        "from_dict",
        "sign"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 111
    },
    "empirica.core.persona.sentinel.sentinel_orchestrator.SentinelOrchestrator": {
      "name": "SentinelOrchestrator",
      "module": "empirica.core.persona.sentinel.sentinel_orchestrator",
      "docstring": "Multi-persona orchestration for epistemic assessment\n\nCoordinates PersonaHarness instances to get multi-perspective assessment,\nthen composes and arbitrates results using COMPOSE and ARBITRATE operati",
      "methods": [
        "__init__",
        "_load_persona_profiles",
        "_create_persona_harnesses",
        "_compose_assessments",
        "_extract_actions_and_confidences",
        "_arbitrate_conflicts",
        "_calculate_agreement_score",
        "_detect_conflicts"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 39
    },
    "empirica.core.persona.sentinel.orchestration_result.ArbitrationResult": {
      "name": "ArbitrationResult",
      "module": "empirica.core.persona.sentinel.orchestration_result",
      "docstring": "Result of conflict arbitration between personas\n\nWhen personas disagree on recommended action (e.g., security says\nINVESTIGATE, UX says PROCEED), arbitration resolves the conflict.",
      "methods": [
        "to_dict"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 16
    },
    "empirica.core.persona.sentinel.orchestration_result.OrchestrationResult": {
      "name": "OrchestrationResult",
      "module": "empirica.core.persona.sentinel.orchestration_result",
      "docstring": "Complete result of multi-persona orchestration\n\nContains:\n- Composed assessment (merged from all personas)\n- Individual persona assessments\n- Arbitration result (conflict resolution)\n- Metadata and me",
      "methods": [
        "to_dict",
        "get_summary"
      ],
      "bases": [],
      "decorators": [
        "dataclass"
      ],
      "line_number": 57
    },
    "empirica.integrations.beads.config.BeadsConfig": {
      "name": "BeadsConfig",
      "module": "empirica.integrations.beads.config",
      "docstring": "BEADS integration configuration",
      "methods": [
        "__init__",
        "_load_config",
        "_default_config",
        "enabled",
        "auto_detect",
        "use_agent_mail",
        "agent_mail_url",
        "agent_name",
        "save"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 15
    },
    "empirica.integrations.beads.adapter.BeadsAdapter": {
      "name": "BeadsAdapter",
      "module": "empirica.integrations.beads.adapter",
      "docstring": "Subprocess-based BEADS integration",
      "methods": [
        "__init__",
        "is_available",
        "create_issue",
        "add_dependency",
        "get_ready_work",
        "update_status",
        "close_issue",
        "get_issue",
        "get_dependency_tree"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 16
    },
    "empirica.cli.command_handlers.monitor_commands.UsageMonitor": {
      "name": "UsageMonitor",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "docstring": "Track and display adapter usage statistics.\n\nMonitors:\n- Request counts per adapter\n- Total costs\n- Average latency\n- Success/failure rates",
      "methods": [
        "__init__",
        "_load_stats",
        "_save_stats",
        "record_request",
        "get_stats",
        "reset_stats"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 24
    },
    "empirica.cli.command_handlers.monitor_commands.MockAssessment": {
      "name": "MockAssessment",
      "module": "empirica.cli.command_handlers.monitor_commands",
      "docstring": "",
      "methods": [
        "__init__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 428
    },
    "empirica.cli.command_handlers.goal_claim_command.MockArgs": {
      "name": "MockArgs",
      "module": "empirica.cli.command_handlers.goal_claim_command",
      "docstring": "",
      "methods": [
        "__init__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 144
    },
    "empirica.cli.command_handlers.goal_complete_command.MockArgs": {
      "name": "MockArgs",
      "module": "empirica.cli.command_handlers.goal_complete_command",
      "docstring": "",
      "methods": [
        "__init__"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 183
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.VerificationSigner": {
      "name": "VerificationSigner",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "docstring": "Minimal signer for verification only - doesn't need identity",
      "methods": [
        "__init__"
      ],
      "bases": [
        "CheckpointSigner"
      ],
      "decorators": [],
      "line_number": 118
    },
    "empirica.cli.command_handlers.checkpoint_signing_commands.ListSigner": {
      "name": "ListSigner",
      "module": "empirica.cli.command_handlers.checkpoint_signing_commands",
      "docstring": "Minimal signer for listing only - doesn't need identity",
      "methods": [
        "__init__"
      ],
      "bases": [
        "CheckpointSigner"
      ],
      "decorators": [],
      "line_number": 179
    },
    "empirica.components.edit_verification.confidence_assessor.EditConfidenceAssessor": {
      "name": "EditConfidenceAssessor",
      "module": "empirica.components.edit_verification.confidence_assessor",
      "docstring": "Assesses epistemic confidence before attempting file edits.\n\nPrevents 80% of edit failures by detecting whitespace mismatches,\nstale context, and ambiguous targets BEFORE attempting edit.",
      "methods": [
        "__init__",
        "assess",
        "recommend_strategy",
        "_assess_context_freshness",
        "_assess_whitespace_confidence",
        "_assess_match_uniqueness",
        "_assess_truncation_risk",
        "_context_age_description"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 18
    },
    "empirica.components.edit_verification.strategy_executor.EditStrategyExecutor": {
      "name": "EditStrategyExecutor",
      "module": "empirica.components.edit_verification.strategy_executor",
      "docstring": "Executes file edits using confidence-appropriate strategies.\n\nPrevents whitespace failures by choosing the right tool for the job.",
      "methods": [
        "__init__",
        "_make_flexible_pattern"
      ],
      "bases": [],
      "decorators": [],
      "line_number": 18
    }
  },
  "imports": [
    {
      "module": "empirica.core.canonical",
      "names": [
        "CanonicalEpistemicAssessor",
        "ReflexLogger"
      ],
      "source_file": "empirica.__init__"
    },
    {
      "module": "empirica.core.metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade"
      ],
      "source_file": "empirica.__init__"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.__init__"
    },
    {
      "module": "empirica.data.session_json_handler",
      "names": [
        "SessionJSONHandler"
      ],
      "source_file": "empirica.__init__"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.__main__"
    },
    {
      "module": "cli_core",
      "names": [
        "main"
      ],
      "source_file": "empirica.cli.__main__"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.cli_utils"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.cli_utils"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "List",
        "Optional"
      ],
      "source_file": "empirica.cli.cli_utils"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.cli_utils"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.cli.uvl_formatter"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.uvl_formatter"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.uvl_formatter"
    },
    {
      "module": "cli_core",
      "names": [
        "main",
        "create_argument_parser"
      ],
      "source_file": "empirica.cli.__init__"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "format_uncertainty_output",
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.__init__"
    },
    {
      "module": "fastapi",
      "names": [
        "FastAPI",
        "HTTPException"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "pydantic",
      "names": [
        "BaseModel"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "List",
        "Optional"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "uvicorn",
      "names": [
        "uvicorn"
      ],
      "source_file": "empirica.cli.simple_session_server"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.mcp_client"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.mcp_client"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.mcp_client"
    },
    {
      "module": "tempfile",
      "names": [
        "tempfile"
      ],
      "source_file": "empirica.cli.mcp_client"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.mcp_client"
    },
    {
      "module": "argparse",
      "names": [
        "argparse"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "print_header"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "command_handlers",
      "names": [
        "*"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "empirica.cli.asyncio_fix",
      "names": [
        "patch_asyncio_for_mcp"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.cli_core"
    },
    {
      "module": "warnings",
      "names": [
        "warnings"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "atexit",
      "names": [
        "atexit"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "threading",
      "names": [
        "threading"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "httpx",
      "names": [
        "httpx"
      ],
      "source_file": "empirica.cli.asyncio_fix"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.integrations.branch_mapping"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.integrations.branch_mapping"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.integrations.branch_mapping"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "List"
      ],
      "source_file": "empirica.integrations.branch_mapping"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.integrations.branch_mapping"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.reasoning.types"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Literal"
      ],
      "source_file": "empirica.reasoning.types"
    },
    {
      "module": "service",
      "names": [
        "ReasoningService"
      ],
      "source_file": "empirica.reasoning.__init__"
    },
    {
      "module": "ollama_adapter",
      "names": [
        "OllamaReasoningModel"
      ],
      "source_file": "empirica.reasoning.__init__"
    },
    {
      "module": "epistemic_cascade",
      "names": [
        "EpistemicCascade",
        "create_default_cascade"
      ],
      "source_file": "empirica.reasoning.__init__"
    },
    {
      "module": "types",
      "names": [
        "DeprecationJudgment",
        "RelationshipAnalysis",
        "ImplementationGap"
      ],
      "source_file": "empirica.reasoning.__init__"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "service",
      "names": [
        "ReasoningService"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "types",
      "names": [
        "DeprecationJudgment",
        "RelationshipAnalysis",
        "ImplementationGap"
      ],
      "source_file": "empirica.reasoning.ollama_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "service",
      "names": [
        "ReasoningService"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "ollama_adapter",
      "names": [
        "OllamaReasoningModel"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "types",
      "names": [
        "DeprecationJudgment"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.reasoning.epistemic_cascade"
    },
    {
      "module": "abc",
      "names": [
        "ABC",
        "abstractmethod"
      ],
      "source_file": "empirica.reasoning.service"
    },
    {
      "module": "typing",
      "names": [
        "Dict"
      ],
      "source_file": "empirica.reasoning.service"
    },
    {
      "module": "types",
      "names": [
        "DeprecationJudgment",
        "RelationshipAnalysis",
        "ImplementationGap"
      ],
      "source_file": "empirica.reasoning.service"
    },
    {
      "module": "app",
      "names": [
        "create_app"
      ],
      "source_file": "empirica.api.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.app"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.api.app"
    },
    {
      "module": "flask",
      "names": [
        "Flask",
        "jsonify",
        "request"
      ],
      "source_file": "empirica.api.app"
    },
    {
      "module": "routes",
      "names": [
        "sessions",
        "deltas",
        "verification",
        "heatmaps",
        "comparison"
      ],
      "source_file": "empirica.api.app"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.credentials_loader"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.config.path_resolver"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.project_config_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.project_config_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.config.project_config_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.project_config_loader"
    },
    {
      "module": "credentials_loader",
      "names": [
        "get_credentials_loader",
        "CredentialsLoader"
      ],
      "source_file": "empirica.config.__init__"
    },
    {
      "module": "profile_loader",
      "names": [
        "load_profile",
        "InvestigationProfile",
        "InvestigationConstraints"
      ],
      "source_file": "empirica.config.__init__"
    },
    {
      "module": "threshold_loader",
      "names": [
        "ThresholdLoader",
        "get_threshold_config",
        "load_profile",
        "get_threshold",
        "override_threshold"
      ],
      "source_file": "empirica.config.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.memory_gap_policy_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.memory_gap_policy_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.memory_gap_policy_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.config.memory_gap_policy_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.goal_scope_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.goal_scope_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.goal_scope_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.config.goal_scope_loader"
    },
    {
      "module": "copy",
      "names": [
        "copy"
      ],
      "source_file": "empirica.config.goal_scope_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.profile_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.config.profile_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.profile_loader"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.config.profile_loader"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.config.profile_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "typing",
      "names": [
        "Any",
        "Dict",
        "Optional"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "copy",
      "names": [
        "copy"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "empirica.core",
      "names": [
        "thresholds"
      ],
      "source_file": "empirica.config.threshold_loader"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any",
        "Tuple"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "empirica.cli.uvl_formatter",
      "names": [
        "get_confidence_color"
      ],
      "source_file": "empirica.dashboard.cascade_monitor"
    },
    {
      "module": "snapshot_monitor",
      "names": [
        "SnapshotMonitor",
        "launch_dashboard"
      ],
      "source_file": "empirica.dashboard.__init__"
    },
    {
      "module": "curses",
      "names": [
        "curses"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "List",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "empirica.plugins.modality_switcher.snapshot_provider",
      "names": [
        "EpistemicSnapshotProvider"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "empirica.plugins.modality_switcher.epistemic_snapshot",
      "names": [
        "EpistemicStateSnapshot"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "empirica.auto_tracker",
      "names": [
        "EmpericaTracker"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.dashboard.snapshot_monitor"
    },
    {
      "module": "abc",
      "names": [
        "ABC",
        "abstractmethod"
      ],
      "source_file": "empirica.core.epistemic_bus"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "List",
        "Optional",
        "Callable"
      ],
      "source_file": "empirica.core.epistemic_bus"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.epistemic_bus"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.epistemic_bus"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.thresholds"
    },
    {
      "module": "typing",
      "names": [
        "Any"
      ],
      "source_file": "empirica.core.thresholds"
    },
    {
      "module": "empirica.config.threshold_loader",
      "names": [
        "get_threshold_config"
      ],
      "source_file": "empirica.core.thresholds"
    },
    {
      "module": "epistemic_bus",
      "names": [
        "EpistemicBus",
        "EpistemicEvent",
        "EpistemicObserver",
        "EventTypes",
        "LoggingObserver",
        "CallbackObserver",
        "get_global_bus",
        "set_global_bus"
      ],
      "source_file": "empirica.core.__init__"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.memory_gap_detector"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.memory_gap_detector"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.memory_gap_detector"
    },
    {
      "module": "empirica.config.memory_gap_policy_loader",
      "names": [
        "get_policy_loader"
      ],
      "source_file": "empirica.core.memory_gap_detector"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any"
      ],
      "source_file": "empirica.core.context_load_balancer"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.context_load_balancer"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.checkpoint_signer"
    },
    {
      "module": "session_resolver",
      "names": [
        "resolve_session_id",
        "get_latest_session_id",
        "is_session_alias"
      ],
      "source_file": "empirica.utils.__init__"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.utils.doc_code_integrity"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.utils.doc_code_integrity"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.utils.doc_code_integrity"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Set",
        "Optional"
      ],
      "source_file": "empirica.utils.doc_code_integrity"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.utils.doc_code_integrity"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Tuple",
        "Optional"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "empirica.utils.doc_code_integrity",
      "names": [
        "DocCodeIntegrityAnalyzer"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.utils.deprecation_detector"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.utils.session_resolver"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.utils.session_resolver"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.utils.session_resolver"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.utils.session_resolver"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.utils.session_resolver"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.utils.finding_refs"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.utils.finding_refs"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.utils.finding_refs"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.utils.finding_refs"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "libtmux",
      "names": [
        "libtmux"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.plugins.dashboard_spawner"
    },
    {
      "module": "abc",
      "names": [
        "ABC",
        "abstractmethod"
      ],
      "source_file": "empirica.plugins.base_plugin"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.plugins.base_plugin"
    },
    {
      "module": "modality_switcher",
      "names": [
        "ModalitySwitcher"
      ],
      "source_file": "empirica.plugins.__init__"
    },
    {
      "module": "investigation_plugin",
      "names": [
        "InvestigationPlugin"
      ],
      "source_file": "empirica.investigation.__init__"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional",
        "Callable"
      ],
      "source_file": "empirica.investigation.investigation_plugin"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.investigation.investigation_plugin"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "asdict"
      ],
      "source_file": "empirica.metrics.token_efficiency"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "functools",
      "names": [
        "wraps"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "typing",
      "names": [
        "Any",
        "Dict",
        "Callable"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "tmux_dashboard_manager",
      "names": [
        "TMuxDashboardManager"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.integration.empirica_action_hooks"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.data.session_json_handler"
    },
    {
      "module": "session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.data.__init__"
    },
    {
      "module": "session_json_handler",
      "names": [
        "SessionJSONHandler"
      ],
      "source_file": "empirica.data.__init__"
    },
    {
      "module": "sqlite3",
      "names": [
        "sqlite3"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "dataclasses",
      "names": [
        "asdict"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "canonical.reflex_frame",
      "names": [
        "EpistemicAssessment",
        "VectorState",
        "Action"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.data.repositories",
      "names": [
        "GoalRepository",
        "BranchRepository",
        "BreadcrumbRepository",
        "ProjectRepository"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.core.context_load_balancer",
      "names": [
        "ContextLoadBalancer"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.config.path_resolver",
      "names": [
        "get_session_db_path"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "empirica.utils.doc_code_integrity",
      "names": [
        "DocCodeIntegrityAnalyzer"
      ],
      "source_file": "empirica.data.session_database"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.repositories.goals"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.data.repositories.goals"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.data.repositories.goals"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List"
      ],
      "source_file": "empirica.data.repositories.goals"
    },
    {
      "module": "base",
      "names": [
        "BaseRepository"
      ],
      "source_file": "empirica.data.repositories.goals"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.repositories.branches"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.data.repositories.branches"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.data.repositories.branches"
    },
    {
      "module": "typing",
      "names": [
        "Dict"
      ],
      "source_file": "empirica.data.repositories.branches"
    },
    {
      "module": "base",
      "names": [
        "BaseRepository"
      ],
      "source_file": "empirica.data.repositories.branches"
    },
    {
      "module": "sqlite3",
      "names": [
        "sqlite3"
      ],
      "source_file": "empirica.data.repositories.base"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.data.repositories.base"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.data.repositories.base"
    },
    {
      "module": "base",
      "names": [
        "BaseRepository"
      ],
      "source_file": "empirica.data.repositories.__init__"
    },
    {
      "module": "goals",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.data.repositories.__init__"
    },
    {
      "module": "branches",
      "names": [
        "BranchRepository"
      ],
      "source_file": "empirica.data.repositories.__init__"
    },
    {
      "module": "breadcrumbs",
      "names": [
        "BreadcrumbRepository"
      ],
      "source_file": "empirica.data.repositories.__init__"
    },
    {
      "module": "projects",
      "names": [
        "ProjectRepository"
      ],
      "source_file": "empirica.data.repositories.__init__"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "base",
      "names": [
        "BaseRepository"
      ],
      "source_file": "empirica.data.repositories.breadcrumbs"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "base",
      "names": [
        "BaseRepository"
      ],
      "source_file": "empirica.data.repositories.projects"
    },
    {
      "module": "advanced_investigation",
      "names": [
        "InvestigationStatus",
        "EvidenceType",
        "Evidence",
        "InvestigationProtocol",
        "AdvancedInvestigationEngine",
        "CorrelationEngine",
        "AnalysisEngine",
        "SourceType",
        "MultiSourceAnalyzer",
        "SourceCorrelator"
      ],
      "source_file": "empirica.investigation.advanced_investigation.__init__"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any",
        "Callable",
        "Union",
        "Tuple"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "threading",
      "names": [
        "threading"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "concurrent.futures",
      "names": [
        "ThreadPoolExecutor",
        "Future"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.investigation.advanced_investigation.advanced_investigation"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.genuine_self_assessment"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.genuine_self_assessment"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.genuine_self_assessment"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.plugins.modality_switcher.genuine_self_assessment"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.plugins.modality_switcher.genuine_self_assessment"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.domain_vectors"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.domain_vectors"
    },
    {
      "module": "importlib.util",
      "names": [
        "importlib.util"
      ],
      "source_file": "empirica.plugins.modality_switcher.domain_vectors"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.domain_vectors"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "asdict"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.plugins.modality_switcher.auth_manager"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "List"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "empirica.auto_tracker",
      "names": [
        "EmpericaTracker"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "epistemic_snapshot",
      "names": [
        "EpistemicStateSnapshot",
        "ContextSummary",
        "create_snapshot"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "empirica.integration.empirica_action_hooks",
      "names": [
        "EmpiricaActionHooks"
      ],
      "source_file": "empirica.plugins.modality_switcher.snapshot_provider"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_router"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_router"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_router"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.config_loader"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "asdict"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.usage_monitor"
    },
    {
      "module": "modality_switcher",
      "names": [
        "ModalitySwitcher",
        "RoutingStrategy",
        "RoutingPreferences"
      ],
      "source_file": "empirica.plugins.modality_switcher.__init__"
    },
    {
      "module": "plugin_registry",
      "names": [
        "PluginRegistry",
        "AdapterInterface",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.__init__"
    },
    {
      "module": "register_adapters",
      "names": [
        "get_registry",
        "get_adapter",
        "list_registered_adapters"
      ],
      "source_file": "empirica.plugins.modality_switcher.__init__"
    },
    {
      "module": "usage_monitor",
      "names": [
        "UsageMonitor"
      ],
      "source_file": "empirica.plugins.modality_switcher.__init__"
    },
    {
      "module": "auth_manager",
      "names": [
        "AuthManager"
      ],
      "source_file": "empirica.plugins.modality_switcher.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.thinking_analyzer"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.plugins.modality_switcher.thinking_analyzer"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.plugins.modality_switcher.thinking_analyzer"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field",
        "asdict"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_snapshot"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_snapshot"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_snapshot"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_snapshot"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_snapshot"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "names": [
        "get_registry"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.modality_switcher"
    },
    {
      "module": "importlib",
      "names": [
        "importlib"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "importlib.util",
      "names": [
        "importlib.util"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "inspect",
      "names": [
        "inspect"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Protocol",
        "Optional",
        "List"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.plugin_registry"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_extractor"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_extractor"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.epistemic_extractor"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "PluginRegistry"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters",
      "names": [
        "MinimaxAdapter",
        "MINIMAX_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.qwen_adapter",
      "names": [
        "QwenAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.rovodev_adapter",
      "names": [
        "RovodevAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.gemini_adapter",
      "names": [
        "GeminiAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.qodo_adapter",
      "names": [
        "QodoAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.openrouter_adapter",
      "names": [
        "OpenRouterAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters.copilot_adapter",
      "names": [
        "CopilotAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "empirica.plugins.modality_switcher.adapters",
      "names": [
        "LocalAdapter",
        "LOCAL_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.register_adapters"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.openrouter_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "anthropic",
      "names": [
        "anthropic"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.thinking_analyzer",
      "names": [
        "extract_from_thinking_semantically",
        "extract_decision_from_thinking"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.minimax_adapter"
    },
    {
      "module": "qwen_adapter",
      "names": [
        "QwenAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "minimax_adapter",
      "names": [
        "MinimaxAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "rovodev_adapter",
      "names": [
        "RovodevAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "gemini_adapter",
      "names": [
        "GeminiAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "qodo_adapter",
      "names": [
        "QodoAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "openrouter_adapter",
      "names": [
        "OpenRouterAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "copilot_adapter",
      "names": [
        "CopilotAdapter",
        "ADAPTER_METADATA"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.__init__"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qodo_adapter"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "empirica.core.modality.plugin_registry",
      "names": [
        "AdapterResponse"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "empirica.core.modality.plugin_registry",
      "names": [
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.rovodev_adapter"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.gemini_adapter"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.copilot_adapter"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterPayload",
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "empirica.plugins.modality_switcher.auth_manager",
      "names": [
        "AuthManager"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.plugins.modality_switcher.adapters.qwen_adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "empirica.core.persona.signing_persona",
      "names": [
        "SigningPersona"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "empirica.core.persona.persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "git",
      "names": [
        "git"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "empirica.core.identity.ai_identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.git_ops.signed_operations"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "dataclasses",
      "names": [
        "asdict"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "empirica.core.persona.persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "empirica.core.identity.ai_identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.persona.signing_persona"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "List",
        "Dict"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "persona_profile",
      "names": [
        "PersonaProfile",
        "SigningIdentityConfig"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "validation",
      "names": [
        "validate_persona_profile",
        "ValidationError"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "persona_profile",
      "names": [
        "EpistemicConfig"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "templates",
      "names": [
        "BUILTIN_TEMPLATES"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "persona_profile",
      "names": [
        "EpistemicConfig"
      ],
      "source_file": "empirica.core.persona.persona_manager"
    },
    {
      "module": "persona_profile",
      "names": [
        "PersonaProfile",
        "EpistemicConfig",
        "SigningIdentityConfig",
        "CapabilitiesConfig",
        "SentinelConfig",
        "PersonaMetadata"
      ],
      "source_file": "empirica.core.persona.__init__"
    },
    {
      "module": "persona_manager",
      "names": [
        "PersonaManager"
      ],
      "source_file": "empirica.core.persona.__init__"
    },
    {
      "module": "validation",
      "names": [
        "validate_persona_profile",
        "ValidationError"
      ],
      "source_file": "empirica.core.persona.__init__"
    },
    {
      "module": "harness",
      "names": [
        "PersonaHarness",
        "PersonaMessage",
        "SentinelMessage",
        "MessageType"
      ],
      "source_file": "empirica.core.persona.__init__"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field",
        "asdict"
      ],
      "source_file": "empirica.core.persona.persona_profile"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.persona.persona_profile"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.persona.persona_profile"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.core.persona.persona_profile"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.validation"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.validation"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.validation"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.persona.validation"
    },
    {
      "module": "jsonschema",
      "names": [
        "jsonschema"
      ],
      "source_file": "empirica.core.persona.validation"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.core.skills.parser"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.skills.parser"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.core.skills.parser"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List"
      ],
      "source_file": "empirica.core.skills.parser"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "types",
      "names": [
        "Goal",
        "ScopeVector"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.goals.repository"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "validation",
      "names": [
        "validate_objective",
        "validate_success_criteria",
        "validate_complexity",
        "validate_scope_vector"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "empirica.core.tasks.types",
      "names": [
        "TaskStatus"
      ],
      "source_file": "empirica.core.goals.types"
    },
    {
      "module": "types",
      "names": [
        "Goal",
        "SuccessCriterion",
        "Dependency",
        "ScopeVector",
        "DependencyType"
      ],
      "source_file": "empirica.core.goals.__init__"
    },
    {
      "module": "repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.core.goals.__init__"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.core.goals.decision_logic"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.goals.decision_logic"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.goals.validation"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.goals.validation"
    },
    {
      "module": "types",
      "names": [
        "Goal",
        "SuccessCriterion",
        "ScopeVector"
      ],
      "source_file": "empirica.core.goals.validation"
    },
    {
      "module": "mirror_drift_monitor",
      "names": [
        "MirrorDriftMonitor"
      ],
      "source_file": "empirica.core.drift.__init__"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.drift.mirror_drift_monitor"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.drift.mirror_drift_monitor"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.drift.mirror_drift_monitor"
    },
    {
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "names": [
        "CheckpointManager"
      ],
      "source_file": "empirica.core.drift.mirror_drift_monitor"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field",
        "asdict"
      ],
      "source_file": "empirica.core.schemas.epistemic_assessment"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.schemas.epistemic_assessment"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.schemas.epistemic_assessment"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.core.schemas.epistemic_assessment"
    },
    {
      "module": "empirica.core.canonical.reflex_frame",
      "names": [
        "Action"
      ],
      "source_file": "empirica.core.schemas.epistemic_assessment"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema",
        "VectorAssessment"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "empirica.core.canonical.reflex_frame",
      "names": [
        "EpistemicAssessment",
        "VectorState",
        "Action"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "CascadePhase"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "empirica.core.canonical.reflex_frame",
      "names": [
        "Action"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "empirica.core.canonical.reflex_frame",
      "names": [
        "Action"
      ],
      "source_file": "empirica.core.schemas.assessment_converters"
    },
    {
      "module": "epistemic_assessment",
      "names": [
        "VectorAssessment",
        "EpistemicAssessmentSchema",
        "validate_assessment",
        "parse_assessment_dict"
      ],
      "source_file": "empirica.core.schemas.__init__"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "hashlib",
      "names": [
        "hashlib"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "Union"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "reflex_frame",
      "names": [
        "VectorState",
        "Action",
        "CANONICAL_WEIGHTS",
        "ENGAGEMENT_THRESHOLD",
        "CRITICAL_THRESHOLDS"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema",
        "VectorAssessment",
        "CascadePhase"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "load_profile"
      ],
      "source_file": "empirica.core.canonical.canonical_epistemic_assessment"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "timedelta",
        "UTC"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "reflex_frame",
      "names": [
        "VectorState",
        "Action"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "empirica.core.git_ops.signed_operations",
      "names": [
        "SignedGitOperations"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "empirica.core.persona.signing_persona",
      "names": [
        "SigningPersona"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.canonical.git_enhanced_reflex_logger"
    },
    {
      "module": "reflex_frame",
      "names": [
        "VectorState",
        "Action",
        "CANONICAL_WEIGHTS"
      ],
      "source_file": "empirica.core.canonical.__init__"
    },
    {
      "module": "thresholds",
      "names": [
        "ENGAGEMENT_THRESHOLD",
        "CRITICAL_THRESHOLDS"
      ],
      "source_file": "empirica.core.canonical.__init__"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.__init__"
    },
    {
      "module": "reflex_logger",
      "names": [
        "ReflexLogger",
        "log_assessment",
        "log_assessment_sync"
      ],
      "source_file": "empirica.core.canonical.__init__"
    },
    {
      "module": "canonical_epistemic_assessment",
      "names": [
        "CanonicalEpistemicAssessor"
      ],
      "source_file": "empirica.core.canonical.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "canonical_goal_orchestrator",
      "names": [
        "Goal",
        "CanonicalGoalOrchestrator"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "empirica.core.goals.types",
      "names": [
        "Goal",
        "SuccessCriterion",
        "ScopeVector"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.core.canonical.goal_orchestrator_bridge"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field",
        "asdict"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "thresholds",
      "names": [
        "ENGAGEMENT_THRESHOLD",
        "CRITICAL_THRESHOLDS"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.reflex_frame"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "reflex_frame",
      "names": [
        "Action"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "thresholds",
      "names": [
        "GOAL_CONFIDENCE_THRESHOLD"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "reflex_frame",
      "names": [
        "Action"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.canonical.canonical_goal_orchestrator"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC",
        "date"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "aiofiles",
      "names": [
        "aiofiles"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "datetime",
      "names": [
        "timedelta"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "shutil",
      "names": [
        "shutil"
      ],
      "source_file": "empirica.core.canonical.reflex_logger"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.completion.git_query"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.completion.git_query"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.completion.git_query"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.completion.git_query"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.core.completion.git_query"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.core.completion.types"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.completion.types"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.completion.types"
    },
    {
      "module": "types",
      "names": [
        "CompletionRecord",
        "CompletionMetrics"
      ],
      "source_file": "empirica.core.completion.__init__"
    },
    {
      "module": "tracker",
      "names": [
        "CompletionTracker"
      ],
      "source_file": "empirica.core.completion.__init__"
    },
    {
      "module": "git_query",
      "names": [
        "GitProgressQuery"
      ],
      "source_file": "empirica.core.completion.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "empirica.core.tasks.types",
      "names": [
        "TaskStatus",
        "EpistemicImportance"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "types",
      "names": [
        "CompletionRecord",
        "CompletionMetrics"
      ],
      "source_file": "empirica.core.completion.tracker"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.handoff.report_generator"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.handoff.auto_generator"
    },
    {
      "module": "report_generator",
      "names": [
        "EpistemicHandoffReportGenerator"
      ],
      "source_file": "empirica.core.handoff.__init__"
    },
    {
      "module": "storage",
      "names": [
        "GitHandoffStorage",
        "DatabaseHandoffStorage"
      ],
      "source_file": "empirica.core.handoff.__init__"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "sqlite3",
      "names": [
        "sqlite3"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.core.handoff.storage"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "hashlib",
      "names": [
        "sha256"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "qdrant_client",
      "names": [
        "QdrantClient"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "qdrant_client.models",
      "names": [
        "Distance",
        "VectorParams",
        "PointStruct"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "empirica.core.persona.signing_persona",
      "names": [
        "SigningPersona"
      ],
      "source_file": "empirica.core.qdrant.persona_registry"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "typing",
      "names": [
        "List"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "openai",
      "names": [
        "OpenAI"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "hashlib",
      "names": [
        "hashlib"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "math",
      "names": [
        "math"
      ],
      "source_file": "empirica.core.qdrant.embeddings"
    },
    {
      "module": "empirica.core.qdrant.persona_registry",
      "names": [
        "PersonaRegistry"
      ],
      "source_file": "empirica.core.qdrant.__init__"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "qdrant_client",
      "names": [
        "QdrantClient"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "qdrant_client.models",
      "names": [
        "Distance",
        "VectorParams",
        "PointStruct",
        "Filter",
        "FieldCondition",
        "MatchValue"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "embeddings",
      "names": [
        "get_embedding"
      ],
      "source_file": "empirica.core.qdrant.vector_store"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "types",
      "names": [
        "SubTask",
        "TaskDecomposition",
        "TaskStatus",
        "EpistemicImportance"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.tasks.repository"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.core.tasks.types"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.tasks.types"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.tasks.types"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.tasks.types"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.core.tasks.types"
    },
    {
      "module": "types",
      "names": [
        "SubTask",
        "TaskDecomposition",
        "EpistemicImportance",
        "TaskStatus"
      ],
      "source_file": "empirica.core.tasks.__init__"
    },
    {
      "module": "repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.core.tasks.__init__"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.core.docs.doc_planner"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.validation.rehydration"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.validation.rehydration"
    },
    {
      "module": "validation_utils",
      "names": [
        "estimate_rehydration_boost",
        "calculate_understanding_ratio"
      ],
      "source_file": "empirica.core.validation.rehydration"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.validation.coherence_validator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.validation.coherence_validator"
    },
    {
      "module": "validation_utils",
      "names": [
        "get_git_diff_summary",
        "analyze_epistemic_trajectory"
      ],
      "source_file": "empirica.core.validation.coherence_validator"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.validation.handoff_validator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.validation.handoff_validator"
    },
    {
      "module": "validation_utils",
      "names": [
        "get_git_diff_summary"
      ],
      "source_file": "empirica.core.validation.handoff_validator"
    },
    {
      "module": "coherence_validator",
      "names": [
        "CoherenceValidator"
      ],
      "source_file": "empirica.core.validation.__init__"
    },
    {
      "module": "rehydration",
      "names": [
        "EpistemicRehydration"
      ],
      "source_file": "empirica.core.validation.__init__"
    },
    {
      "module": "handoff_validator",
      "names": [
        "HandoffValidator"
      ],
      "source_file": "empirica.core.validation.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.validation.validation_utils"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.core.validation.validation_utils"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.validation.validation_utils"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.validation.validation_utils"
    },
    {
      "module": "metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade",
        "run_canonical_cascade",
        "CascadePhase",
        "CanonicalCascadeState"
      ],
      "source_file": "empirica.core.metacognitive_cascade.__init__"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any",
        "Optional",
        "Callable"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_plugin"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_plugin"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_plugin"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "hashlib",
      "names": [
        "hashlib"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.canonical",
      "names": [
        "CanonicalEpistemicAssessor",
        "ReflexLogger",
        "Action",
        "CANONICAL_WEIGHTS",
        "ENGAGEMENT_THRESHOLD"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema",
        "CascadePhase",
        "AssessmentType"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "investigation_strategy",
      "names": [
        "recommend_investigation_tools",
        "Domain",
        "ToolRecommendation"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "investigation_plugin",
      "names": [
        "InvestigationPlugin",
        "PluginRegistry"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.data.session_json_handler",
      "names": [
        "SessionJSONHandler"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.drift",
      "names": [
        "MirrorDriftMonitor"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.integration.empirica_action_hooks",
      "names": [
        "log_cascade_phase",
        "log_12d_state",
        "log_thought",
        "initialize_tmux_dashboard"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "select_profile",
        "get_profile_loader"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.goals.decision_logic",
      "names": [
        "decide_goal_creation",
        "format_decision_for_ai"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.canonical.reflex_frame",
      "names": [
        "VectorState"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "warnings",
      "names": [
        "warnings"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "warnings",
      "names": [
        "warnings"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.metrics.token_efficiency",
      "names": [
        "TokenEfficiencyMetrics"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.epistemic_bus",
      "names": [
        "EpistemicEvent",
        "EventTypes"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.epistemic_bus",
      "names": [
        "EpistemicEvent"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.epistemic_bus",
      "names": [
        "EpistemicEvent",
        "EventTypes"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "VectorAssessment"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.canonical.goal_orchestrator_bridge",
      "names": [
        "create_orchestrator_with_bridge"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "empirica.core.epistemic_bus",
      "names": [
        "EpistemicEvent",
        "EventTypes"
      ],
      "source_file": "empirica.core.metacognitive_cascade.metacognitive_cascade"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional",
        "Protocol"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "abc",
      "names": [
        "ABC",
        "abstractmethod"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "empirica.core.canonical",
      "names": [
        "EpistemicAssessment",
        "VectorState"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "load_profile"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "load_profile"
      ],
      "source_file": "empirica.core.metacognitive_cascade.investigation_strategy"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "hashlib",
      "names": [
        "hashlib"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "ai_identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.identity.signature"
    },
    {
      "module": "ai_identity",
      "names": [
        "AIIdentity",
        "IdentityManager"
      ],
      "source_file": "empirica.core.identity.__init__"
    },
    {
      "module": "signature",
      "names": [
        "sign_assessment",
        "verify_signature",
        "create_eep1_payload",
        "verify_eep1_payload"
      ],
      "source_file": "empirica.core.identity.__init__"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "cryptography.hazmat.primitives.asymmetric.ed25519",
      "names": [
        "Ed25519PrivateKey",
        "Ed25519PublicKey"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "cryptography.hazmat.primitives",
      "names": [
        "serialization"
      ],
      "source_file": "empirica.core.identity.ai_identity"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.empirica_git.sentinel_hooks"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "Callable"
      ],
      "source_file": "empirica.core.canonical.empirica_git.sentinel_hooks"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.canonical.empirica_git.sentinel_hooks"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.canonical.empirica_git.session_sync"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.canonical.empirica_git.session_sync"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.empirica_git.session_sync"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.core.canonical.empirica_git.session_sync"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.canonical.empirica_git.checkpoint_manager"
    },
    {
      "module": "checkpoint_manager",
      "names": [
        "CheckpointManager",
        "auto_checkpoint"
      ],
      "source_file": "empirica.core.canonical.empirica_git.__init__"
    },
    {
      "module": "goal_store",
      "names": [
        "GitGoalStore"
      ],
      "source_file": "empirica.core.canonical.empirica_git.__init__"
    },
    {
      "module": "session_sync",
      "names": [
        "SessionSync"
      ],
      "source_file": "empirica.core.canonical.empirica_git.__init__"
    },
    {
      "module": "sentinel_hooks",
      "names": [
        "SentinelHooks"
      ],
      "source_file": "empirica.core.canonical.empirica_git.__init__"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.canonical.empirica_git.goal_store"
    },
    {
      "module": "persona_harness",
      "names": [
        "PersonaHarness"
      ],
      "source_file": "empirica.core.persona.harness.__init__"
    },
    {
      "module": "communication",
      "names": [
        "SentinelMessage",
        "PersonaMessage",
        "MessageType",
        "send_message",
        "receive_message"
      ],
      "source_file": "empirica.core.persona.harness.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "persona_manager",
      "names": [
        "PersonaManager"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "communication",
      "names": [
        "PersonaMessage",
        "SentinelMessage",
        "MessageType",
        "send_message",
        "receive_message"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema",
        "VectorAssessment"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "empirica.core.metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade"
      ],
      "source_file": "empirica.core.persona.harness.persona_harness"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "enum",
      "names": [
        "Enum"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field",
        "asdict"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "empirica.core.identity.signature",
      "names": [
        "sign_assessment"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "empirica.core.identity.signature",
      "names": [
        "sign_assessment"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.persona.harness.communication"
    },
    {
      "module": "orchestration_result",
      "names": [
        "OrchestrationResult",
        "ArbitrationResult"
      ],
      "source_file": "empirica.core.persona.sentinel.__init__"
    },
    {
      "module": "sentinel_orchestrator",
      "names": [
        "SentinelOrchestrator"
      ],
      "source_file": "empirica.core.persona.sentinel.__init__"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional",
        "Any"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "empirica.core.persona.harness.persona_harness",
      "names": [
        "PersonaHarness"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "empirica.core.persona.persona_manager",
      "names": [
        "PersonaManager"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "empirica.core.persona.persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "orchestration_result",
      "names": [
        "OrchestrationResult",
        "ArbitrationResult"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "composition_strategies",
      "names": [
        "get_composition_strategy"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "arbitration_strategies",
      "names": [
        "get_arbitration_strategy"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "VectorAssessment"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "collections",
      "names": [
        "Counter"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "collections",
      "names": [
        "Counter"
      ],
      "source_file": "empirica.core.persona.sentinel.sentinel_orchestrator"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "List"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "collections",
      "names": [
        "Counter"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "empirica.core.persona.persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "orchestration_result",
      "names": [
        "ArbitrationResult"
      ],
      "source_file": "empirica.core.persona.sentinel.arbitration_strategies"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.core.persona.sentinel.composition_strategies"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Optional"
      ],
      "source_file": "empirica.core.persona.sentinel.composition_strategies"
    },
    {
      "module": "statistics",
      "names": [
        "mean",
        "stdev"
      ],
      "source_file": "empirica.core.persona.sentinel.composition_strategies"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema",
        "VectorAssessment"
      ],
      "source_file": "empirica.core.persona.sentinel.composition_strategies"
    },
    {
      "module": "empirica.core.persona.persona_profile",
      "names": [
        "PersonaProfile"
      ],
      "source_file": "empirica.core.persona.sentinel.composition_strategies"
    },
    {
      "module": "dataclasses",
      "names": [
        "dataclass",
        "field"
      ],
      "source_file": "empirica.core.persona.sentinel.orchestration_result"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.core.persona.sentinel.orchestration_result"
    },
    {
      "module": "datetime",
      "names": [
        "datetime",
        "UTC"
      ],
      "source_file": "empirica.core.persona.sentinel.orchestration_result"
    },
    {
      "module": "empirica.core.schemas.epistemic_assessment",
      "names": [
        "EpistemicAssessmentSchema"
      ],
      "source_file": "empirica.core.persona.sentinel.orchestration_result"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.routes.verification"
    },
    {
      "module": "flask",
      "names": [
        "Blueprint",
        "jsonify",
        "request"
      ],
      "source_file": "empirica.api.routes.verification"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "flask",
      "names": [
        "Blueprint",
        "request",
        "jsonify"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.api.routes.sessions"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.routes.heatmaps"
    },
    {
      "module": "flask",
      "names": [
        "Blueprint",
        "jsonify"
      ],
      "source_file": "empirica.api.routes.heatmaps"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.routes.deltas"
    },
    {
      "module": "flask",
      "names": [
        "Blueprint",
        "jsonify"
      ],
      "source_file": "empirica.api.routes.deltas"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.api.routes.deltas"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.api.routes.comparison"
    },
    {
      "module": "flask",
      "names": [
        "Blueprint",
        "jsonify",
        "request"
      ],
      "source_file": "empirica.api.routes.comparison"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.integrations.beads.config"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.integrations.beads.config"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.integrations.beads.config"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.integrations.beads.config"
    },
    {
      "module": "adapter",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.integrations.beads.__init__"
    },
    {
      "module": "config",
      "names": [
        "BeadsConfig"
      ],
      "source_file": "empirica.integrations.beads.__init__"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.integrations.beads.adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.integrations.beads.adapter"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.integrations.beads.adapter"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict",
        "List",
        "Any"
      ],
      "source_file": "empirica.integrations.beads.adapter"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.utils.config_validator"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.utils.config_validator"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.cli.utils.config_validator"
    },
    {
      "module": "jsonschema",
      "names": [
        "jsonschema"
      ],
      "source_file": "empirica.cli.utils.config_validator"
    },
    {
      "module": "jsonschema",
      "names": [
        "validate",
        "ValidationError"
      ],
      "source_file": "empirica.cli.utils.config_validator"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.cli.utils.project_resolver"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.utils.project_resolver"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.utils.project_resolver"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.utils.project_resolver"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "hashlib",
      "names": [
        "hashlib"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "handle_cli_error",
        "format_uncertainty_output",
        "parse_json_safely",
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.cli.command_handlers.decision_utils",
      "names": [
        "get_recommendation_from_vectors"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.core.metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.core.canonical",
      "names": [
        "CanonicalEpistemicAssessor"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "ProfileLoader"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.core.canonical.empirica_git",
      "names": [
        "auto_checkpoint"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity",
        "sign_assessment"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.cascade_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "ProfileLoader"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.components.code_intelligence_analyzer",
      "names": [
        "CodeIntelligenceAnalyzer"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.components.workspace_awareness",
      "names": [
        "WorkspaceNavigator"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.components.empirical_performance_analyzer",
      "names": [
        "EmpiricalPerformanceAnalyzer"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.components.code_intelligence_analyzer",
      "names": [
        "CodeIntelligenceAnalyzer"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.components.workspace_awareness",
      "names": [
        "WorkspaceNavigator"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.core.canonical.canonical_epistemic_assessment",
      "names": [
        "CanonicalEpistemicAssessor"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.investigation_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity",
        "IdentityManager"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "IdentityManager"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "IdentityManager"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "verify_signature",
        "verify_eep1_payload"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.identity_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.cli.command_handlers.decision_utils",
      "names": [
        "calculate_decision"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "empirica.core.docs.doc_planner",
      "names": [
        "compute_doc_plan"
      ],
      "source_file": "empirica.cli.command_handlers.workflow_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.goals_ready_command"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.goals_ready_command"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Any"
      ],
      "source_file": "empirica.cli.command_handlers.goals_ready_command"
    },
    {
      "module": "empirica.integrations.beads",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.cli.command_handlers.goals_ready_command"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goals_ready_command"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "names": [
        "ModalitySwitcher"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.register_adapters",
      "names": [
        "get_registry"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.config_loader",
      "names": [
        "get_config"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "empirica.core.drift.mirror_drift_monitor",
      "names": [
        "MirrorDriftMonitor"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "empirica.core.canonical.empirica_git.checkpoint_manager",
      "names": [
        "CheckpointManager"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "csv",
      "names": [
        "csv"
      ],
      "source_file": "empirica.cli.command_handlers.monitor_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.core.memory_gap_detector",
      "names": [
        "MemoryGapDetector"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.config.project_config_loader",
      "names": [
        "get_current_subject"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.cli.utils.project_resolver",
      "names": [
        "resolve_project_id"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.cli.cli_utils",
      "names": [
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.config.project_config_loader",
      "names": [
        "get_current_subject"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.cli.utils.project_resolver",
      "names": [
        "resolve_project_id"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.config.project_config_loader",
      "names": [
        "get_current_subject"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.cli.utils.project_resolver",
      "names": [
        "resolve_project_id"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.config.project_config_loader",
      "names": [
        "get_current_subject"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "empirica.cli.utils.project_resolver",
      "names": [
        "resolve_project_id"
      ],
      "source_file": "empirica.cli.command_handlers.project_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.component_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "handle_cli_error",
        "format_component_list"
      ],
      "source_file": "empirica.cli.command_handlers.component_commands"
    },
    {
      "module": "random",
      "names": [
        "random"
      ],
      "source_file": "empirica.cli.command_handlers.component_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "empirica.core.canonical.empirica_git",
      "names": [
        "GitGoalStore"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "empirica.core.canonical.empirica_git",
      "names": [
        "GitGoalStore"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_discovery_commands"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "List"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "requests",
      "names": [
        "requests"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "zipfile",
      "names": [
        "zipfile"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "io",
      "names": [
        "io"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "empirica.core.skills.parser",
      "names": [
        "parse_markdown_to_skill"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "json",
      "names": [
        "_json"
      ],
      "source_file": "empirica.cli.command_handlers.skill_commands"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "empirica.bootstraps.onboarding_wizard",
      "names": [
        "EmpericaOnboardingWizard"
      ],
      "source_file": "empirica.cli.command_handlers.onboard_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.utils.session_resolver",
      "names": [
        "resolve_session_id"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.utils.session_resolver",
      "names": [
        "resolve_session_id"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "empirica.utils.session_resolver",
      "names": [
        "resolve_session_id"
      ],
      "source_file": "empirica.cli.command_handlers.session_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "ProfileLoader"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "empirica.core.metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.utility_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.mistake_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.modality_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.modality_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.modality_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "names": [
        "ModalitySwitcher",
        "RoutingPreferences",
        "RoutingStrategy"
      ],
      "source_file": "empirica.cli.command_handlers.modality_commands"
    },
    {
      "module": "empirica.core.metacognitive_cascade",
      "names": [
        "CanonicalEpistemicCascade"
      ],
      "source_file": "empirica.cli.command_handlers.modality_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.onboard"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.onboard"
    },
    {
      "module": "onboard",
      "names": [
        "handle_onboard_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "cascade_commands",
      "names": [
        "handle_preflight_command",
        "handle_postflight_command",
        "handle_workflow_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "modality_commands",
      "names": [
        "handle_modality_route_command",
        "handle_decision_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "action_commands",
      "names": [
        "handle_investigate_log_command",
        "handle_act_log_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "workflow_commands",
      "names": [
        "handle_preflight_submit_command",
        "handle_check_command",
        "handle_check_submit_command",
        "handle_postflight_submit_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "goal_commands",
      "names": [
        "handle_goals_create_command",
        "handle_goals_add_subtask_command",
        "handle_goals_complete_subtask_command",
        "handle_goals_progress_command",
        "handle_goals_get_subtasks_command",
        "handle_goals_list_command",
        "handle_sessions_resume_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "goals_ready_command",
      "names": [
        "handle_goals_ready_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "goal_claim_command",
      "names": [
        "handle_goals_claim_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "goal_complete_command",
      "names": [
        "handle_goals_complete_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "goal_discovery_commands",
      "names": [
        "handle_goals_discover_command",
        "handle_goals_resume_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "identity_commands",
      "names": [
        "handle_identity_create_command",
        "handle_identity_list_command",
        "handle_identity_export_command",
        "handle_identity_verify_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "decision_commands",
      "names": [
        "handle_decision_command",
        "handle_decision_batch_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "config_commands",
      "names": [
        "handle_config_command",
        "handle_config_init_command",
        "handle_config_show_command",
        "handle_config_validate_command",
        "handle_config_get_command",
        "handle_config_set_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "mcp_commands",
      "names": [
        "handle_mcp_start_command",
        "handle_mcp_stop_command",
        "handle_mcp_status_command",
        "handle_mcp_test_command",
        "handle_mcp_list_tools_command",
        "handle_mcp_call_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "session_commands",
      "names": [
        "handle_sessions_list_command",
        "handle_sessions_show_command",
        "handle_session_snapshot_command",
        "handle_sessions_export_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "session_create",
      "names": [
        "handle_session_create_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "checkpoint_commands",
      "names": [
        "handle_checkpoint_create_command",
        "handle_checkpoint_load_command",
        "handle_checkpoint_list_command",
        "handle_checkpoint_diff_command",
        "handle_efficiency_report_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "checkpoint_signing_commands",
      "names": [
        "handle_checkpoint_sign_command",
        "handle_checkpoint_verify_command",
        "handle_checkpoint_signatures_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "handoff_commands",
      "names": [
        "handle_handoff_create_command",
        "handle_handoff_query_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "mistake_commands",
      "names": [
        "handle_mistake_log_command",
        "handle_mistake_query_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "project_commands",
      "names": [
        "handle_project_create_command",
        "handle_project_handoff_command",
        "handle_project_list_command",
        "handle_project_bootstrap_command",
        "handle_finding_log_command",
        "handle_unknown_log_command",
        "handle_deadend_log_command",
        "handle_refdoc_add_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "project_search",
      "names": [
        "handle_project_search_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "project_embed",
      "names": [
        "handle_project_embed_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "doc_commands",
      "names": [
        "handle_doc_check_command",
        "handle_doc_plan_suggest_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "skill_commands",
      "names": [
        "handle_skill_suggest_command",
        "handle_skill_fetch_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "monitor_commands",
      "names": [
        "handle_monitor_command",
        "handle_monitor_export_command",
        "handle_monitor_reset_command",
        "handle_monitor_cost_command",
        "handle_check_drift_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "investigation_commands",
      "names": [
        "handle_investigate_command",
        "handle_analyze_command",
        "handle_investigate_create_branch_command",
        "handle_investigate_checkpoint_branch_command",
        "handle_investigate_merge_branches_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "performance_commands",
      "names": [
        "handle_benchmark_command",
        "handle_performance_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "component_commands",
      "names": [
        "handle_list_command",
        "handle_explain_command",
        "handle_demo_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "utility_commands",
      "names": [
        "handle_goal_analysis_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "ask_handler",
      "names": [
        "handle_ask_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "chat_handler",
      "names": [
        "handle_chat_command"
      ],
      "source_file": "empirica.cli.command_handlers.__init__"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "empirica.integrations.branch_mapping",
      "names": [
        "get_branch_mapping"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "empirica.integrations.beads",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "cascade_commands",
      "names": [
        "handle_preflight_command"
      ],
      "source_file": "empirica.cli.command_handlers.goal_claim_command"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.config_loader",
      "names": [
        "ConfigLoader",
        "get_config"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.config_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "typing",
      "names": [
        "Optional",
        "Dict"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "empirica.core.handoff.report_generator",
      "names": [
        "EpistemicHandoffReportGenerator"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "empirica.core.handoff.storage",
      "names": [
        "HybridHandoffStorage"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "empirica.core.handoff.storage",
      "names": [
        "HybridHandoffStorage"
      ],
      "source_file": "empirica.cli.command_handlers.handoff_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.action_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "empirica.plugins.modality_switcher",
      "names": [
        "ModalitySwitcher",
        "RoutingStrategy",
        "RoutingPreferences"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "empirica.data.session_json_handler",
      "names": [
        "SessionJSONHandler"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.ask_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "typing",
      "names": [
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "ProfileLoader"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.core.canonical.git_enhanced_reflex_logger",
      "names": [
        "GitEnhancedReflexLogger"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "empirica.metrics.token_efficiency",
      "names": [
        "TokenEfficiencyMetrics"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "traceback",
      "names": [
        "traceback"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_commands"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.cli.command_handlers.project_search"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.project_search"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict"
      ],
      "source_file": "empirica.cli.command_handlers.project_search"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.project_search"
    },
    {
      "module": "empirica.core.qdrant.vector_store",
      "names": [
        "init_collections",
        "search"
      ],
      "source_file": "empirica.cli.command_handlers.project_search"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "print_component_status",
        "handle_cli_error",
        "format_execution_time",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "empirica.config.profile_loader",
      "names": [
        "ProfileLoader"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "empirica.components.empirical_performance_analyzer",
      "names": [
        "EmpiricalPerformanceAnalyzer"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "empirica.components.empirical_performance_analyzer",
      "names": [
        "EmpiricalPerformanceAnalyzer"
      ],
      "source_file": "empirica.cli.command_handlers.performance_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Any",
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.modality_switcher",
      "names": [
        "ModalitySwitcher",
        "RoutingStrategy",
        "RoutingPreferences"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "empirica.plugins.modality_switcher.plugin_registry",
      "names": [
        "AdapterResponse",
        "AdapterError"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "empirica.config.credentials_loader",
      "names": [
        "get_credentials_loader"
      ],
      "source_file": "empirica.cli.command_handlers.decision_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "cli_utils",
      "names": [
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "empirica.config.project_config_loader",
      "names": [
        "get_current_subject"
      ],
      "source_file": "empirica.cli.command_handlers.session_create"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "tempfile",
      "names": [
        "tempfile"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict",
        "Optional"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "empirica.plugins.modality_switcher",
      "names": [
        "ModalitySwitcher",
        "RoutingStrategy",
        "RoutingPreferences"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "uvl_formatter",
      "names": [
        "format_uvl_response",
        "format_routing_decision",
        "format_uvl_stream_message",
        "get_agent_emoji"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.cli.command_handlers.chat_handler"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "typing",
      "names": [
        "List",
        "Dict"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "empirica.core.qdrant.vector_store",
      "names": [
        "init_collections",
        "upsert_docs",
        "upsert_memory"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.project_embed"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.goals.types",
      "names": [
        "Goal",
        "ScopeVector",
        "SuccessCriterion"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.types",
      "names": [
        "SubTask",
        "EpistemicImportance",
        "TaskStatus"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "uuid",
      "names": [
        "uuid"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.types",
      "names": [
        "TaskStatus"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.tasks.repository",
      "names": [
        "TaskRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.core.canonical.empirica_git",
      "names": [
        "GitGoalStore"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.integrations.beads",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.integrations.beads",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goal_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "parse_json_safely"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "empirica.core.goals.repository",
      "names": [
        "GoalRepository"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "empirica.integrations.branch_mapping",
      "names": [
        "get_branch_mapping"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "empirica.data.session_database",
      "names": [
        "SessionDatabase"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "cascade_commands",
      "names": [
        "handle_postflight_command"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "empirica.integrations.beads",
      "names": [
        "BeadsAdapter"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "handoff_commands",
      "names": [
        "handle_handoff_create_command"
      ],
      "source_file": "empirica.cli.command_handlers.goal_complete_command"
    },
    {
      "module": "__future__",
      "names": [
        "annotations"
      ],
      "source_file": "empirica.cli.command_handlers.doc_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.doc_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.doc_commands"
    },
    {
      "module": "empirica.core.docs.doc_planner",
      "names": [
        "compute_doc_plan"
      ],
      "source_file": "empirica.cli.command_handlers.doc_commands"
    },
    {
      "module": "empirica.core.docs.doc_planner",
      "names": [
        "compute_doc_plan"
      ],
      "source_file": "empirica.cli.command_handlers.doc_commands"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "signal",
      "names": [
        "signal"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "time",
      "names": [
        "time"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error",
        "print_header"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "psutil",
      "names": [
        "psutil"
      ],
      "source_file": "empirica.cli.command_handlers.mcp_commands"
    },
    {
      "module": "json",
      "names": [
        "json"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "sys",
      "names": [
        "sys"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "cli_utils",
      "names": [
        "handle_cli_error"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.checkpoint_signer",
      "names": [
        "CheckpointSigner"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.checkpoint_signer",
      "names": [
        "CheckpointSigner"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.identity",
      "names": [
        "AIIdentity"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.checkpoint_signer",
      "names": [
        "CheckpointSigner"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.checkpoint_signer",
      "names": [
        "CheckpointSigner"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "empirica.core.checkpoint_signer",
      "names": [
        "CheckpointSigner"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.cli.command_handlers.checkpoint_signing_commands"
    },
    {
      "module": "yaml",
      "names": [
        "yaml"
      ],
      "source_file": "empirica.cli.command_handlers.decision_utils"
    },
    {
      "module": "logging",
      "names": [
        "logging"
      ],
      "source_file": "empirica.cli.command_handlers.decision_utils"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.cli.command_handlers.decision_utils"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Tuple",
        "Optional"
      ],
      "source_file": "empirica.components.edit_verification.confidence_assessor"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.components.edit_verification.confidence_assessor"
    },
    {
      "module": "datetime",
      "names": [
        "datetime"
      ],
      "source_file": "empirica.components.edit_verification.confidence_assessor"
    },
    {
      "module": "confidence_assessor",
      "names": [
        "EditConfidenceAssessor"
      ],
      "source_file": "empirica.components.edit_verification.__init__"
    },
    {
      "module": "strategy_executor",
      "names": [
        "EditStrategyExecutor"
      ],
      "source_file": "empirica.components.edit_verification.__init__"
    },
    {
      "module": "subprocess",
      "names": [
        "subprocess"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "re",
      "names": [
        "re"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "typing",
      "names": [
        "Dict",
        "Optional",
        "Tuple"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "pathlib",
      "names": [
        "Path"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "asyncio",
      "names": [
        "asyncio"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "tempfile",
      "names": [
        "tempfile"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    },
    {
      "module": "os",
      "names": [
        "os"
      ],
      "source_file": "empirica.components.edit_verification.strategy_executor"
    }
  ],
  "db_tables": {},
  "cli_commands": {},
  "call_graph": {
    "empirica.cli.cli_utils.print_component_status": [
      "get",
      "lower",
      "print"
    ],
    "empirica.cli.cli_utils.format_uncertainty_output": [
      "append",
      "items",
      "sorted",
      "join"
    ],
    "empirica.cli.cli_utils.handle_cli_error": [
      "format_exc",
      "print"
    ],
    "empirica.cli.cli_utils.parse_json_safely": [
      "print",
      "loads"
    ],
    "empirica.cli.cli_utils.format_execution_time": [
      "time"
    ],
    "empirica.cli.cli_utils.validate_confidence_threshold": [],
    "empirica.cli.cli_utils.print_header": [
      "len",
      "print"
    ],
    "empirica.cli.cli_utils.print_separator": [
      "print"
    ],
    "empirica.cli.cli_utils.format_component_list": [
      "join",
      "append",
      "len",
      "get",
      "sum"
    ],
    "empirica.cli.uvl_formatter.get_confidence_color": [],
    "empirica.cli.uvl_formatter.get_agent_emoji": [
      "get",
      "lower"
    ],
    "empirica.cli.uvl_formatter.detect_state_modifier": [
      "hasattr",
      "get",
      "lower",
      "any"
    ],
    "empirica.cli.uvl_formatter.format_uvl_response": [
      "detect_state_modifier",
      "get_confidence_color",
      "run",
      "get_agent_emoji",
      "strip",
      "rstrip",
      "any",
      "get"
    ],
    "empirica.cli.uvl_formatter.format_routing_decision": [
      "title",
      "int",
      "items",
      "sorted",
      "len",
      "ljust",
      "get_agent_emoji"
    ],
    "empirica.cli.uvl_formatter.format_epistemic_delta": [
      "get",
      "abs",
      "upper"
    ],
    "empirica.cli.uvl_formatter.format_uvl_stream_message": [
      "detect_state_modifier",
      "isoformat",
      "get_agent_emoji",
      "utcnow",
      "get"
    ],
    "empirica.cli.simple_session_server.create_session": [
      "create",
      "_dashboard",
      "post"
    ],
    "empirica.cli.simple_session_server.execute_command": [
      "_list_files",
      "_run_bash",
      "_get_guidance",
      "_move_file",
      "isoformat",
      "_handle_plan_proposal",
      "_store_assessment",
      "post",
      "append",
      "utcnow",
      "execute_command",
      "get",
      "_read_file",
      "_prompt_assessment",
      "_dashboard"
    ],
    "empirica.cli.simple_session_server.get_dashboard": [
      "get",
      "HTTPException",
      "_dashboard"
    ],
    "empirica.cli.simple_session_server.list_sessions": [
      "get",
      "items",
      "len"
    ],
    "empirica.cli.simple_session_server.root": [
      "get",
      "len"
    ],
    "empirica.cli.simple_session_server.__init__": [
      "Path"
    ],
    "empirica.cli.simple_session_server.create": [
      "isoformat",
      "utcnow",
      "uuid4",
      "str"
    ],
    "empirica.cli.simple_session_server._list_files": [
      "iterdir",
      "str",
      "Path",
      "append",
      "is_dir",
      "len",
      "exists",
      "stat",
      "is_file"
    ],
    "empirica.cli.simple_session_server._read_file": [
      "str",
      "splitlines",
      "Path",
      "append",
      "len",
      "exists",
      "is_file",
      "read_text"
    ],
    "empirica.cli.simple_session_server._move_file": [
      "str",
      "isoformat",
      "mkdir",
      "Path",
      "append",
      "utcnow",
      "rename",
      "exists"
    ],
    "empirica.cli.simple_session_server._run_bash": [
      "run",
      "split",
      "str"
    ],
    "empirica.cli.simple_session_server._prompt_assessment": [
      "get"
    ],
    "empirica.cli.simple_session_server._store_assessment": [
      "get",
      "utcnow",
      "isoformat"
    ],
    "empirica.cli.simple_session_server._handle_plan_proposal": [
      "get",
      "utcnow",
      "isoformat"
    ],
    "empirica.cli.simple_session_server._get_guidance": [
      "append"
    ],
    "empirica.cli.simple_session_server._dashboard": [
      "_get_available_actions",
      "len",
      "_get_status_summary",
      "_get_recommended"
    ],
    "empirica.cli.simple_session_server._get_available_actions": [
      "append",
      "extend"
    ],
    "empirica.cli.simple_session_server._get_recommended": [],
    "empirica.cli.simple_session_server._get_status_summary": [
      "get"
    ],
    "empirica.cli.mcp_client.session_create": [
      "time",
      "str",
      "int",
      "__import__"
    ],
    "empirica.cli.mcp_client.call_mcp_tool": [],
    "empirica.cli.cli_core.create_argument_parser": [
      "_add_profile_parsers",
      "_add_component_parsers",
      "_add_session_parsers",
      "add_argument",
      "_add_checkpoint_parsers",
      "_add_performance_parsers",
      "_add_cascade_parsers",
      "_add_investigation_parsers",
      "_add_monitor_parsers",
      "_add_skill_parsers",
      "_add_action_parsers",
      "_add_user_interface_parsers",
      "ArgumentParser",
      "_add_utility_parsers",
      "_add_assessment_parsers",
      "_add_config_parsers",
      "add_subparsers"
    ],
    "empirica.cli.cli_core._add_assessment_parsers": [],
    "empirica.cli.cli_core._add_cascade_parsers": [
      "add_parser",
      "add_mutually_exclusive_group",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_investigation_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_performance_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_component_parsers": [],
    "empirica.cli.cli_core._add_skill_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_utility_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_config_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_monitor_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_mcp_parsers": [],
    "empirica.cli.cli_core._add_session_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_action_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_checkpoint_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core._add_profile_parsers": [],
    "empirica.cli.cli_core._add_user_interface_parsers": [
      "add_parser",
      "add_argument"
    ],
    "empirica.cli.cli_core.main": [
      "create_argument_parser",
      "print_help",
      "parse_args",
      "getattr",
      "print",
      "get",
      "handle_cli_error",
      "handler",
      "time"
    ],
    "empirica.cli.asyncio_fix.suppress_asyncio_warnings": [
      "filterwarnings"
    ],
    "empirica.cli.asyncio_fix.patch_asyncio_for_mcp": [
      "original_del",
      "all_tasks",
      "get_or_create_event_loop",
      "run_until_complete",
      "get_event_loop",
      "gather",
      "new_event_loop",
      "close",
      "suppress_asyncio_warnings",
      "is_closed",
      "set_event_loop",
      "register"
    ],
    "empirica.cli.asyncio_fix.get_or_create_event_loop": [
      "get_event_loop",
      "new_event_loop",
      "is_closed",
      "set_event_loop"
    ],
    "empirica.cli.asyncio_fix.cleanup_event_loop": [
      "all_tasks",
      "run_until_complete",
      "get_event_loop",
      "gather",
      "close",
      "is_closed"
    ],
    "empirica.cli.asyncio_fix.safe_del": [
      "original_del"
    ],
    "empirica.integrations.branch_mapping.get_branch_mapping": [
      "BranchMapping"
    ],
    "empirica.integrations.branch_mapping.__init__": [
      "_load_mappings",
      "_find_repo_root",
      "mkdir",
      "Path"
    ],
    "empirica.integrations.branch_mapping._find_repo_root": [
      "RuntimeError",
      "exists",
      "cwd",
      "str"
    ],
    "empirica.integrations.branch_mapping._load_mappings": [
      "open",
      "exists",
      "load"
    ],
    "empirica.integrations.branch_mapping._save_mappings": [
      "open",
      "dump"
    ],
    "empirica.integrations.branch_mapping.add_mapping": [
      "_save_mappings",
      "utcnow",
      "isoformat"
    ],
    "empirica.integrations.branch_mapping.get_mapping": [
      "get"
    ],
    "empirica.integrations.branch_mapping.get_branch_for_goal": [
      "items"
    ],
    "empirica.integrations.branch_mapping.remove_mapping": [
      "_save_mappings",
      "isoformat",
      "utcnow",
      "append"
    ],
    "empirica.integrations.branch_mapping.list_active_mappings": [
      "items"
    ],
    "empirica.integrations.branch_mapping.get_history": [],
    "empirica.reasoning.ollama_adapter.__init__": [],
    "empirica.reasoning.ollama_adapter._call_ollama": [
      "json",
      "raise_for_status",
      "error",
      "post"
    ],
    "empirica.reasoning.ollama_adapter._build_deprecation_prompt": [
      "get",
      "join"
    ],
    "empirica.reasoning.ollama_adapter._parse_deprecation_response": [
      "warning",
      "DeprecationJudgment",
      "str",
      "error",
      "loads",
      "float",
      "max",
      "get",
      "min"
    ],
    "empirica.reasoning.ollama_adapter.analyze_deprecation": [
      "DeprecationJudgment",
      "str",
      "error",
      "info",
      "_call_ollama",
      "_build_deprecation_prompt",
      "_parse_deprecation_response"
    ],
    "empirica.reasoning.ollama_adapter._build_relationship_prompt": [
      "get"
    ],
    "empirica.reasoning.ollama_adapter._parse_relationship_response": [
      "warning",
      "str",
      "RelationshipAnalysis",
      "error",
      "loads",
      "float",
      "max",
      "get",
      "min"
    ],
    "empirica.reasoning.ollama_adapter.analyze_relationship": [
      "_build_relationship_prompt",
      "str",
      "_parse_relationship_response",
      "RelationshipAnalysis",
      "error",
      "info",
      "_call_ollama",
      "get"
    ],
    "empirica.reasoning.ollama_adapter._build_implementation_gap_prompt": [
      "get"
    ],
    "empirica.reasoning.ollama_adapter._parse_implementation_gap_response": [
      "warning",
      "str",
      "error",
      "loads",
      "float",
      "ImplementationGap",
      "max",
      "get",
      "min"
    ],
    "empirica.reasoning.ollama_adapter.analyze_implementation_gap": [
      "str",
      "error",
      "_parse_implementation_gap_response",
      "info",
      "_call_ollama",
      "ImplementationGap",
      "get",
      "_build_implementation_gap_prompt"
    ],
    "empirica.reasoning.epistemic_cascade.create_default_cascade": [
      "EpistemicCascade"
    ],
    "empirica.reasoning.epistemic_cascade.__init__": [
      "OllamaReasoningModel",
      "info"
    ],
    "empirica.reasoning.epistemic_cascade.analyze_with_cascade": [
      "analyze_deprecation",
      "warning",
      "_create_human_review_judgment",
      "info"
    ],
    "empirica.reasoning.epistemic_cascade._create_human_review_judgment": [
      "DeprecationJudgment",
      "max"
    ],
    "empirica.reasoning.epistemic_cascade.analyze_batch_with_cascade": [
      "append",
      "len",
      "time",
      "analyze_with_cascade"
    ],
    "empirica.reasoning.service.analyze_deprecation": [],
    "empirica.reasoning.service.analyze_relationship": [],
    "empirica.reasoning.service.analyze_implementation_gap": [],
    "empirica.api.app.create_app": [
      "route",
      "errorhandler",
      "str",
      "error",
      "info",
      "jsonify",
      "register_blueprint",
      "Flask"
    ],
    "empirica.api.app.add_cors_headers": [],
    "empirica.api.app.health_check": [
      "route",
      "jsonify"
    ],
    "empirica.api.app.handle_error": [
      "jsonify",
      "errorhandler",
      "error",
      "str"
    ],
    "empirica.config.credentials_loader.get_credentials_loader": [
      "CredentialsLoader"
    ],
    "empirica.config.credentials_loader.__new__": [
      "__new__",
      "super"
    ],
    "empirica.config.credentials_loader.__init__": [
      "_load_credentials"
    ],
    "empirica.config.credentials_loader._find_config_file": [
      "Path",
      "home",
      "exists",
      "getenv"
    ],
    "empirica.config.credentials_loader._load_credentials": [
      "_load_from_dotfiles",
      "open",
      "warning",
      "error",
      "info",
      "_interpolate_env_vars",
      "len",
      "load",
      "get",
      "_find_config_file",
      "safe_load"
    ],
    "empirica.config.credentials_loader._interpolate_env_vars": [
      "getenv",
      "debug",
      "items",
      "replace_vars",
      "sub",
      "group",
      "isinstance"
    ],
    "empirica.config.credentials_loader._load_from_dotfiles": [
      "read",
      "open",
      "warning",
      "str",
      "debug",
      "items",
      "Path",
      "info",
      "strip",
      "exists"
    ],
    "empirica.config.credentials_loader.get_provider_config": [
      "get",
      "_load_credentials"
    ],
    "empirica.config.credentials_loader.get_api_key": [
      "get",
      "get_provider_config"
    ],
    "empirica.config.credentials_loader.get_base_url": [
      "get",
      "get_provider_config"
    ],
    "empirica.config.credentials_loader.get_headers": [
      "items",
      "get_provider_config",
      "replace",
      "isinstance",
      "get"
    ],
    "empirica.config.credentials_loader.get_default_model": [
      "get",
      "get_provider_config"
    ],
    "empirica.config.credentials_loader.get_available_models": [
      "get",
      "get_provider_config"
    ],
    "empirica.config.credentials_loader.validate_model": [
      "get_available_models"
    ],
    "empirica.config.credentials_loader.get_auth_method": [
      "get",
      "get_provider_config"
    ],
    "empirica.config.credentials_loader.list_providers": [
      "list",
      "get",
      "keys",
      "_load_credentials"
    ],
    "empirica.config.credentials_loader.reload": [
      "_load_credentials"
    ],
    "empirica.config.credentials_loader.replace_vars": [
      "getenv",
      "debug",
      "items",
      "replace_vars",
      "sub",
      "group",
      "isinstance"
    ],
    "empirica.config.credentials_loader.replacer": [
      "debug",
      "group",
      "getenv"
    ],
    "empirica.config.path_resolver.get_git_root": [
      "run",
      "strip",
      "Path"
    ],
    "empirica.config.path_resolver.load_empirica_config": [
      "get_git_root",
      "open",
      "warning",
      "debug",
      "exists",
      "safe_load"
    ],
    "empirica.config.path_resolver.get_empirica_root": [
      "load_empirica_config",
      "get_git_root",
      "getenv",
      "debug",
      "cwd",
      "Path",
      "resolve",
      "expanduser"
    ],
    "empirica.config.path_resolver.get_session_db_path": [
      "load_empirica_config",
      "getenv",
      "debug",
      "get_empirica_root",
      "Path",
      "resolve",
      "expanduser"
    ],
    "empirica.config.path_resolver.get_identity_dir": [
      "load_empirica_config",
      "get_empirica_root"
    ],
    "empirica.config.path_resolver.get_metrics_dir": [
      "load_empirica_config",
      "get_empirica_root"
    ],
    "empirica.config.path_resolver.get_messages_dir": [
      "load_empirica_config",
      "get_empirica_root"
    ],
    "empirica.config.path_resolver.ensure_empirica_structure": [
      "debug",
      "get_empirica_root",
      "mkdir"
    ],
    "empirica.config.path_resolver.create_default_config": [
      "get_git_root",
      "open",
      "str",
      "debug",
      "mkdir",
      "dump",
      "info",
      "exists"
    ],
    "empirica.config.path_resolver.debug_paths": [
      "load_empirica_config",
      "get_git_root",
      "get_messages_dir",
      "str",
      "get_identity_dir",
      "getenv",
      "get_session_db_path",
      "get_empirica_root",
      "get_metrics_dir"
    ],
    "empirica.config.project_config_loader.load_project_config": [
      "open",
      "debug",
      "error",
      "cwd",
      "info",
      "exists",
      "get",
      "ProjectConfig",
      "safe_load"
    ],
    "empirica.config.project_config_loader.get_current_subject": [
      "load_project_config",
      "get_subject_for_path",
      "cwd",
      "str"
    ],
    "empirica.config.project_config_loader.__init__": [
      "get"
    ],
    "empirica.config.project_config_loader.get_subject_for_path": [
      "debug",
      "items",
      "Path",
      "info",
      "relative_to",
      "resolve",
      "get"
    ],
    "empirica.config.project_config_loader.get_subject_info": [
      "get"
    ],
    "empirica.config.project_config_loader.list_subjects": [
      "list",
      "keys"
    ],
    "empirica.config.memory_gap_policy_loader.get_policy_loader": [
      "MemoryGapPolicyLoader"
    ],
    "empirica.config.memory_gap_policy_loader.get_memory_gap_policy": [
      "get_policy",
      "get_policy_loader"
    ],
    "empirica.config.memory_gap_policy_loader.get_enforcement_for_gap": [
      "get",
      "get_enforcement_for_gap",
      "get_policy_loader"
    ],
    "empirica.config.memory_gap_policy_loader.__init__": [
      "_load_configurations",
      "Path"
    ],
    "empirica.config.memory_gap_policy_loader._load_configurations": [
      "_load_hardcoded_defaults",
      "open",
      "warning",
      "error",
      "info",
      "len",
      "exists",
      "get",
      "safe_load"
    ],
    "empirica.config.memory_gap_policy_loader._load_hardcoded_defaults": [
      "warning"
    ],
    "empirica.config.memory_gap_policy_loader.get_policy": [
      "get",
      "items",
      "keys",
      "warning"
    ],
    "empirica.config.memory_gap_policy_loader.list_enforcement_modes": [
      "get",
      "items"
    ],
    "empirica.config.memory_gap_policy_loader.list_scope_policies": [
      "get",
      "items"
    ],
    "empirica.config.goal_scope_loader.get_scope_recommendations": [
      "get_scope_recommendations",
      "_calculate_pattern_match",
      "_apply_context_adjustments",
      "GoalScopeLoader",
      "items",
      "debug",
      "info",
      "_get_conservative_defaults",
      "get"
    ],
    "empirica.config.goal_scope_loader.validate_scope_coherence": [
      "GoalScopeLoader",
      "items",
      "append",
      "validate_scope_coherence",
      "len",
      "get"
    ],
    "empirica.config.goal_scope_loader.__init__": [
      "_load_configurations",
      "Path"
    ],
    "empirica.config.goal_scope_loader._load_configurations": [
      "_load_hardcoded_defaults",
      "open",
      "warning",
      "error",
      "info",
      "len",
      "exists",
      "get",
      "safe_load"
    ],
    "empirica.config.goal_scope_loader._load_hardcoded_defaults": [
      "warning"
    ],
    "empirica.config.goal_scope_loader._calculate_pattern_match": [
      "items",
      "max"
    ],
    "empirica.config.goal_scope_loader._apply_context_adjustments": [
      "get",
      "min",
      "deepcopy",
      "max"
    ],
    "empirica.config.goal_scope_loader._get_conservative_defaults": [
      "get",
      "min",
      "max"
    ],
    "empirica.config.goal_scope_loader.list_available_patterns": [
      "get",
      "items"
    ],
    "empirica.config.profile_loader.get_profile_loader": [
      "ProfileLoader"
    ],
    "empirica.config.profile_loader.load_profile": [
      "get_profile",
      "ValueError",
      "get_profile_loader"
    ],
    "empirica.config.profile_loader.select_profile": [
      "list",
      "get_profile_loader",
      "items",
      "values",
      "any",
      "get",
      "lower",
      "select_profile"
    ],
    "empirica.config.profile_loader.to_dict": [],
    "empirica.config.profile_loader.__init__": [
      "load_config",
      "exists",
      "Path"
    ],
    "empirica.config.profile_loader.load_config": [
      "_parse_profile",
      "open",
      "items",
      "get",
      "safe_load",
      "UniversalConstraints"
    ],
    "empirica.config.profile_loader._parse_profile": [
      "InvestigationConstraints",
      "LearningConfig",
      "PostflightMode",
      "DomainDetection",
      "InvestigationProfile",
      "TuningParameters",
      "ActionThresholds",
      "ToolSuggestionMode",
      "isinstance",
      "get",
      "StrategyConfig"
    ],
    "empirica.config.profile_loader.get_profile": [
      "get"
    ],
    "empirica.config.profile_loader.list_profiles": [
      "list",
      "keys"
    ],
    "empirica.config.profile_loader.validate_constraints": [],
    "empirica.config.profile_loader.export_profile": [
      "open",
      "to_dict",
      "dump",
      "ValueError",
      "get_profile"
    ],
    "empirica.config.profile_loader.import_profile": [
      "get",
      "_parse_profile",
      "open",
      "safe_load"
    ],
    "empirica.config.threshold_loader.get_threshold_config": [
      "get_instance"
    ],
    "empirica.config.threshold_loader.load_profile": [
      "list",
      "keys",
      "error",
      "info",
      "get_threshold_config",
      "get",
      "load_profile"
    ],
    "empirica.config.threshold_loader.get_threshold": [
      "get",
      "get_threshold_config"
    ],
    "empirica.config.threshold_loader.override_threshold": [
      "get_threshold_config",
      "override"
    ],
    "empirica.config.threshold_loader.__init__": [
      "_load_profiles",
      "Path"
    ],
    "empirica.config.threshold_loader.get_instance": [
      "cls"
    ],
    "empirica.config.threshold_loader.reset_instance": [],
    "empirica.config.threshold_loader._load_profiles": [
      "_load_hardcoded_defaults",
      "open",
      "warning",
      "error",
      "info",
      "len",
      "exists",
      "get",
      "safe_load"
    ],
    "empirica.config.threshold_loader._load_hardcoded_defaults": [
      "error",
      "warning",
      "info"
    ],
    "empirica.config.threshold_loader.get": [
      "isinstance",
      "split"
    ],
    "empirica.config.threshold_loader.override": [
      "info"
    ],
    "empirica.config.threshold_loader.clear_overrides": [
      "len",
      "info"
    ],
    "empirica.config.threshold_loader.create_custom_profile": [
      "items",
      "error",
      "_set_nested_value",
      "deepcopy",
      "info",
      "len"
    ],
    "empirica.config.threshold_loader._set_nested_value": [
      "setdefault",
      "split"
    ],
    "empirica.config.threshold_loader.get_profile_info": [
      "get",
      "len"
    ],
    "empirica.config.threshold_loader.list_profiles": [
      "get",
      "items"
    ],
    "empirica.config.threshold_loader.get_all_thresholds": [
      "items",
      "deepcopy",
      "_set_nested_value"
    ],
    "empirica.config.threshold_loader.export_for_handoff": [],
    "empirica.dashboard.cascade_monitor.main": [
      "CascadeMonitor",
      "mkdir",
      "print",
      "watch_for_updates"
    ],
    "empirica.dashboard.cascade_monitor.__init__": [
      "SessionDatabase"
    ],
    "empirica.dashboard.cascade_monitor.get_active_cascade": [
      "cursor",
      "execute",
      "fetchone",
      "dict"
    ],
    "empirica.dashboard.cascade_monitor.get_latest_cascade": [
      "cursor",
      "execute",
      "fetchone",
      "dict"
    ],
    "empirica.dashboard.cascade_monitor.get_assessments": [
      "cursor",
      "execute",
      "fetchone",
      "dict"
    ],
    "empirica.dashboard.cascade_monitor.format_vector_state": [
      "get",
      "get_confidence_color",
      "upper"
    ],
    "empirica.dashboard.cascade_monitor.format_phase_progress": [
      "get",
      "join",
      "append"
    ],
    "empirica.dashboard.cascade_monitor.calculate_delta": [
      "get",
      "keys",
      "loads"
    ],
    "empirica.dashboard.cascade_monitor.format_delta_indicator": [
      "abs"
    ],
    "empirica.dashboard.cascade_monitor.render_markdown": [
      "get_confidence_color",
      "strftime",
      "get_latest_cascade",
      "get_active_cascade",
      "items",
      "len",
      "upper",
      "get",
      "list",
      "fromkeys",
      "calculate_delta",
      "get_assessments",
      "append",
      "format_delta_indicator",
      "format_vector_state",
      "abs",
      "join",
      "loads",
      "format_phase_progress"
    ],
    "empirica.dashboard.cascade_monitor.render_with_glow": [
      "render_markdown",
      "run"
    ],
    "empirica.dashboard.cascade_monitor.display": [
      "render_with_glow",
      "print"
    ],
    "empirica.dashboard.cascade_monitor.watch_for_updates": [
      "sleep",
      "display",
      "get_active_cascade",
      "exists",
      "stat",
      "print"
    ],
    "empirica.dashboard.snapshot_monitor.launch_dashboard": [
      "SnapshotMonitor",
      "print_exc",
      "wrapper",
      "print"
    ],
    "empirica.dashboard.snapshot_monitor.__init__": [
      "get_instance",
      "time",
      "EpistemicSnapshotProvider"
    ],
    "empirica.dashboard.snapshot_monitor.get_color_for_reliability": [],
    "empirica.dashboard.snapshot_monitor.get_status_label": [],
    "empirica.dashboard.snapshot_monitor.format_bar": [
      "int"
    ],
    "empirica.dashboard.snapshot_monitor.draw_header": [
      "len",
      "getmaxyx",
      "addstr"
    ],
    "empirica.dashboard.snapshot_monitor.draw_compression_status": [
      "estimate_memory_reliability",
      "format_bar",
      "len",
      "getmaxyx",
      "addstr",
      "get_status_label"
    ],
    "empirica.dashboard.snapshot_monitor.draw_snapshot_timeline": [
      "abs",
      "estimate_memory_reliability",
      "items",
      "enumerate",
      "strftime",
      "join",
      "append",
      "len",
      "color_pair",
      "getmaxyx",
      "addstr",
      "get",
      "upper",
      "fromisoformat"
    ],
    "empirica.dashboard.snapshot_monitor.draw_commands": [
      "getmaxyx",
      "addstr"
    ],
    "empirica.dashboard.snapshot_monitor.draw_details": [
      "draw_commands",
      "clear",
      "draw_header",
      "format_bar",
      "getmaxyx",
      "addstr",
      "get",
      "upper"
    ],
    "empirica.dashboard.snapshot_monitor.export_snapshot": [
      "absolute",
      "open",
      "str",
      "int",
      "to_json",
      "Path",
      "write",
      "time"
    ],
    "empirica.dashboard.snapshot_monitor.main_loop": [
      "sleep",
      "draw_compression_status",
      "get_latest_snapshot",
      "nodelay",
      "ord",
      "draw_commands",
      "getch",
      "refresh",
      "clear",
      "timeout",
      "init_pair",
      "start_color",
      "getmaxyx",
      "time",
      "draw_snapshot_timeline",
      "draw_header",
      "str",
      "addstr",
      "curs_set",
      "export_snapshot",
      "color_pair",
      "draw_details",
      "get_snapshot_history"
    ],
    "empirica.core.epistemic_bus.get_global_bus": [
      "EpistemicBus"
    ],
    "empirica.core.epistemic_bus.set_global_bus": [],
    "empirica.core.epistemic_bus.__init__": [
      "time"
    ],
    "empirica.core.epistemic_bus.to_dict": [],
    "empirica.core.epistemic_bus.__repr__": [],
    "empirica.core.epistemic_bus.handle_event": [
      "callback",
      "log"
    ],
    "empirica.core.epistemic_bus.subscribe": [
      "type",
      "info",
      "append",
      "isinstance",
      "TypeError"
    ],
    "empirica.core.epistemic_bus.unsubscribe": [
      "remove",
      "info"
    ],
    "empirica.core.epistemic_bus.publish": [
      "debug",
      "error",
      "handle_event"
    ],
    "empirica.core.epistemic_bus.get_observer_count": [
      "len"
    ],
    "empirica.core.epistemic_bus.get_event_count": [],
    "empirica.core.epistemic_bus.clear_observers": [
      "info",
      "clear"
    ],
    "empirica.core.thresholds._get_config": [
      "get_threshold_config",
      "warning"
    ],
    "empirica.core.thresholds._get_threshold": [
      "get",
      "_get_config"
    ],
    "empirica.core.thresholds.get_engagement_threshold": [
      "_get_threshold"
    ],
    "empirica.core.thresholds.get_critical_thresholds": [
      "_get_threshold"
    ],
    "empirica.core.thresholds.get_cascade_max_rounds": [
      "_get_threshold"
    ],
    "empirica.core.thresholds.get_check_confidence_threshold": [
      "_get_threshold"
    ],
    "empirica.core.thresholds.reload_thresholds": [
      "get_critical_thresholds",
      "_get_threshold",
      "info"
    ],
    "empirica.core.memory_gap_detector.get_policy_loader": [
      "_get_loader",
      "warning"
    ],
    "empirica.core.memory_gap_detector.__init__": [
      "warning",
      "get_policy",
      "info",
      "get",
      "get_policy_loader"
    ],
    "empirica.core.memory_gap_detector.detect_gaps": [
      "_determine_enforcement",
      "MemoryGapReport",
      "_check_file_awareness",
      "MemoryGap",
      "_suggest_actions",
      "_check_compaction",
      "append",
      "len",
      "isinstance",
      "_calculate_expected_knowledge",
      "max",
      "get",
      "_check_findings",
      "_check_unknowns"
    ],
    "empirica.core.memory_gap_detector._check_findings": [
      "_referenced_in_session",
      "str",
      "MemoryGap",
      "get_finding_text",
      "append",
      "len",
      "isinstance",
      "get",
      "min"
    ],
    "empirica.core.memory_gap_detector._check_unknowns": [
      "str",
      "MemoryGap",
      "append",
      "get_unknown_text",
      "len",
      "isinstance",
      "_incorporated_in_session",
      "get",
      "min"
    ],
    "empirica.core.memory_gap_detector._check_file_awareness": [
      "MemoryGap",
      "_mentioned_in_session",
      "append",
      "len",
      "get",
      "min"
    ],
    "empirica.core.memory_gap_detector._check_compaction": [
      "get",
      "MemoryGap",
      "len",
      "sum"
    ],
    "empirica.core.memory_gap_detector._calculate_expected_knowledge": [
      "_calculate_signal_confidence",
      "len",
      "isinstance",
      "max",
      "get",
      "min"
    ],
    "empirica.core.memory_gap_detector._calculate_signal_confidence": [
      "items",
      "min",
      "sum"
    ],
    "empirica.core.memory_gap_detector._determine_enforcement": [
      "get"
    ],
    "empirica.core.memory_gap_detector._suggest_actions": [
      "get",
      "append"
    ],
    "empirica.core.memory_gap_detector.apply_enforcement": [
      "copy",
      "warning",
      "info",
      "append",
      "get"
    ],
    "empirica.core.memory_gap_detector._referenced_in_session": [
      "get"
    ],
    "empirica.core.memory_gap_detector._incorporated_in_session": [
      "get"
    ],
    "empirica.core.memory_gap_detector._mentioned_in_session": [
      "get"
    ],
    "empirica.core.memory_gap_detector.get_finding_text": [
      "get",
      "isinstance",
      "str"
    ],
    "empirica.core.memory_gap_detector.get_unknown_text": [
      "get",
      "isinstance",
      "str"
    ],
    "empirica.core.context_load_balancer.__init__": [],
    "empirica.core.context_load_balancer.calculate_context_budget": [
      "get",
      "_match_skills_to_task",
      "_select_mco_configs",
      "_calculate_dynamic_budget"
    ],
    "empirica.core.context_load_balancer._calculate_dynamic_budget": [],
    "empirica.core.context_load_balancer._select_mco_configs": [
      "get",
      "lower"
    ],
    "empirica.core.context_load_balancer._match_skills_to_task": [
      "append",
      "lower"
    ],
    "empirica.core.context_load_balancer.estimate_tokens": [
      "len",
      "split",
      "int"
    ],
    "empirica.core.context_load_balancer.validate_budget": [
      "get",
      "warning"
    ],
    "empirica.core.checkpoint_signer.__init__": [
      "warning",
      "load_keypair",
      "cwd",
      "info",
      "AIIdentity"
    ],
    "empirica.core.checkpoint_signer.sign_checkpoint": [
      "str",
      "hex",
      "sign",
      "run",
      "public_key_hex",
      "isoformat",
      "info",
      "now",
      "strip",
      "encode",
      "dumps"
    ],
    "empirica.core.checkpoint_signer.verify_checkpoint": [
      "warning",
      "str",
      "run",
      "verify",
      "loads",
      "info",
      "strip",
      "get",
      "encode",
      "fromhex"
    ],
    "empirica.core.checkpoint_signer.list_signed_checkpoints": [
      "int",
      "run",
      "sorted",
      "split",
      "error",
      "loads",
      "append",
      "strip",
      "len",
      "get"
    ],
    "empirica.utils.doc_code_integrity.analyze_project_integrity": [
      "DocCodeIntegrityAnalyzer",
      "get_detailed_gaps"
    ],
    "empirica.utils.doc_code_integrity.analyze_complete_integrity": [
      "DocCodeIntegrityAnalyzer",
      "get_detailed_gaps"
    ],
    "empirica.utils.doc_code_integrity.__init__": [
      "cwd",
      "Path"
    ],
    "empirica.utils.doc_code_integrity.analyze_cli_commands": [
      "list",
      "sorted",
      "_get_actual_cli_commands",
      "len",
      "_calculate_integrity_score",
      "_get_documented_cli_commands"
    ],
    "empirica.utils.doc_code_integrity._get_actual_cli_commands": [
      "add",
      "match",
      "startswith",
      "warning",
      "run",
      "search",
      "split",
      "group",
      "strip",
      "set"
    ],
    "empirica.utils.doc_code_integrity._get_documented_cli_commands": [
      "findall",
      "debug",
      "update",
      "exists",
      "compile",
      "read_text",
      "rglob",
      "set"
    ],
    "empirica.utils.doc_code_integrity._calculate_integrity_score": [
      "len"
    ],
    "empirica.utils.doc_code_integrity.get_detailed_gaps": [
      "_find_command_mentions",
      "analyze_cli_commands",
      "len",
      "append"
    ],
    "empirica.utils.doc_code_integrity._find_command_mentions": [
      "escape",
      "match",
      "str",
      "enumerate",
      "split",
      "append",
      "strip",
      "exists",
      "relative_to",
      "compile",
      "read_text",
      "rglob"
    ],
    "empirica.utils.deprecation_detector.analyze_deprecation": [
      "generate_deprecation_report",
      "DeprecationDetector"
    ],
    "empirica.utils.deprecation_detector.__init__": [
      "cwd",
      "Path"
    ],
    "empirica.utils.deprecation_detector.detect_explicit_deprecation": [
      "str",
      "search",
      "_extract_feature_from_context",
      "split",
      "enumerate",
      "append",
      "strip",
      "exists",
      "relative_to",
      "read_text",
      "rglob"
    ],
    "empirica.utils.deprecation_detector._extract_feature_from_context": [
      "search",
      "group"
    ],
    "empirica.utils.deprecation_detector.detect_unused_features": [
      "cursor",
      "fetchall",
      "add",
      "format",
      "str",
      "split",
      "close",
      "loads",
      "append",
      "print",
      "replace",
      "SessionDatabase",
      "_is_core_feature",
      "execute",
      "DocCodeIntegrityAnalyzer",
      "set",
      "_get_documented_cli_commands"
    ],
    "empirica.utils.deprecation_detector._is_core_feature": [],
    "empirica.utils.deprecation_detector.detect_stale_code": [
      "list",
      "glob",
      "str",
      "int",
      "run",
      "strftime",
      "append",
      "now",
      "strip",
      "relative_to",
      "timedelta",
      "fromtimestamp",
      "min",
      "print"
    ],
    "empirica.utils.deprecation_detector.generate_deprecation_report": [
      "detect_explicit_deprecation",
      "detect_stale_code",
      "len",
      "detect_unused_features"
    ],
    "empirica.utils.session_resolver.resolve_session_id": [
      "cursor",
      "startswith",
      "warning",
      "debug",
      "error",
      "split",
      "close",
      "append",
      "info",
      "fetchone",
      "SessionDatabase",
      "_resolve_partial_uuid",
      "ValueError",
      "execute"
    ],
    "empirica.utils.session_resolver._resolve_partial_uuid": [
      "cursor",
      "fetchall",
      "warning",
      "debug",
      "error",
      "close",
      "len",
      "SessionDatabase",
      "ValueError",
      "execute"
    ],
    "empirica.utils.session_resolver.get_latest_session_id": [
      "append",
      "resolve_session_id",
      "join"
    ],
    "empirica.utils.session_resolver.is_session_alias": [
      "startswith"
    ],
    "empirica.utils.finding_refs.get_current_git_commit": [
      "run",
      "strip"
    ],
    "empirica.utils.finding_refs.parse_file_references": [
      "append",
      "group",
      "int",
      "finditer"
    ],
    "empirica.utils.finding_refs.parse_doc_references": [
      "append",
      "group",
      "finditer"
    ],
    "empirica.utils.finding_refs.parse_url_references": [
      "list",
      "set",
      "findall"
    ],
    "empirica.utils.finding_refs.structure_finding": [
      "parse_doc_references",
      "parse_url_references",
      "get_current_git_commit",
      "parse_file_references"
    ],
    "empirica.utils.finding_refs.structure_findings_list": [
      "structure_finding",
      "get_current_git_commit"
    ],
    "empirica.utils.finding_refs.filter_findings_by_file": [
      "get",
      "any"
    ],
    "empirica.utils.finding_refs.filter_findings_by_commit": [
      "get"
    ],
    "empirica.utils.finding_refs.get_file_refs_from_findings": [
      "list",
      "add",
      "sorted",
      "get",
      "set"
    ],
    "empirica.plugins.dashboard_spawner.get_spawner": [
      "DashboardSpawner"
    ],
    "empirica.plugins.dashboard_spawner.spawn_dashboard_if_possible": [
      "debug",
      "info",
      "get_spawner",
      "get",
      "spawn_dashboard"
    ],
    "empirica.plugins.dashboard_spawner.check_dashboard_status": [
      "get_dashboard_status",
      "get_spawner"
    ],
    "empirica.plugins.dashboard_spawner.spawn_dashboard": [
      "_get_current_session_name",
      "warning",
      "select_pane",
      "is_tmux_available",
      "sleep",
      "send_keys",
      "str",
      "get_dashboard_status",
      "find_where",
      "split_window",
      "error",
      "get_spawner",
      "len",
      "Server",
      "get",
      "spawn_dashboard",
      "is_libtmux_available"
    ],
    "empirica.plugins.dashboard_spawner._auto_spawn_on_import": [
      "is_tmux_available",
      "get_dashboard_status",
      "get_spawner",
      "info",
      "get",
      "spawn_dashboard",
      "is_libtmux_available"
    ],
    "empirica.plugins.dashboard_spawner.__init__": [
      "_find_empirica_root"
    ],
    "empirica.plugins.dashboard_spawner._find_empirica_root": [
      "exists",
      "cwd",
      "resolve",
      "Path"
    ],
    "empirica.plugins.dashboard_spawner.is_tmux_available": [
      "get",
      "bool"
    ],
    "empirica.plugins.dashboard_spawner.is_libtmux_available": [],
    "empirica.plugins.dashboard_spawner.get_dashboard_status": [
      "str",
      "is_tmux_available",
      "debug",
      "Server",
      "get",
      "is_libtmux_available"
    ],
    "empirica.plugins.dashboard_spawner._get_current_session_name": [
      "get",
      "strip",
      "debug",
      "run"
    ],
    "empirica.plugins.base_plugin.initialize": [],
    "empirica.plugins.base_plugin.health_check": [],
    "empirica.plugins.base_plugin.get_metadata": [],
    "empirica.plugins.base_plugin.cleanup": [],
    "empirica.investigation.investigation_plugin.create_jira_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.investigation.investigation_plugin.create_confluence_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.investigation.investigation_plugin.create_slack_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.investigation.investigation_plugin.create_github_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.investigation.investigation_plugin.create_database_query_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.investigation.investigation_plugin.create_common_plugins": [
      "create_slack_plugin",
      "create_jira_plugin",
      "create_github_plugin",
      "create_confluence_plugin"
    ],
    "empirica.investigation.investigation_plugin.__post_init__": [
      "ValueError"
    ],
    "empirica.investigation.investigation_plugin.to_capability_dict": [],
    "empirica.investigation.investigation_plugin.__repr__": [
      "len"
    ],
    "empirica.investigation.investigation_plugin.__init__": [],
    "empirica.investigation.investigation_plugin.register": [
      "ValueError",
      "info"
    ],
    "empirica.investigation.investigation_plugin.unregister": [
      "info"
    ],
    "empirica.investigation.investigation_plugin.get": [
      "get"
    ],
    "empirica.investigation.investigation_plugin.list_plugins": [
      "list",
      "keys"
    ],
    "empirica.investigation.investigation_plugin.get_all_capabilities": [
      "items",
      "to_capability_dict"
    ],
    "empirica.investigation.investigation_plugin.find_by_vector": [
      "values"
    ],
    "empirica.investigation.investigation_plugin.__len__": [
      "len"
    ],
    "empirica.metrics.token_efficiency.__init__": [
      "mkdir",
      "Path"
    ],
    "empirica.metrics.token_efficiency.measure_context_load": [
      "isoformat",
      "TokenMeasurement",
      "append",
      "info",
      "_count_tokens",
      "now"
    ],
    "empirica.metrics.token_efficiency._count_tokens": [
      "len",
      "split",
      "int"
    ],
    "empirica.metrics.token_efficiency.get_phase_total": [
      "sum"
    ],
    "empirica.metrics.token_efficiency.get_session_total": [
      "sum"
    ],
    "empirica.metrics.token_efficiency.calculate_reduction": [
      "round"
    ],
    "empirica.metrics.token_efficiency.compare_efficiency": [
      "isoformat",
      "values",
      "get_session_total",
      "now",
      "calculate_reduction",
      "get",
      "get_phase_total",
      "sum"
    ],
    "empirica.metrics.token_efficiency.export_report": [
      "open",
      "_format_csv_report",
      "mkdir",
      "info",
      "Path",
      "compare_efficiency",
      "_format_markdown_report",
      "ValueError",
      "write",
      "dumps"
    ],
    "empirica.metrics.token_efficiency._format_markdown_report": [
      "items",
      "enumerate",
      "join",
      "append",
      "len",
      "extend"
    ],
    "empirica.metrics.token_efficiency._format_csv_report": [
      "append",
      "items",
      "join"
    ],
    "empirica.metrics.token_efficiency.save_measurements": [
      "open",
      "isoformat",
      "dump",
      "info",
      "now",
      "asdict"
    ],
    "empirica.metrics.token_efficiency.load_measurements": [
      "open",
      "error",
      "TokenMeasurement",
      "info",
      "len",
      "exists",
      "load"
    ],
    "empirica.integration.empirica_action_hooks.track_component_usage": [
      "func",
      "update_chain_of_thought",
      "EmpiricaActionHooks",
      "update_12d_monitor",
      "wraps",
      "isinstance",
      "get"
    ],
    "empirica.integration.empirica_action_hooks.track_cascade_phase": [
      "func",
      "update_chain_of_thought",
      "update_cascade_status",
      "EmpiricaActionHooks",
      "wraps",
      "get"
    ],
    "empirica.integration.empirica_action_hooks.log_cascade_phase": [
      "update_cascade_status",
      "EmpiricaActionHooks"
    ],
    "empirica.integration.empirica_action_hooks.log_12d_state": [
      "update_12d_monitor",
      "EmpiricaActionHooks"
    ],
    "empirica.integration.empirica_action_hooks.log_thought": [
      "update_chain_of_thought",
      "EmpiricaActionHooks"
    ],
    "empirica.integration.empirica_action_hooks.log_statusline": [
      "update_statusline_cache",
      "EmpiricaActionHooks"
    ],
    "empirica.integration.empirica_action_hooks.initialize_tmux_dashboard": [
      "create_session",
      "session_exists",
      "TMuxDashboardManager",
      "create_dashboard_window",
      "start_dashboard_monitoring",
      "print"
    ],
    "empirica.integration.empirica_action_hooks.trigger_pane_update": [
      "get",
      "run"
    ],
    "empirica.integration.empirica_action_hooks.update_12d_monitor": [
      "open",
      "dump",
      "print",
      "isinstance",
      "trigger_pane_update",
      "upper",
      "get",
      "lower",
      "time"
    ],
    "empirica.integration.empirica_action_hooks.update_cascade_status": [
      "open",
      "time",
      "dump",
      "trigger_pane_update",
      "get",
      "print"
    ],
    "empirica.integration.empirica_action_hooks.update_chain_of_thought": [
      "open",
      "dump",
      "print",
      "exists",
      "trigger_pane_update",
      "load",
      "get",
      "time"
    ],
    "empirica.integration.empirica_action_hooks.update_snapshot_status": [
      "open",
      "dump",
      "print",
      "trigger_pane_update",
      "get",
      "time"
    ],
    "empirica.integration.empirica_action_hooks.update_statusline_cache": [
      "open",
      "getenv",
      "dump",
      "print",
      "trigger_pane_update",
      "time"
    ],
    "empirica.integration.empirica_action_hooks.decorator": [
      "func",
      "update_chain_of_thought",
      "update_cascade_status",
      "EmpiricaActionHooks",
      "update_12d_monitor",
      "wraps",
      "isinstance",
      "get"
    ],
    "empirica.integration.empirica_action_hooks.wrapper": [
      "func",
      "update_chain_of_thought",
      "update_cascade_status",
      "EmpiricaActionHooks",
      "update_12d_monitor",
      "wraps",
      "isinstance",
      "get"
    ],
    "empirica.integration.empirica_action_hooks.get_nested_value": [
      "get",
      "lower",
      "isinstance",
      "upper"
    ],
    "empirica.data.session_json_handler.__init__": [
      "info",
      "mkdir",
      "Path"
    ],
    "empirica.data.session_json_handler.export_session": [
      "get_session",
      "open",
      "get_session_cascades",
      "dump",
      "info",
      "append",
      "loads",
      "ValueError",
      "_get_cascade_assessments_summary",
      "get",
      "bool"
    ],
    "empirica.data.session_json_handler.export_cascade_graph": [
      "cursor",
      "open",
      "dict",
      "dump",
      "info",
      "get_cascade_assessments",
      "append",
      "next",
      "range",
      "fetchone",
      "ValueError",
      "get",
      "execute",
      "bool"
    ],
    "empirica.data.session_json_handler.load_session_context": [
      "open",
      "warning",
      "exists",
      "load"
    ],
    "empirica.data.session_json_handler.read_synthesis_history": [
      "cursor",
      "fetchall",
      "_extract_reasoning_summary",
      "get_session_cascades",
      "close",
      "append",
      "SessionDatabase",
      "execute"
    ],
    "empirica.data.session_json_handler._extract_reasoning_summary": [
      "get",
      "len",
      "values",
      "sum"
    ],
    "empirica.data.session_json_handler.create_compact_summary": [
      "cursor",
      "get_session",
      "dict",
      "get_session_cascades",
      "len",
      "fetchone",
      "execute",
      "bool"
    ],
    "empirica.data.session_json_handler._get_cascade_assessments_summary": [
      "get_cascade_assessments",
      "append"
    ],
    "empirica.data.session_database.__init__": [
      "GoalRepository",
      "ProjectRepository",
      "str",
      "get_session_db_path",
      "mkdir",
      "_create_tables",
      "Path",
      "BreadcrumbRepository",
      "info",
      "connect",
      "BranchRepository"
    ],
    "empirica.data.session_database._validate_session_id": [
      "UUID",
      "ValueError"
    ],
    "empirica.data.session_database._create_tables": [
      "cursor",
      "commit",
      "fetchone",
      "execute",
      "_migrate_legacy_tables_to_reflexes"
    ],
    "empirica.data.session_database._migrate_legacy_tables_to_reflexes": [
      "cursor",
      "debug",
      "error",
      "info",
      "commit",
      "fetchone",
      "execute"
    ],
    "empirica.data.session_database.create_session": [
      "cursor",
      "str",
      "commit",
      "now",
      "execute",
      "uuid4"
    ],
    "empirica.data.session_database.end_session": [
      "cursor",
      "commit",
      "now",
      "_validate_session_id",
      "execute"
    ],
    "empirica.data.session_database.create_cascade": [
      "cursor",
      "str",
      "commit",
      "now",
      "_validate_session_id",
      "execute",
      "uuid4",
      "dumps"
    ],
    "empirica.data.session_database.update_cascade_phase": [
      "cursor",
      "execute",
      "commit",
      "ValueError"
    ],
    "empirica.data.session_database.complete_cascade": [
      "cursor",
      "execute",
      "now",
      "commit"
    ],
    "empirica.data.session_database.log_epistemic_assessment": [
      "cursor",
      "store_vectors",
      "warning",
      "error",
      "fetchone",
      "upper",
      "execute"
    ],
    "empirica.data.session_database.log_divergence": [
      "cursor",
      "str",
      "commit",
      "get",
      "execute",
      "uuid4",
      "dumps"
    ],
    "empirica.data.session_database.log_bayesian_belief": [
      "cursor",
      "str",
      "commit",
      "now",
      "execute",
      "uuid4"
    ],
    "empirica.data.session_database.log_tool_execution": [
      "cursor",
      "str",
      "commit",
      "execute",
      "uuid4",
      "dumps"
    ],
    "empirica.data.session_database.get_session": [
      "cursor",
      "execute",
      "fetchone",
      "dict"
    ],
    "empirica.data.session_database.get_session_cascades": [
      "cursor",
      "execute",
      "dict",
      "fetchall"
    ],
    "empirica.data.session_database.get_cascade_assessments": [
      "cursor",
      "execute",
      "dict",
      "fetchall"
    ],
    "empirica.data.session_database.log_preflight_assessment": [
      "store_vectors"
    ],
    "empirica.data.session_database.log_check_phase_assessment": [
      "store_vectors"
    ],
    "empirica.data.session_database.log_postflight_assessment": [
      "store_vectors"
    ],
    "empirica.data.session_database.log_investigation_round": [
      "cursor",
      "str",
      "commit",
      "execute",
      "uuid4",
      "_export_to_reflex_logs"
    ],
    "empirica.data.session_database.log_act_phase": [
      "cursor",
      "str",
      "commit",
      "execute",
      "uuid4",
      "_export_to_reflex_logs"
    ],
    "empirica.data.session_database._export_to_reflex_logs": [
      "date",
      "open",
      "isoformat",
      "mkdir",
      "strftime",
      "dump",
      "Path",
      "utcnow",
      "exists",
      "get",
      "locals",
      "safe_load",
      "_determine_action"
    ],
    "empirica.data.session_database._determine_action": [
      "get"
    ],
    "empirica.data.session_database.get_preflight_assessment": [
      "get_latest_vectors"
    ],
    "empirica.data.session_database.get_check_phase_assessments": [
      "get_vectors_by_phase"
    ],
    "empirica.data.session_database.get_postflight_assessment": [
      "get_latest_vectors"
    ],
    "empirica.data.session_database.get_preflight_vectors": [
      "get_latest_vectors"
    ],
    "empirica.data.session_database.get_check_vectors": [
      "get",
      "get_vectors_by_phase"
    ],
    "empirica.data.session_database.get_postflight_vectors": [
      "get_latest_vectors"
    ],
    "empirica.data.session_database.get_vectors_by_phase": [
      "cursor",
      "fetchall",
      "dict",
      "items",
      "loads",
      "append",
      "get",
      "execute"
    ],
    "empirica.data.session_database.store_epistemic_delta": [
      "cursor",
      "execute",
      "commit",
      "dumps"
    ],
    "empirica.data.session_database.get_last_session_by_ai": [
      "cursor",
      "execute",
      "fetchone",
      "dict"
    ],
    "empirica.data.session_database.get_session_snapshot": [
      "get_session",
      "round",
      "run",
      "split",
      "append",
      "get_goal_tree",
      "strip",
      "get_epistemic_sources",
      "get_vectors_by_phase",
      "get",
      "get_latest_vectors"
    ],
    "empirica.data.session_database.get_session_summary": [
      "cursor",
      "get_session",
      "fetchall",
      "get_session_cascades",
      "loads",
      "len",
      "fetchone",
      "get",
      "execute",
      "lower"
    ],
    "empirica.data.session_database.get_git_checkpoint": [
      "debug",
      "GitEnhancedReflexLogger",
      "_get_checkpoint_from_reflexes",
      "get_last_checkpoint"
    ],
    "empirica.data.session_database.list_git_checkpoints": [
      "warning",
      "list_checkpoints",
      "debug",
      "GitEnhancedReflexLogger",
      "len"
    ],
    "empirica.data.session_database.get_checkpoint_diff": [
      "abs",
      "keys",
      "GitEnhancedReflexLogger",
      "_get_latest_vectors",
      "append",
      "get",
      "get_last_checkpoint"
    ],
    "empirica.data.session_database._get_checkpoint_from_reflexes": [
      "cursor",
      "loads",
      "fetchone",
      "execute",
      "lower"
    ],
    "empirica.data.session_database._get_latest_vectors": [
      "cursor",
      "execute",
      "fetchone",
      "loads"
    ],
    "empirica.data.session_database.store_vectors": [
      "cursor",
      "dumps",
      "update",
      "commit",
      "append",
      "isinstance",
      "get",
      "execute",
      "time"
    ],
    "empirica.data.session_database.get_latest_vectors": [
      "cursor",
      "dict",
      "loads",
      "append",
      "float",
      "fetchone",
      "get",
      "execute"
    ],
    "empirica.data.session_database.get_findings_by_file": [
      "cursor",
      "fetchall",
      "loads",
      "append",
      "isinstance",
      "get",
      "execute"
    ],
    "empirica.data.session_database.get_findings_by_commit": [
      "cursor",
      "fetchall",
      "startswith",
      "loads",
      "append",
      "get",
      "execute"
    ],
    "empirica.data.session_database.create_goal": [
      "create_goal"
    ],
    "empirica.data.session_database.create_subtask": [
      "create_subtask"
    ],
    "empirica.data.session_database.update_subtask_findings": [
      "update_subtask_findings"
    ],
    "empirica.data.session_database.update_subtask_unknowns": [
      "update_subtask_unknowns"
    ],
    "empirica.data.session_database.update_subtask_dead_ends": [
      "update_subtask_dead_ends"
    ],
    "empirica.data.session_database.complete_subtask": [
      "complete_subtask"
    ],
    "empirica.data.session_database.get_all_sessions": [
      "cursor",
      "execute",
      "dict",
      "fetchall"
    ],
    "empirica.data.session_database.get_goal_tree": [
      "get_goal_tree"
    ],
    "empirica.data.session_database.query_unknowns_summary": [
      "query_unknowns_summary"
    ],
    "empirica.data.session_database.create_branch": [
      "create_branch"
    ],
    "empirica.data.session_database.checkpoint_branch": [
      "checkpoint_branch"
    ],
    "empirica.data.session_database.calculate_branch_merge_score": [
      "calculate_branch_merge_score"
    ],
    "empirica.data.session_database.merge_branches": [
      "merge_branches"
    ],
    "empirica.data.session_database.create_project": [
      "create_project"
    ],
    "empirica.data.session_database.get_project": [
      "get_project"
    ],
    "empirica.data.session_database.resolve_project_id": [
      "resolve_project_id"
    ],
    "empirica.data.session_database.link_session_to_project": [
      "link_session_to_project",
      "_validate_session_id"
    ],
    "empirica.data.session_database.get_project_sessions": [
      "get_project_sessions"
    ],
    "empirica.data.session_database.aggregate_project_learning_deltas": [
      "aggregate_project_learning_deltas"
    ],
    "empirica.data.session_database.create_project_handoff": [
      "create_project_handoff"
    ],
    "empirica.data.session_database.get_latest_project_handoff": [
      "get_latest_project_handoff"
    ],
    "empirica.data.session_database.bootstrap_project_breadcrumbs": [
      "getcwd",
      "ContextLoadBalancer",
      "execute",
      "_generate_context_markdown",
      "fetchall",
      "get_project_unknowns",
      "open",
      "calculate_context_budget",
      "dict",
      "get_session_snapshot",
      "items",
      "len",
      "get_epistemic_sources",
      "get_project_reference_docs",
      "get",
      "DocCodeIntegrityAnalyzer",
      "list",
      "get_project_dead_ends",
      "resolve_project_id",
      "get_project",
      "get_latest_project_handoff",
      "append",
      "replace",
      "endswith",
      "cursor",
      "listdir",
      "str",
      "get_detailed_gaps",
      "join",
      "loads",
      "get_project_findings",
      "exists",
      "bool",
      "safe_load"
    ],
    "empirica.data.session_database._generate_context_markdown": [
      "get",
      "join",
      "append"
    ],
    "empirica.data.session_database.log_finding": [
      "cursor",
      "str",
      "info",
      "commit",
      "dumps",
      "execute",
      "uuid4",
      "time"
    ],
    "empirica.data.session_database.log_unknown": [
      "cursor",
      "str",
      "info",
      "commit",
      "dumps",
      "execute",
      "uuid4",
      "time"
    ],
    "empirica.data.session_database.resolve_unknown": [
      "resolve_unknown"
    ],
    "empirica.data.session_database.log_dead_end": [
      "log_dead_end"
    ],
    "empirica.data.session_database.add_reference_doc": [
      "add_reference_doc"
    ],
    "empirica.data.session_database.get_project_findings": [
      "get_project_findings"
    ],
    "empirica.data.session_database.get_project_unknowns": [
      "get_project_unknowns"
    ],
    "empirica.data.session_database.get_project_dead_ends": [
      "get_project_dead_ends"
    ],
    "empirica.data.session_database.get_project_reference_docs": [
      "get_project_reference_docs"
    ],
    "empirica.data.session_database.add_epistemic_source": [
      "cursor",
      "str",
      "info",
      "commit",
      "now",
      "execute",
      "uuid4",
      "dumps"
    ],
    "empirica.data.session_database.get_epistemic_sources": [
      "cursor",
      "fetchall",
      "dict",
      "loads",
      "append",
      "get",
      "execute"
    ],
    "empirica.data.session_database.log_mistake": [
      "log_mistake"
    ],
    "empirica.data.session_database.get_mistakes": [
      "get_mistakes"
    ],
    "empirica.data.session_database.close": [
      "close"
    ],
    "empirica.data.repositories.goals.create_goal": [
      "str",
      "time",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.goals.create_subtask": [
      "str",
      "time",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.goals.update_subtask_findings": [
      "loads",
      "commit",
      "fetchone",
      "ValueError",
      "dumps",
      "_execute"
    ],
    "empirica.data.repositories.goals.update_subtask_unknowns": [
      "loads",
      "commit",
      "fetchone",
      "ValueError",
      "dumps",
      "_execute"
    ],
    "empirica.data.repositories.goals.update_subtask_dead_ends": [
      "loads",
      "commit",
      "fetchone",
      "ValueError",
      "dumps",
      "_execute"
    ],
    "empirica.data.repositories.goals.complete_subtask": [
      "commit",
      "time",
      "_execute"
    ],
    "empirica.data.repositories.goals.get_goal_tree": [
      "fetchall",
      "loads",
      "append",
      "get",
      "_execute"
    ],
    "empirica.data.repositories.goals.query_unknowns_summary": [
      "fetchall",
      "list",
      "values",
      "loads",
      "len",
      "get",
      "_execute"
    ],
    "empirica.data.repositories.branches.create_branch": [
      "str",
      "time",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.branches.checkpoint_branch": [
      "commit",
      "_execute",
      "time",
      "dumps"
    ],
    "empirica.data.repositories.branches.calculate_branch_merge_score": [
      "round",
      "loads",
      "append",
      "len",
      "fetchone",
      "max",
      "get",
      "_execute",
      "sum"
    ],
    "empirica.data.repositories.branches.merge_branches": [
      "fetchall",
      "dumps",
      "str",
      "round",
      "calculate_branch_merge_score",
      "time",
      "commit",
      "append",
      "len",
      "max",
      "get",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.base.__init__": [],
    "empirica.data.repositories.base._execute": [
      "cursor",
      "execute"
    ],
    "empirica.data.repositories.base._execute_many": [
      "cursor",
      "executemany"
    ],
    "empirica.data.repositories.base.commit": [
      "commit"
    ],
    "empirica.data.repositories.base.rollback": [
      "rollback"
    ],
    "empirica.data.repositories.breadcrumbs.log_finding": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.breadcrumbs.log_unknown": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.breadcrumbs.resolve_unknown": [
      "commit",
      "time",
      "_execute",
      "info"
    ],
    "empirica.data.repositories.breadcrumbs.log_dead_end": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.breadcrumbs.add_reference_doc": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.breadcrumbs.get_project_findings": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.breadcrumbs.get_project_unknowns": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.breadcrumbs.get_project_dead_ends": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.breadcrumbs.get_project_reference_docs": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.breadcrumbs.log_mistake": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.breadcrumbs.get_mistakes": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.projects.create_project": [
      "str",
      "time",
      "info",
      "commit",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.projects.get_project": [
      "dict",
      "_execute",
      "fetchone"
    ],
    "empirica.data.repositories.projects.get_project_by_name": [
      "dict",
      "_execute",
      "fetchone"
    ],
    "empirica.data.repositories.projects.resolve_project_id": [
      "get_project_by_name",
      "get_project"
    ],
    "empirica.data.repositories.projects.link_session_to_project": [
      "commit",
      "time",
      "_execute",
      "info"
    ],
    "empirica.data.repositories.projects.get_project_sessions": [
      "fetchall",
      "_execute",
      "dict"
    ],
    "empirica.data.repositories.projects.aggregate_project_learning_deltas": [
      "fetchall",
      "enumerate",
      "_execute",
      "fetchone"
    ],
    "empirica.data.repositories.projects.create_project_handoff": [
      "fetchall",
      "str",
      "dict",
      "get_project",
      "time",
      "info",
      "commit",
      "append",
      "loads",
      "get_project_sessions",
      "aggregate_project_learning_deltas",
      "dumps",
      "uuid4",
      "_execute"
    ],
    "empirica.data.repositories.projects.get_latest_project_handoff": [
      "dict",
      "_execute",
      "fetchone"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.__init__": [
      "ThreadPoolExecutor",
      "AnalysisEngine",
      "Lock",
      "_initialize_default_protocols",
      "CorrelationEngine"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.initiate_investigation": [
      "get",
      "submit",
      "now",
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.collect_evidence": [
      "append",
      "_analyze_evidence_correlations",
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.get_investigation_status": [
      "get",
      "now",
      "len",
      "str"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.get_investigation_report": [
      "_generate_recommendations",
      "str",
      "isoformat",
      "append",
      "now",
      "_generate_investigation_summary",
      "get"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._execute_investigation": [
      "_perform_final_analysis",
      "str",
      "_execute_investigation_step",
      "enumerate",
      "now",
      "len",
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._execute_investigation_step": [
      "_analyze_performance_evidence",
      "_collect_behavioral_evidence",
      "_generate_findings",
      "_correlate_all_evidence"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._collect_behavioral_evidence": [
      "timestamp",
      "now",
      "Evidence",
      "collect_evidence"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._analyze_performance_evidence": [
      "timestamp",
      "now",
      "Evidence",
      "collect_evidence"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._analyze_evidence_correlations": [
      "extend",
      "find_correlations"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._correlate_all_evidence": [
      "correlate_evidence_set",
      "extend"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_findings": [
      "generate_findings",
      "extend"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._perform_final_analysis": [
      "_assess_investigation_quality",
      "_generate_findings",
      "_correlate_all_evidence"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._assess_investigation_quality": [
      "min",
      "len"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_investigation_summary": [
      "len"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._generate_recommendations": [
      "append",
      "len"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._initialize_default_protocols": [
      "InvestigationProtocol"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.find_correlations": [
      "append",
      "_calculate_correlation",
      "abs",
      "total_seconds"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.correlate_evidence_set": [
      "append",
      "_calculate_correlation",
      "enumerate"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._calculate_correlation": [
      "abs",
      "min",
      "total_seconds"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.generate_findings": [
      "items",
      "append",
      "len",
      "get",
      "sum"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.register_source": [
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.analyze_multi_source_data": [
      "_convert_source_data_to_evidence",
      "items",
      "append"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._convert_source_data_to_evidence": [
      "Evidence",
      "timestamp",
      "now",
      "get",
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.add_correlation_rule": [
      "print"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation.correlate_sources": [
      "_apply_correlation_rule",
      "items",
      "extend"
    ],
    "empirica.investigation.advanced_investigation.advanced_investigation._apply_correlation_rule": [
      "extend",
      "len",
      "any",
      "get",
      "print"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.generate_self_assessment_prompt": [
      "_format_vector_keys",
      "strip",
      "_format_vector_definitions"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment._format_vector_definitions": [
      "get",
      "join",
      "append"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment._format_vector_keys": [
      "append",
      "join",
      "len",
      "enumerate"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.parse_ai_self_assessment": [
      "warning",
      "findall",
      "loads"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.prompt_for_self_assessment": [
      "warning",
      "parse_ai_self_assessment",
      "ai_response_function",
      "generate_self_assessment_prompt",
      "error",
      "info",
      "get"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.integrate_with_adapter": [
      "hasattr",
      "info",
      "generate_self_assessment_prompt",
      "original_transform"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.wrapper": [
      "hasattr",
      "info",
      "generate_self_assessment_prompt",
      "original_transform"
    ],
    "empirica.plugins.modality_switcher.genuine_self_assessment.new_transform": [
      "hasattr",
      "info",
      "generate_self_assessment_prompt",
      "original_transform"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.initialize_registry": [
      "copy",
      "len",
      "info"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.register_domain_vectors": [
      "keys",
      "warning",
      "info",
      "len",
      "max",
      "min"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.get_domain_vectors": [
      "get",
      "initialize_registry"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.list_domains": [
      "list",
      "keys",
      "initialize_registry"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.calculate_domain_confidence": [
      "items",
      "warning",
      "get_domain_vectors"
    ],
    "empirica.plugins.modality_switcher.domain_vectors.auto_discover_custom_domains": [
      "startswith",
      "glob",
      "warning",
      "hasattr",
      "getattr",
      "register_domain_vectors",
      "Path",
      "info",
      "exists",
      "spec_from_file_location",
      "module_from_spec",
      "exec_module"
    ],
    "empirica.plugins.modality_switcher.auth_manager.get_token": [
      "get_token",
      "globals",
      "is_expired",
      "_request_from_sentinel",
      "_request_from_env",
      "debug",
      "sorted",
      "join",
      "error",
      "AuthManager",
      "AuthenticationError"
    ],
    "empirica.plugins.modality_switcher.auth_manager.__post_init__": [],
    "empirica.plugins.modality_switcher.auth_manager.is_expired": [
      "time"
    ],
    "empirica.plugins.modality_switcher.auth_manager.__init__": [
      "getenv",
      "_check_sentinel_availability"
    ],
    "empirica.plugins.modality_switcher.auth_manager._check_sentinel_availability": [
      "get",
      "warning",
      "debug",
      "info"
    ],
    "empirica.plugins.modality_switcher.auth_manager._request_from_sentinel": [
      "json",
      "Exception",
      "info",
      "post",
      "asdict",
      "get",
      "TokenRequest",
      "TokenResponse"
    ],
    "empirica.plugins.modality_switcher.auth_manager._request_from_env": [
      "getenv",
      "info",
      "upper",
      "get",
      "AuthenticationError",
      "TokenResponse",
      "lower"
    ],
    "empirica.plugins.modality_switcher.auth_manager.revoke_token": [
      "post",
      "startswith",
      "debug",
      "info"
    ],
    "empirica.plugins.modality_switcher.auth_manager.clear_cache": [
      "info",
      "clear"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.__init__": [
      "get_instance"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.create_snapshot_from_session": [
      "_estimate_fidelity",
      "get_session",
      "str",
      "calculate_delta",
      "uuid4",
      "isoformat",
      "EpistemicStateSnapshot",
      "_estimate_original_context_tokens",
      "_extract_vectors_from_assessment",
      "get_latest_snapshot",
      "_estimate_snapshot_tokens",
      "ContextSummary",
      "now",
      "ValueError",
      "_get_default_vectors",
      "_estimate_information_loss",
      "get_preflight_assessment"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.save_snapshot": [
      "cursor",
      "estimate_memory_reliability",
      "to_dict",
      "update_snapshot_status",
      "should_refresh",
      "get_refresh_reason",
      "commit",
      "print",
      "execute",
      "dumps"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.get_latest_snapshot": [
      "cursor",
      "execute",
      "_row_to_snapshot",
      "fetchone"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.get_snapshot_by_id": [
      "cursor",
      "execute",
      "_row_to_snapshot",
      "fetchone"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.get_snapshot_history": [
      "cursor",
      "execute",
      "_row_to_snapshot",
      "fetchall"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.export_snapshot_to_file": [
      "absolute",
      "open",
      "str",
      "mkdir",
      "to_json",
      "Path",
      "write",
      "print"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider.import_snapshot_from_file": [
      "read",
      "open",
      "from_json",
      "FileNotFoundError",
      "Path",
      "exists",
      "print"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider._extract_vectors_from_assessment": [
      "get",
      "items"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider._get_default_vectors": [],
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_original_context_tokens": [
      "get_session",
      "get_session_cascades",
      "len"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_snapshot_tokens": [
      "len"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_fidelity": [
      "min",
      "values",
      "sum",
      "max"
    ],
    "empirica.plugins.modality_switcher.snapshot_provider._estimate_information_loss": [],
    "empirica.plugins.modality_switcher.snapshot_provider._row_to_snapshot": [
      "from_dict",
      "dict",
      "EpistemicStateSnapshot",
      "loads",
      "get"
    ],
    "empirica.plugins.modality_switcher.epistemic_router.__init__": [],
    "empirica.plugins.modality_switcher.epistemic_router.route": [
      "get",
      "_estimate_cost",
      "_route_by_action",
      "_create_decision"
    ],
    "empirica.plugins.modality_switcher.epistemic_router._route_by_action": [
      "_estimate_cost",
      "_create_decision"
    ],
    "empirica.plugins.modality_switcher.epistemic_router._estimate_cost": [
      "get"
    ],
    "empirica.plugins.modality_switcher.epistemic_router._create_decision": [
      "RoutingDecision"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_config": [
      "ConfigLoader"
    ],
    "empirica.plugins.modality_switcher.config_loader.__init__": [
      "load_config"
    ],
    "empirica.plugins.modality_switcher.config_loader.load_config": [
      "_load_yaml",
      "warning",
      "_apply_env_overrides",
      "info",
      "exists",
      "_merge_configs",
      "_get_minimal_defaults"
    ],
    "empirica.plugins.modality_switcher.config_loader._load_yaml": [
      "open",
      "error",
      "safe_load"
    ],
    "empirica.plugins.modality_switcher.config_loader._merge_configs": [
      "items",
      "copy",
      "isinstance",
      "_merge_configs"
    ],
    "empirica.plugins.modality_switcher.config_loader._apply_env_overrides": [
      "startswith",
      "_parse_env_value",
      "debug",
      "items",
      "split",
      "len",
      "lower"
    ],
    "empirica.plugins.modality_switcher.config_loader._parse_env_value": [
      "float",
      "lower",
      "int"
    ],
    "empirica.plugins.modality_switcher.config_loader._get_minimal_defaults": [],
    "empirica.plugins.modality_switcher.config_loader.get": [
      "isinstance",
      "split"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_adapter_config": [
      "get"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_routing_config": [
      "get"
    ],
    "empirica.plugins.modality_switcher.config_loader.is_adapter_enabled": [
      "get",
      "get_adapter_config"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_adapter_costs": [
      "get",
      "items"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_adapter_latencies": [
      "get",
      "items"
    ],
    "empirica.plugins.modality_switcher.config_loader.get_adapter_quality": [
      "get",
      "items"
    ],
    "empirica.plugins.modality_switcher.config_loader.save_user_config": [
      "open",
      "mkdir",
      "dump",
      "info"
    ],
    "empirica.plugins.modality_switcher.config_loader.to_dict": [
      "copy"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.__post_init__": [],
    "empirica.plugins.modality_switcher.usage_monitor.__init__": [
      "_load_state",
      "mkdir",
      "home",
      "Path"
    ],
    "empirica.plugins.modality_switcher.usage_monitor._load_state": [
      "copy",
      "_save_state",
      "open",
      "CallRecord",
      "items",
      "error",
      "info",
      "len",
      "exists",
      "load",
      "get",
      "BudgetPolicy"
    ],
    "empirica.plugins.modality_switcher.usage_monitor._save_state": [
      "open",
      "isoformat",
      "items",
      "error",
      "dump",
      "now",
      "asdict"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.record_call": [
      "CallRecord",
      "_save_state",
      "warning",
      "debug",
      "append",
      "get",
      "time"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.check_budget": [
      "warning",
      "len",
      "get",
      "time",
      "sum"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.get_usage_summary": [
      "len",
      "time",
      "sum"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.reset_stop_flag": [
      "_save_state",
      "info"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.set_policy": [
      "_save_state",
      "info"
    ],
    "empirica.plugins.modality_switcher.usage_monitor.cleanup_old_records": [
      "_save_state",
      "len",
      "time",
      "info"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_from_thinking_semantically": [
      "warning",
      "_analyze_capability_confidence",
      "join",
      "info",
      "_analyze_uncertainty_level",
      "_analyze_context_awareness",
      "lower",
      "_analyze_knowledge_confidence",
      "extract_from_response_only"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_knowledge_confidence": [
      "search",
      "len",
      "max",
      "min",
      "sum"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_capability_confidence": [
      "search",
      "sum"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_context_awareness": [
      "findall",
      "search",
      "len",
      "max",
      "min",
      "set",
      "sum"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer._analyze_uncertainty_level": [
      "search",
      "min",
      "sum"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_from_response_only": [
      "search",
      "lower",
      "warning"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer.extract_decision_from_thinking": [
      "get",
      "info"
    ],
    "empirica.plugins.modality_switcher.thinking_analyzer.validate_with_explicit_assessment": [
      "get",
      "warning",
      "abs"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.create_snapshot": [
      "str",
      "isoformat",
      "EpistemicStateSnapshot",
      "now",
      "uuid4"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_dict": [
      "asdict",
      "to_dict"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.from_dict": [
      "get",
      "cls",
      "from_dict"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_prompt": [
      "append",
      "items",
      "join"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_json": [
      "to_dict",
      "dumps"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.from_json": [
      "from_dict",
      "loads"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.to_context_prompt": [
      "_standard_prompt",
      "_minimal_prompt",
      "ValueError",
      "_full_prompt"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._minimal_prompt": [
      "_format_vectors"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._standard_prompt": [
      "to_prompt",
      "_minimal_prompt",
      "_format_delta"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._full_prompt": [
      "_standard_prompt",
      "_format_domain_vectors"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_vectors": [
      "format_group",
      "join",
      "append",
      "_score_to_bar",
      "get"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_delta": [
      "abs",
      "items",
      "sorted",
      "join",
      "append"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._format_domain_vectors": [
      "title",
      "items",
      "type",
      "join",
      "append",
      "replace",
      "isinstance",
      "_score_to_bar"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot._score_to_bar": [
      "int"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.calculate_delta": [
      "get",
      "items"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.increment_transfer_count": [],
    "empirica.plugins.modality_switcher.epistemic_snapshot.estimate_memory_reliability": [
      "now",
      "max",
      "min",
      "total_seconds",
      "fromisoformat"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.should_refresh": [
      "estimate_memory_reliability",
      "now",
      "total_seconds",
      "fromisoformat"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.get_refresh_reason": [
      "estimate_memory_reliability",
      "now",
      "total_seconds",
      "fromisoformat"
    ],
    "empirica.plugins.modality_switcher.epistemic_snapshot.format_group": [
      "get",
      "join",
      "_score_to_bar",
      "append"
    ],
    "empirica.plugins.modality_switcher.modality_switcher.__init__": [
      "get_registry",
      "info"
    ],
    "empirica.plugins.modality_switcher.modality_switcher.route_request": [
      "_latency_route",
      "_quality_route",
      "_balanced_route",
      "RoutingPreferences",
      "_force_adapter_route",
      "_epistemic_route",
      "_cost_route"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._epistemic_route": [
      "get",
      "RoutingDecision"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._cost_route": [
      "RoutingDecision"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._latency_route": [
      "RoutingDecision"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._quality_route": [
      "RoutingDecision"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._balanced_route": [
      "RoutingDecision",
      "sorted",
      "values",
      "max"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._force_adapter_route": [
      "RoutingDecision",
      "ValueError"
    ],
    "empirica.plugins.modality_switcher.modality_switcher.execute_with_routing": [
      "call",
      "warning",
      "str",
      "route_request",
      "error",
      "_try_fallback",
      "info",
      "isinstance",
      "get",
      "AdapterPayload",
      "AdapterError",
      "get_adapter"
    ],
    "empirica.plugins.modality_switcher.modality_switcher._try_fallback": [
      "call",
      "warning",
      "error",
      "info",
      "isinstance",
      "get",
      "AdapterError",
      "get_adapter"
    ],
    "empirica.plugins.modality_switcher.modality_switcher.get_usage_stats": [
      "dict"
    ],
    "empirica.plugins.modality_switcher.modality_switcher.reset_usage_stats": [],
    "empirica.plugins.modality_switcher.plugin_registry.__post_init__": [
      "ValueError"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.get_augmented_prompt": [
      "to_context_prompt"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.health_check": [],
    "empirica.plugins.modality_switcher.plugin_registry.authenticate": [],
    "empirica.plugins.modality_switcher.plugin_registry.call": [],
    "empirica.plugins.modality_switcher.plugin_registry.__init__": [],
    "empirica.plugins.modality_switcher.plugin_registry.register": [
      "_validates_interface",
      "ValueError",
      "info"
    ],
    "empirica.plugins.modality_switcher.plugin_registry._validates_interface": [
      "hasattr",
      "error",
      "getattr",
      "callable"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.discover_adapters": [
      "list",
      "glob",
      "warning",
      "error",
      "info",
      "Path",
      "_load_adapter_module",
      "len",
      "exists"
    ],
    "empirica.plugins.modality_switcher.plugin_registry._load_adapter_module": [
      "getmembers",
      "ImportError",
      "warning",
      "hasattr",
      "replace",
      "endswith",
      "spec_from_file_location",
      "register",
      "module_from_spec",
      "exec_module"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.get_adapter": [
      "list",
      "adapter_class",
      "KeyError",
      "keys"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.list_adapters": [
      "append",
      "get"
    ],
    "empirica.plugins.modality_switcher.plugin_registry.health_check_all": [
      "error",
      "get_adapter",
      "health_check"
    ],
    "empirica.plugins.modality_switcher.epistemic_extractor.extract_epistemic_vectors": [
      "findall",
      "round",
      "search",
      "split",
      "join",
      "info",
      "min",
      "len",
      "max",
      "lower",
      "sum"
    ],
    "empirica.plugins.modality_switcher.epistemic_extractor.extract_decision": [
      "any",
      "lower",
      "join",
      "sum"
    ],
    "empirica.plugins.modality_switcher.register_adapters.get_registry": [
      "create_registry"
    ],
    "empirica.plugins.modality_switcher.register_adapters.create_registry": [
      "warning",
      "debug",
      "error",
      "PluginRegistry",
      "info",
      "len",
      "register",
      "list_adapters"
    ],
    "empirica.plugins.modality_switcher.register_adapters.register_custom_adapter": [
      "get_registry",
      "register",
      "info"
    ],
    "empirica.plugins.modality_switcher.register_adapters.list_registered_adapters": [
      "get_registry",
      "list_adapters"
    ],
    "empirica.plugins.modality_switcher.register_adapters.health_check_adapters": [
      "get_registry",
      "health_check_all"
    ],
    "empirica.plugins.modality_switcher.register_adapters.get_adapter": [
      "get_registry",
      "get_adapter"
    ],
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.__init__": [
      "Session",
      "get_credentials_loader",
      "get",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_base_url",
      "get_default_model",
      "get_api_key",
      "ValueError",
      "get_headers"
    ],
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.health_check": [
      "debug",
      "warning",
      "startswith",
      "error"
    ],
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.authenticate": [
      "debug",
      "error"
    ],
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter.call": [
      "json",
      "str",
      "debug",
      "_transform_to_schema",
      "error",
      "info",
      "append",
      "increment_transfer_count",
      "post",
      "strip",
      "len",
      "get_augmented_prompt",
      "AdapterError"
    ],
    "empirica.plugins.modality_switcher.adapters.openrouter_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "insert",
      "get",
      "lower"
    ],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.__init__": [
      "get_credentials_loader",
      "warning",
      "get",
      "get_provider_config",
      "info",
      "get_api_key",
      "ValueError",
      "Anthropic",
      "ImportError"
    ],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.health_check": [
      "bool"
    ],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.authenticate": [],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.call": [
      "create",
      "str",
      "debug",
      "update",
      "_transform_to_schema",
      "error",
      "join",
      "type",
      "info",
      "append",
      "increment_transfer_count",
      "strip",
      "max",
      "AdapterError",
      "min",
      "get_augmented_prompt"
    ],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter.stream_call": [
      "create",
      "str",
      "hasattr",
      "debug",
      "error",
      "info",
      "increment_transfer_count",
      "max",
      "min",
      "get_augmented_prompt"
    ],
    "empirica.plugins.modality_switcher.adapters.minimax_adapter._transform_to_schema": [
      "extract_decision_from_thinking",
      "extract_from_thinking_semantically",
      "AdapterResponse",
      "join",
      "len",
      "get",
      "insert"
    ],
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.__init__": [
      "get_credentials_loader",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_base_url",
      "get_default_model",
      "get_api_key",
      "ValueError",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.health_check": [
      "run",
      "error",
      "warning",
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.authenticate": [
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.qodo_adapter.call": [
      "str",
      "debug",
      "run",
      "_transform_to_schema",
      "error",
      "join",
      "info",
      "append",
      "increment_transfer_count",
      "loads",
      "strip",
      "isinstance",
      "get_augmented_prompt",
      "AdapterError"
    ],
    "empirica.plugins.modality_switcher.adapters.qodo_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "insert",
      "lower"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.__init__": [
      "get_credentials_loader",
      "get",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_base_url",
      "get_default_model",
      "get_api_key",
      "ValueError",
      "get_headers"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._start_server": [
      "Popen",
      "sleep",
      "str",
      "error",
      "info",
      "range",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._stop_server": [
      "terminate",
      "wait",
      "kill",
      "info"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.health_check": [
      "json",
      "warning",
      "debug",
      "_start_server",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.authenticate": [
      "RuntimeError",
      "_start_server",
      "health_check",
      "info"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.call": [
      "startswith",
      "str",
      "debug",
      "authenticate",
      "_transform_to_schema",
      "decode",
      "error",
      "post",
      "info",
      "increment_transfer_count",
      "iter_lines",
      "loads",
      "append",
      "isinstance",
      "get_augmented_prompt",
      "get",
      "AdapterError"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "max",
      "lower"
    ],
    "empirica.plugins.modality_switcher.adapters.rovodev_adapter.__del__": [
      "_stop_server"
    ],
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.__init__": [
      "get_credentials_loader",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_base_url",
      "get_default_model",
      "get_api_key",
      "ValueError",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.health_check": [
      "run",
      "error",
      "warning",
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.authenticate": [
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.gemini_adapter.call": [
      "str",
      "debug",
      "run",
      "_transform_to_schema",
      "error",
      "join",
      "info",
      "append",
      "increment_transfer_count",
      "loads",
      "strip",
      "isinstance",
      "get_augmented_prompt",
      "AdapterError",
      "extend"
    ],
    "empirica.plugins.modality_switcher.adapters.gemini_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "insert",
      "lower"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.__init__": [
      "get_credentials_loader",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_default_model",
      "ValueError",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.health_check": [
      "warning",
      "run",
      "debug",
      "error",
      "strip"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.authenticate": [
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter.call": [
      "_parse_token_usage",
      "str",
      "debug",
      "run",
      "_transform_to_schema",
      "error",
      "split",
      "join",
      "info",
      "append",
      "increment_transfer_count",
      "strip",
      "get_augmented_prompt",
      "AdapterError"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter._parse_token_usage": [
      "warning",
      "int",
      "search",
      "split",
      "float",
      "group"
    ],
    "empirica.plugins.modality_switcher.adapters.copilot_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "insert",
      "get",
      "lower"
    ],
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.__init__": [
      "get_credentials_loader",
      "get_provider_config",
      "validate_model",
      "get_available_models",
      "info",
      "get_base_url",
      "get_default_model",
      "get_api_key",
      "ValueError",
      "get"
    ],
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.health_check": [
      "run",
      "error",
      "warning",
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.authenticate": [
      "debug"
    ],
    "empirica.plugins.modality_switcher.adapters.qwen_adapter.call": [
      "str",
      "debug",
      "run",
      "_transform_to_schema",
      "error",
      "join",
      "info",
      "loads",
      "increment_transfer_count",
      "strip",
      "isinstance",
      "get_augmented_prompt",
      "AdapterError",
      "extend"
    ],
    "empirica.plugins.modality_switcher.adapters.qwen_adapter._transform_to_schema": [
      "AdapterResponse",
      "split",
      "min",
      "len",
      "any",
      "insert",
      "lower"
    ],
    "empirica.core.git_ops.signed_operations.__init__": [
      "info",
      "lower",
      "getenv",
      "GitRepo"
    ],
    "empirica.core.git_ops.signed_operations.commit_signed_state": [
      "get_persona_info",
      "_validate_cascade_phase",
      "Actor",
      "error",
      "info",
      "commit",
      "GitCommandError",
      "notes",
      "sign_epistemic_state",
      "dumps"
    ],
    "empirica.core.git_ops.signed_operations.get_signed_state_from_commit": [
      "loads",
      "notes"
    ],
    "empirica.core.git_ops.signed_operations.verify_cascade_chain": [
      "list",
      "warning",
      "encode",
      "str",
      "isoformat",
      "verify",
      "error",
      "split",
      "info",
      "append",
      "len",
      "iter_commits",
      "get",
      "get_signed_state_from_commit",
      "dumps",
      "fromhex"
    ],
    "empirica.core.git_ops.signed_operations.export_cascade_report": [
      "list",
      "all",
      "open",
      "str",
      "isoformat",
      "mkdir",
      "dump",
      "Path",
      "info",
      "verify_cascade_chain",
      "len",
      "now",
      "get",
      "set",
      "sum"
    ],
    "empirica.core.git_ops.signed_operations._validate_cascade_phase": [
      "index",
      "_get_last_cascade_phase",
      "join",
      "info",
      "ValueError"
    ],
    "empirica.core.git_ops.signed_operations._get_last_cascade_phase": [
      "warning",
      "split",
      "log"
    ],
    "empirica.core.git_ops.signed_operations.get_cascade_timeline": [
      "get",
      "verify_cascade_chain",
      "sort"
    ],
    "empirica.core.persona.signing_persona.__init__": [
      "ValueError",
      "info"
    ],
    "empirica.core.persona.signing_persona._create_canonical_state": [
      "isoformat",
      "public_key_hex",
      "sorted",
      "now",
      "ValueError"
    ],
    "empirica.core.persona.signing_persona.sign_epistemic_state": [
      "hex",
      "_create_canonical_state",
      "sign",
      "info",
      "encode",
      "dumps"
    ],
    "empirica.core.persona.signing_persona.verify_signature": [
      "warning",
      "verify",
      "public_key_hex",
      "error",
      "info",
      "get",
      "encode",
      "dumps",
      "fromhex"
    ],
    "empirica.core.persona.signing_persona.get_persona_info": [
      "public_key_hex",
      "get_type"
    ],
    "empirica.core.persona.signing_persona.export_public_persona": [
      "public_key_hex",
      "get_type",
      "asdict"
    ],
    "empirica.core.persona.persona_manager.__init__": [
      "mkdir",
      "Path"
    ],
    "empirica.core.persona.persona_manager.create_persona": [
      "PersonaProfile",
      "_get_or_create_signing_identity",
      "info",
      "_create_from_template",
      "EpistemicConfig",
      "_get_default_priors"
    ],
    "empirica.core.persona.persona_manager.save_persona": [
      "open",
      "to_dict",
      "dump",
      "info",
      "FileExistsError",
      "exists",
      "validate_persona_profile"
    ],
    "empirica.core.persona.persona_manager.load_persona": [
      "open",
      "from_dict",
      "FileNotFoundError",
      "info",
      "exists",
      "validate_persona_profile",
      "load"
    ],
    "empirica.core.persona.persona_manager.list_personas": [
      "glob"
    ],
    "empirica.core.persona.persona_manager.delete_persona": [
      "FileNotFoundError",
      "exists",
      "unlink",
      "info"
    ],
    "empirica.core.persona.persona_manager.get_persona_type": [
      "get_type",
      "load_persona"
    ],
    "empirica.core.persona.persona_manager._get_or_create_signing_identity": [
      "hex",
      "public_bytes_raw",
      "load_keypair",
      "SigningIdentityConfig",
      "info",
      "save_keypair",
      "AIIdentity",
      "generate_keypair"
    ],
    "empirica.core.persona.persona_manager._get_default_priors": [],
    "empirica.core.persona.persona_manager._create_from_template": [
      "list",
      "keys",
      "PersonaProfile",
      "_get_or_create_signing_identity",
      "info",
      "replace",
      "EpistemicConfig",
      "ValueError"
    ],
    "empirica.core.persona.persona_profile.to_dict": [
      "asdict",
      "to_dict"
    ],
    "empirica.core.persona.persona_profile.__post_init__": [
      "match",
      "isoformat",
      "values",
      "now",
      "len",
      "ValueError",
      "sum"
    ],
    "empirica.core.persona.persona_profile._parse_sentinel_config": [
      "copy",
      "EscalationTrigger",
      "pop",
      "SentinelConfig",
      "get"
    ],
    "empirica.core.persona.persona_profile.from_dict": [
      "_parse_sentinel_config",
      "SigningIdentityConfig",
      "PersonaMetadata",
      "EpistemicConfig",
      "CapabilitiesConfig",
      "get",
      "cls"
    ],
    "empirica.core.persona.persona_profile.get_type": [
      "any"
    ],
    "empirica.core.persona.validation.load_schema": [
      "open",
      "FileNotFoundError",
      "Path",
      "exists",
      "load"
    ],
    "empirica.core.persona.validation.validate_persona_profile": [
      "ValidationError",
      "str",
      "_validate_business_logic",
      "join",
      "info",
      "validate",
      "get",
      "load_schema"
    ],
    "empirica.core.persona.validation._validate_business_logic": [
      "ValidationError",
      "warning",
      "_validate_escalation_trigger",
      "values",
      "get",
      "sum"
    ],
    "empirica.core.persona.validation._validate_escalation_trigger": [
      "debug",
      "ValidationError",
      "any"
    ],
    "empirica.core.skills.parser.parse_markdown_to_skill": [
      "match",
      "startswith",
      "join",
      "splitlines",
      "sub",
      "append",
      "setdefault",
      "group",
      "strip",
      "extract_paragraph",
      "extract_list",
      "get",
      "lower"
    ],
    "empirica.core.skills.parser.extract_list": [
      "get",
      "strip",
      "append",
      "startswith"
    ],
    "empirica.core.skills.parser.extract_paragraph": [
      "get",
      "strip",
      "join"
    ],
    "empirica.core.goals.repository.__init__": [
      "_ensure_tables",
      "SessionDatabase"
    ],
    "empirica.core.goals.repository._ensure_tables": [
      "commit",
      "execute",
      "error",
      "info"
    ],
    "empirica.core.goals.repository.save_goal": [
      "rollback",
      "to_dict",
      "error",
      "info",
      "commit",
      "execute",
      "dumps"
    ],
    "empirica.core.goals.repository.get_goal": [
      "from_dict",
      "error",
      "loads",
      "fetchone",
      "execute"
    ],
    "empirica.core.goals.repository.get_session_goals": [
      "fetchall",
      "from_dict",
      "error",
      "loads",
      "append",
      "execute"
    ],
    "empirica.core.goals.repository.update_goal_completion": [
      "rollback",
      "to_dict",
      "error",
      "get_goal",
      "info",
      "commit",
      "dumps",
      "execute",
      "time"
    ],
    "empirica.core.goals.repository.query_goals": [
      "fetchall",
      "to_dict",
      "from_dict",
      "error",
      "loads",
      "append",
      "execute",
      "dumps"
    ],
    "empirica.core.goals.repository.close": [
      "close"
    ],
    "empirica.core.goals.types.__post_init__": [
      "type",
      "isinstance",
      "getattr",
      "ValueError"
    ],
    "empirica.core.goals.types.to_dict": [
      "to_dict"
    ],
    "empirica.core.goals.types.from_dict": [
      "SuccessCriterion",
      "ScopeVector",
      "from_dict",
      "Dependency",
      "float",
      "DependencyType",
      "get",
      "Goal",
      "time"
    ],
    "empirica.core.goals.types.create": [
      "ScopeVector",
      "str",
      "validate_success_criteria",
      "validate_objective",
      "validate_complexity",
      "get",
      "Goal",
      "uuid4",
      "validate_scope_vector"
    ],
    "empirica.core.goals.types.get_subtasks": [
      "TaskRepository",
      "close",
      "get_goal_subtasks"
    ],
    "empirica.core.goals.types.calculate_progress": [
      "get",
      "get_subtasks",
      "len"
    ],
    "empirica.core.goals.types.is_ready_for_completion": [
      "calculate_progress"
    ],
    "empirica.core.goals.decision_logic.decide_goal_creation": [
      "min",
      "GoalDecision"
    ],
    "empirica.core.goals.decision_logic.get_investigation_focus": [],
    "empirica.core.goals.decision_logic.format_decision_for_ai": [
      "append",
      "upper",
      "join",
      "get_investigation_focus"
    ],
    "empirica.core.goals.validation.validate_objective": [
      "ValidationError",
      "len",
      "strip"
    ],
    "empirica.core.goals.validation.validate_success_criteria": [
      "ValidationError",
      "strip",
      "enumerate"
    ],
    "empirica.core.goals.validation.validate_complexity": [
      "ValidationError"
    ],
    "empirica.core.goals.validation.validate_scope_vector": [
      "ValidationError",
      "type",
      "isinstance",
      "warning"
    ],
    "empirica.core.goals.validation.validate_goal": [
      "validate_objective",
      "validate_complexity",
      "validate_scope_vector",
      "validate_success_criteria"
    ],
    "empirica.core.goals.validation.validate_mcp_goal_input": [
      "ValidationError",
      "type",
      "enumerate",
      "float",
      "strip",
      "isinstance",
      "get"
    ],
    "empirica.core.goals.validation.validate_mcp_subtask_input": [
      "ValidationError",
      "int",
      "type",
      "len",
      "strip",
      "isinstance",
      "get"
    ],
    "empirica.core.drift.mirror_drift_monitor.__init__": [],
    "empirica.core.drift.mirror_drift_monitor.detect_drift": [
      "DriftReport",
      "_log_drift",
      "_load_recent_checkpoints",
      "_calculate_baseline",
      "_compare_states"
    ],
    "empirica.core.drift.mirror_drift_monitor._load_recent_checkpoints": [
      "load_recent_checkpoints",
      "CheckpointManager",
      "warning"
    ],
    "empirica.core.drift.mirror_drift_monitor._calculate_baseline": [
      "append",
      "len",
      "sum"
    ],
    "empirica.core.drift.mirror_drift_monitor._compare_states": [
      "_extract_vectors",
      "_recommend_action",
      "_classify_drift_pattern",
      "_classify_overall_severity",
      "items",
      "DriftReport",
      "append",
      "len",
      "_classify_drift_severity",
      "max",
      "get"
    ],
    "empirica.core.drift.mirror_drift_monitor._extract_vectors": [
      "hasattr",
      "getattr"
    ],
    "empirica.core.drift.mirror_drift_monitor._classify_drift_severity": [],
    "empirica.core.drift.mirror_drift_monitor._classify_overall_severity": [],
    "empirica.core.drift.mirror_drift_monitor._recommend_action": [],
    "empirica.core.drift.mirror_drift_monitor._log_drift": [
      "len",
      "warning",
      "upper"
    ],
    "empirica.core.drift.mirror_drift_monitor._classify_drift_pattern": [
      "get",
      "min",
      "abs"
    ],
    "empirica.core.schemas.epistemic_assessment.validate_assessment": [
      "float",
      "check_vector",
      "ValueError"
    ],
    "empirica.core.schemas.epistemic_assessment.parse_assessment_dict": [
      "from_nested_dict",
      "validate_assessment"
    ],
    "empirica.core.schemas.epistemic_assessment.__post_init__": [
      "ValueError"
    ],
    "empirica.core.schemas.epistemic_assessment.to_dict": [],
    "empirica.core.schemas.epistemic_assessment.from_dict": [
      "get",
      "float",
      "str",
      "cls"
    ],
    "empirica.core.schemas.epistemic_assessment.to_nested_dict": [
      "to_dict"
    ],
    "empirica.core.schemas.epistemic_assessment.to_flat_dict": [],
    "empirica.core.schemas.epistemic_assessment.from_nested_dict": [
      "cls",
      "from_dict"
    ],
    "empirica.core.schemas.epistemic_assessment.apply_persona_priors": [
      "VectorAssessment",
      "EpistemicAssessmentSchema",
      "blend_vector"
    ],
    "empirica.core.schemas.epistemic_assessment.calculate_tier_confidences": [],
    "empirica.core.schemas.epistemic_assessment.determine_action": [
      "calculate_tier_confidences"
    ],
    "empirica.core.schemas.epistemic_assessment.know": [],
    "empirica.core.schemas.epistemic_assessment.do": [],
    "empirica.core.schemas.epistemic_assessment.context": [],
    "empirica.core.schemas.epistemic_assessment.clarity": [],
    "empirica.core.schemas.epistemic_assessment.coherence": [],
    "empirica.core.schemas.epistemic_assessment.signal": [],
    "empirica.core.schemas.epistemic_assessment.density": [],
    "empirica.core.schemas.epistemic_assessment.state": [],
    "empirica.core.schemas.epistemic_assessment.change": [],
    "empirica.core.schemas.epistemic_assessment.completion": [],
    "empirica.core.schemas.epistemic_assessment.impact": [],
    "empirica.core.schemas.epistemic_assessment.engagement_gate_passed": [],
    "empirica.core.schemas.epistemic_assessment.assessment_id": [
      "uuid4"
    ],
    "empirica.core.schemas.epistemic_assessment.foundation_confidence": [],
    "empirica.core.schemas.epistemic_assessment.comprehension_confidence": [],
    "empirica.core.schemas.epistemic_assessment.execution_confidence": [],
    "empirica.core.schemas.epistemic_assessment.overall_confidence": [],
    "empirica.core.schemas.epistemic_assessment.recommended_action": [],
    "empirica.core.schemas.epistemic_assessment.coherence_critical": [],
    "empirica.core.schemas.epistemic_assessment.density_critical": [],
    "empirica.core.schemas.epistemic_assessment.change_critical": [],
    "empirica.core.schemas.epistemic_assessment.check_vector": [
      "float",
      "ValueError"
    ],
    "empirica.core.schemas.epistemic_assessment.blend_vector": [
      "VectorAssessment"
    ],
    "empirica.core.schemas.assessment_converters.convert_old_to_new": [
      "VectorAssessment",
      "hasattr",
      "EpistemicAssessmentSchema",
      "convert_vector",
      "get",
      "_convert_phase_to_enum",
      "lower"
    ],
    "empirica.core.schemas.assessment_converters.convert_new_to_old": [
      "determine_action",
      "VectorState",
      "calculate_tier_confidences",
      "_calculate_tier_confidence",
      "_convert_action_to_old",
      "convert_vector",
      "EpistemicAssessment"
    ],
    "empirica.core.schemas.assessment_converters._calculate_tier_confidence": [
      "len",
      "sum"
    ],
    "empirica.core.schemas.assessment_converters._convert_phase_to_enum": [
      "lower"
    ],
    "empirica.core.schemas.assessment_converters._convert_action": [
      "str",
      "upper"
    ],
    "empirica.core.schemas.assessment_converters._convert_action_to_old": [
      "lower"
    ],
    "empirica.core.schemas.assessment_converters.validate_conversion_old_to_new": [
      "convert_old_to_new",
      "print"
    ],
    "empirica.core.schemas.assessment_converters.validate_conversion_new_to_old": [
      "print",
      "convert_new_to_old"
    ],
    "empirica.core.schemas.assessment_converters.convert_vector": [
      "VectorAssessment",
      "VectorState",
      "hasattr",
      "get",
      "lower"
    ],
    "empirica.core.canonical.canonical_epistemic_assessment.__init__": [],
    "empirica.core.canonical.canonical_epistemic_assessment._generate_assessment_id": [
      "isoformat",
      "hexdigest",
      "now",
      "sha256",
      "encode"
    ],
    "empirica.core.canonical.canonical_epistemic_assessment._build_self_assessment_prompt": [
      "_format_context"
    ],
    "empirica.core.canonical.canonical_epistemic_assessment._format_context": [
      "items",
      "join",
      "append",
      "len",
      "isinstance"
    ],
    "empirica.core.canonical.canonical_epistemic_assessment._build_self_assessment_template_for_mapping": [],
    "empirica.core.canonical.canonical_epistemic_assessment.parse_llm_response": [
      "VectorAssessment",
      "EpistemicAssessmentSchema",
      "loads",
      "strip",
      "isinstance",
      "find",
      "ValueError",
      "get"
    ],
    "empirica.core.canonical.canonical_epistemic_assessment._determine_action": [
      "load_profile"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.__init__": [
      "warning",
      "str",
      "_check_git_available",
      "mkdir",
      "cwd",
      "Path",
      "SignedGitOperations"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.git_enabled": [],
    "empirica.core.canonical.git_enhanced_reflex_logger._check_git_available": [
      "run",
      "debug"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.add_checkpoint": [
      "_git_add_signed_note",
      "_create_checkpoint",
      "_save_checkpoint_to_sqlite",
      "_git_add_note"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._create_checkpoint": [
      "round",
      "isoformat",
      "_calculate_learning_delta",
      "now",
      "len",
      "get",
      "_capture_git_state",
      "_estimate_token_count",
      "sum"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._estimate_token_count": [
      "split",
      "len",
      "dumps",
      "int"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._capture_git_state": [
      "warning",
      "run",
      "_get_uncommitted_changes",
      "strip",
      "_get_commits_since_last_checkpoint"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._get_commits_since_last_checkpoint": [
      "warning",
      "run",
      "split",
      "append",
      "strip",
      "len",
      "get",
      "get_last_checkpoint"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._get_uncommitted_changes": [
      "warning",
      "run",
      "split",
      "append",
      "strip",
      "len"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._calculate_learning_delta": [
      "get",
      "warning",
      "get_last_checkpoint",
      "round"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._save_checkpoint_to_sqlite": [
      "store_vectors",
      "debug",
      "error",
      "close",
      "SessionDatabase",
      "get"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._git_add_note": [
      "warning",
      "run",
      "split",
      "info",
      "loads",
      "strip",
      "get",
      "dumps"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._git_add_signed_note": [
      "warning",
      "run",
      "debug",
      "_git_add_note",
      "info",
      "commit_signed_state",
      "get",
      "dumps"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.get_last_checkpoint": [
      "_load_checkpoint_from_sqlite",
      "_is_fresh",
      "_git_get_latest_note_new"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._git_get_latest_note": [
      "warning",
      "debug",
      "run",
      "split",
      "loads",
      "strip",
      "len",
      "get"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._git_get_latest_note_new": [
      "warning",
      "debug",
      "run",
      "loads",
      "range",
      "get"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._load_checkpoint_from_sqlite": [
      "glob",
      "open",
      "debug",
      "get",
      "sorted",
      "now",
      "exists",
      "load",
      "stat",
      "timedelta",
      "fromisoformat"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger._is_fresh": [
      "timedelta",
      "now",
      "fromisoformat"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.list_checkpoints": [
      "sort",
      "warning",
      "run",
      "debug",
      "split",
      "loads",
      "append",
      "strip",
      "len",
      "get"
    ],
    "empirica.core.canonical.git_enhanced_reflex_logger.get_vector_diff": [
      "abs",
      "round",
      "isoformat",
      "append",
      "now",
      "get",
      "_estimate_token_count"
    ],
    "empirica.core.canonical.goal_orchestrator_bridge.create_orchestrator_with_bridge": [
      "GoalOrchestratorBridge",
      "CanonicalGoalOrchestrator"
    ],
    "empirica.core.canonical.goal_orchestrator_bridge.__init__": [
      "GoalRepository"
    ],
    "empirica.core.canonical.goal_orchestrator_bridge._convert_to_structured_goal": [
      "SuccessCriterion",
      "ScopeVector",
      "create",
      "str",
      "_map_priority_to_complexity",
      "append",
      "uuid4"
    ],
    "empirica.core.canonical.goal_orchestrator_bridge._map_priority_to_complexity": [],
    "empirica.core.canonical.goal_orchestrator_bridge.create_goal_from_decision": [
      "SuccessCriterion",
      "ScopeVector",
      "create",
      "str",
      "hasattr",
      "getattr",
      "error",
      "info",
      "get",
      "save_goal",
      "uuid4"
    ],
    "empirica.core.canonical.goal_orchestrator_bridge.close": [
      "close"
    ],
    "empirica.core.canonical.reflex_frame.__post_init__": [
      "ValueError"
    ],
    "empirica.core.canonical.reflex_frame.to_dict": [
      "asdict"
    ],
    "empirica.core.canonical.canonical_goal_orchestrator.create_goal_orchestrator": [
      "CanonicalGoalOrchestrator"
    ],
    "empirica.core.canonical.canonical_goal_orchestrator.to_dict": [],
    "empirica.core.canonical.canonical_goal_orchestrator.__init__": [
      "ActionEnum",
      "Vector",
      "warning",
      "ValueError"
    ],
    "empirica.core.canonical.canonical_goal_orchestrator._build_goal_orchestration_prompt": [
      "_format_epistemic_state",
      "join",
      "append",
      "dumps",
      "_get_goal_generation_instructions"
    ],
    "empirica.core.canonical.canonical_goal_orchestrator._format_epistemic_state": [],
    "empirica.core.canonical.canonical_goal_orchestrator._get_goal_generation_instructions": [],
    "empirica.core.canonical.canonical_goal_orchestrator._placeholder_goal_generation": [
      "append",
      "Goal"
    ],
    "empirica.core.canonical.canonical_goal_orchestrator._parse_llm_goal_response": [
      "warning",
      "rfind",
      "loads",
      "append",
      "GoalAutonomyLevel",
      "find",
      "ValueError",
      "get",
      "Goal"
    ],
    "empirica.core.canonical.reflex_logger.log_assessment_sync": [
      "run",
      "log_assessment"
    ],
    "empirica.core.canonical.reflex_logger.__init__": [
      "_ensure_log_directory",
      "Path"
    ],
    "empirica.core.canonical.reflex_logger._ensure_log_directory": [
      "mkdir"
    ],
    "empirica.core.canonical.reflex_logger._get_agent_log_dir": [
      "isoformat",
      "mkdir",
      "today"
    ],
    "empirica.core.canonical.reflex_logger._generate_log_filename": [
      "now",
      "strftime"
    ],
    "empirica.core.canonical.reflex_logger.log_frame_sync": [
      "open",
      "_generate_log_filename",
      "_get_agent_log_dir",
      "write",
      "get",
      "dumps"
    ],
    "empirica.core.canonical.reflex_logger.get_recent_frames_sync": [
      "glob",
      "open",
      "_get_agent_log_dir",
      "sorted",
      "append",
      "load",
      "stat"
    ],
    "empirica.core.canonical.reflex_logger.get_assessment_history": [
      "get_recent_frames_sync",
      "range",
      "timedelta",
      "extend",
      "today"
    ],
    "empirica.core.canonical.reflex_logger.cleanup_old_logs": [
      "iterdir",
      "rmtree",
      "is_dir",
      "info",
      "exists",
      "timedelta",
      "fromisoformat",
      "today"
    ],
    "empirica.core.completion.git_query.__init__": [
      "_check_git_available"
    ],
    "empirica.core.completion.git_query._check_git_available": [
      "run"
    ],
    "empirica.core.completion.git_query.get_goal_timeline": [
      "startswith",
      "str",
      "int",
      "run",
      "isoformat",
      "error",
      "split",
      "append",
      "len",
      "strip",
      "fromtimestamp",
      "_get_task_note"
    ],
    "empirica.core.completion.git_query._get_task_note": [
      "run",
      "debug",
      "loads"
    ],
    "empirica.core.completion.git_query.get_team_progress": [
      "append",
      "get",
      "get_goal_timeline"
    ],
    "empirica.core.completion.git_query.get_unified_timeline": [
      "sort",
      "str",
      "run",
      "error",
      "append",
      "len",
      "get",
      "get_goal_timeline",
      "_get_task_note"
    ],
    "empirica.core.completion.git_query.get_recent_activity": [
      "str",
      "int",
      "run",
      "isoformat",
      "error",
      "split",
      "append",
      "len",
      "strip",
      "fromtimestamp"
    ],
    "empirica.core.completion.types.to_dict": [],
    "empirica.core.completion.types.from_dict": [
      "get",
      "CompletionRecord",
      "time"
    ],
    "empirica.core.completion.tracker.__init__": [
      "_check_git_available",
      "TaskRepository",
      "GoalRepository"
    ],
    "empirica.core.completion.tracker.track_progress": [
      "warning",
      "update_goal_completion",
      "get_goal_subtasks",
      "CompletionRecord",
      "error",
      "info",
      "append",
      "len",
      "sum"
    ],
    "empirica.core.completion.tracker.auto_update_completion": [
      "track_progress"
    ],
    "empirica.core.completion.tracker.record_subtask_completion": [
      "startswith",
      "_add_task_note",
      "error",
      "split",
      "info",
      "update_subtask_status"
    ],
    "empirica.core.completion.tracker.get_session_metrics": [
      "get_session_goals",
      "track_progress",
      "error",
      "CompletionMetrics",
      "len"
    ],
    "empirica.core.completion.tracker.auto_update_from_recent_commits": [
      "warning",
      "run",
      "debug",
      "search",
      "get_subtask",
      "split",
      "info",
      "group",
      "strip",
      "record_subtask_completion"
    ],
    "empirica.core.completion.tracker._check_git_available": [
      "run"
    ],
    "empirica.core.completion.tracker._add_task_note": [
      "warning",
      "run",
      "get_subtask",
      "error",
      "time",
      "info",
      "split",
      "strip",
      "dumps"
    ],
    "empirica.core.completion.tracker.close": [
      "close"
    ],
    "empirica.core.handoff.report_generator.__init__": [
      "SessionDatabase"
    ],
    "empirica.core.handoff.report_generator.generate_handoff_report": [
      "_compress_report",
      "_generate_markdown",
      "_extract_investigation_tools",
      "_get_postflight_assessment",
      "len",
      "get",
      "_calculate_deltas",
      "_check_calibration",
      "_generate_recommendations",
      "isoformat",
      "_calculate_duration",
      "info",
      "now",
      "_get_preflight_assessment",
      "get_check_phase_assessments",
      "_identify_filled_gaps",
      "_get_session_metadata",
      "ValueError",
      "bool"
    ],
    "empirica.core.handoff.report_generator.generate_planning_handoff": [
      "isoformat",
      "_get_session_metadata",
      "join",
      "_calculate_duration",
      "info",
      "append",
      "now",
      "len",
      "_compress_planning_handoff",
      "get",
      "extend"
    ],
    "empirica.core.handoff.report_generator._get_preflight_assessment": [
      "get",
      "warning",
      "get_latest_vectors"
    ],
    "empirica.core.handoff.report_generator._get_postflight_assessment": [
      "get",
      "warning",
      "get_latest_vectors"
    ],
    "empirica.core.handoff.report_generator._calculate_deltas": [
      "get",
      "round"
    ],
    "empirica.core.handoff.report_generator._check_calibration": [
      "debug",
      "info",
      "isinstance",
      "get",
      "_heuristic_calibration_check",
      "get_latest_vectors"
    ],
    "empirica.core.handoff.report_generator._heuristic_calibration_check": [
      "get",
      "abs"
    ],
    "empirica.core.handoff.report_generator._identify_filled_gaps": [
      "round",
      "append",
      "any",
      "get",
      "lower"
    ],
    "empirica.core.handoff.report_generator._extract_investigation_tools": [
      "cursor",
      "fetchall",
      "list",
      "add",
      "debug",
      "sorted",
      "fetchone",
      "execute",
      "set"
    ],
    "empirica.core.handoff.report_generator._generate_recommendations": [
      "get",
      "len",
      "append"
    ],
    "empirica.core.handoff.report_generator._get_session_metadata": [
      "cursor",
      "warning",
      "isoformat",
      "now",
      "fetchone",
      "execute"
    ],
    "empirica.core.handoff.report_generator._calculate_duration": [
      "cursor",
      "debug",
      "now",
      "fetchone",
      "execute",
      "total_seconds",
      "fromisoformat"
    ],
    "empirica.core.handoff.report_generator._generate_markdown": [
      "title",
      "_format_gaps",
      "isoformat",
      "join",
      "replace",
      "now",
      "_build_delta_table",
      "get"
    ],
    "empirica.core.handoff.report_generator._build_delta_table": [
      "abs",
      "items",
      "join",
      "append",
      "upper",
      "get"
    ],
    "empirica.core.handoff.report_generator._format_gaps": [
      "get",
      "join",
      "append"
    ],
    "empirica.core.handoff.report_generator._compress_report": [
      "abs",
      "round",
      "items",
      "get",
      "dumps"
    ],
    "empirica.core.handoff.report_generator._compress_planning_handoff": [
      "dumps",
      "round"
    ],
    "empirica.core.handoff.auto_generator.auto_generate_handoff": [
      "enumerate",
      "fetchone",
      "SessionDatabase",
      "execute",
      "total_seconds",
      "extend",
      "fetchall",
      "utcnow",
      "len",
      "get",
      "fromisoformat",
      "list",
      "fromkeys",
      "isoformat",
      "append",
      "isinstance",
      "map",
      "cursor",
      "int",
      "round",
      "join",
      "close",
      "loads",
      "_get_artifacts_from_session",
      "ValueError"
    ],
    "empirica.core.handoff.auto_generator._get_artifacts_from_session": [
      "run",
      "strip",
      "debug",
      "split"
    ],
    "empirica.core.handoff.auto_generator.close_session": [
      "cursor",
      "isoformat",
      "info",
      "commit",
      "close",
      "utcnow",
      "SessionDatabase",
      "execute"
    ],
    "empirica.core.handoff.storage.__init__": [
      "DatabaseHandoffStorage",
      "warning",
      "str",
      "_create_table",
      "mkdir",
      "cwd",
      "Path",
      "info",
      "exists",
      "GitHandoffStorage",
      "connect"
    ],
    "empirica.core.handoff.storage.store_handoff": [
      "cursor",
      "warning",
      "_get_note_sha",
      "str",
      "run",
      "debug",
      "error",
      "timestamp",
      "Exception",
      "info",
      "commit",
      "store_handoff",
      "now",
      "execute",
      "dumps"
    ],
    "empirica.core.handoff.storage.load_handoff": [
      "cursor",
      "str",
      "run",
      "debug",
      "loads",
      "_row_to_dict",
      "load_handoff",
      "fetchone",
      "execute"
    ],
    "empirica.core.handoff.storage.list_handoffs": [
      "list",
      "add",
      "cursor",
      "fetchall",
      "str",
      "run",
      "debug",
      "sorted",
      "split",
      "splitlines",
      "list_handoffs",
      "len",
      "execute",
      "set"
    ],
    "empirica.core.handoff.storage._get_note_sha": [
      "run",
      "strip",
      "str"
    ],
    "empirica.core.handoff.storage._create_table": [
      "cursor",
      "execute",
      "commit"
    ],
    "empirica.core.handoff.storage.query_handoffs": [
      "cursor",
      "fetchall",
      "append",
      "_row_to_dict",
      "query_handoffs",
      "execute"
    ],
    "empirica.core.handoff.storage._row_to_dict": [
      "loads"
    ],
    "empirica.core.handoff.storage.check_sync_status": [
      "load_handoff"
    ],
    "empirica.core.qdrant.persona_registry.__init__": [
      "ConnectionError",
      "QdrantClient",
      "error",
      "info",
      "_ensure_collection",
      "get_collections"
    ],
    "empirica.core.qdrant.persona_registry._ensure_collection": [
      "VectorParams",
      "get_collection",
      "create_collection",
      "info"
    ],
    "empirica.core.qdrant.persona_registry.register_persona": [
      "PointStruct",
      "error",
      "info",
      "_persona_id_to_point_id",
      "ValueError",
      "get",
      "export_public_persona",
      "upsert"
    ],
    "empirica.core.qdrant.persona_registry.find_personas_by_domain": [
      "warning",
      "append",
      "scroll",
      "get",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.find_personas_by_tag": [
      "warning",
      "append",
      "scroll",
      "get",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.find_similar_personas": [
      "warning",
      "search",
      "append",
      "get",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.get_persona_by_id": [
      "retrieve",
      "_persona_id_to_point_id",
      "warning",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.list_all_personas": [
      "warning",
      "info",
      "scroll",
      "len",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.get_personas_by_type": [
      "get",
      "scroll",
      "warning",
      "_point_to_persona_dict"
    ],
    "empirica.core.qdrant.persona_registry.get_personas_by_reputation": [
      "get",
      "list_all_personas",
      "sort",
      "warning"
    ],
    "empirica.core.qdrant.persona_registry.delete_persona": [
      "info",
      "_persona_id_to_point_id",
      "warning",
      "delete"
    ],
    "empirica.core.qdrant.persona_registry.get_registry_stats": [
      "get_collection",
      "warning"
    ],
    "empirica.core.qdrant.persona_registry._persona_id_to_point_id": [
      "from_bytes",
      "sha256",
      "digest",
      "encode"
    ],
    "empirica.core.qdrant.persona_registry._point_to_persona_dict": [
      "get",
      "hasattr"
    ],
    "empirica.core.qdrant.embeddings.get_embedding": [
      "EmbeddingsProvider",
      "embed"
    ],
    "empirica.core.qdrant.embeddings.__init__": [
      "RuntimeError",
      "OpenAI",
      "lower",
      "getenv"
    ],
    "empirica.core.qdrant.embeddings.embed": [
      "RuntimeError",
      "create",
      "int",
      "hexdigest",
      "split",
      "sqrt",
      "sha256",
      "encode",
      "sum"
    ],
    "empirica.core.qdrant.vector_store._get_qdrant_client": [
      "QdrantClient",
      "getenv"
    ],
    "empirica.core.qdrant.vector_store._docs_collection": [],
    "empirica.core.qdrant.vector_store._memory_collection": [],
    "empirica.core.qdrant.vector_store.init_collections": [
      "create_collection",
      "_docs_collection",
      "_get_qdrant_client",
      "VectorParams",
      "collection_exists",
      "_memory_collection"
    ],
    "empirica.core.qdrant.vector_store.upsert_docs": [
      "PointStruct",
      "get_embedding",
      "append",
      "_docs_collection",
      "_get_qdrant_client",
      "get",
      "upsert"
    ],
    "empirica.core.qdrant.vector_store.upsert_memory": [
      "PointStruct",
      "get_embedding",
      "append",
      "_get_qdrant_client",
      "get",
      "upsert",
      "_memory_collection"
    ],
    "empirica.core.qdrant.vector_store._service_url": [
      "getenv"
    ],
    "empirica.core.qdrant.vector_store._rest_search": [
      "json",
      "raise_for_status",
      "post",
      "_service_url",
      "get"
    ],
    "empirica.core.qdrant.vector_store.search": [
      "hasattr",
      "search",
      "getattr",
      "get_embedding",
      "callable",
      "_docs_collection",
      "_get_qdrant_client",
      "get",
      "_memory_collection",
      "_rest_search"
    ],
    "empirica.core.tasks.repository.__init__": [
      "_ensure_tables",
      "SessionDatabase"
    ],
    "empirica.core.tasks.repository._ensure_tables": [
      "commit",
      "execute",
      "error",
      "info"
    ],
    "empirica.core.tasks.repository.save_subtask": [
      "rollback",
      "to_dict",
      "error",
      "info",
      "commit",
      "execute",
      "dumps"
    ],
    "empirica.core.tasks.repository.get_subtask": [
      "from_dict",
      "error",
      "loads",
      "fetchone",
      "execute"
    ],
    "empirica.core.tasks.repository.get_goal_subtasks": [
      "fetchall",
      "from_dict",
      "error",
      "loads",
      "append",
      "execute"
    ],
    "empirica.core.tasks.repository.update_subtask_status": [
      "rollback",
      "to_dict",
      "get_subtask",
      "error",
      "info",
      "commit",
      "dumps",
      "execute",
      "time"
    ],
    "empirica.core.tasks.repository.save_decomposition": [
      "rollback",
      "to_dict",
      "save_subtask",
      "error",
      "info",
      "commit",
      "execute",
      "dumps"
    ],
    "empirica.core.tasks.repository.get_decomposition": [
      "from_dict",
      "error",
      "loads",
      "fetchone",
      "execute"
    ],
    "empirica.core.tasks.repository.query_subtasks": [
      "fetchall",
      "from_dict",
      "error",
      "loads",
      "append",
      "execute"
    ],
    "empirica.core.tasks.repository.close": [
      "close"
    ],
    "empirica.core.tasks.types.create": [
      "SubTask",
      "uuid4",
      "str"
    ],
    "empirica.core.tasks.types.to_dict": [
      "to_dict"
    ],
    "empirica.core.tasks.types.from_dict": [
      "TaskStatus",
      "TaskDecomposition",
      "from_dict",
      "EpistemicImportance",
      "get",
      "SubTask",
      "time"
    ],
    "empirica.core.docs.doc_planner._load_yaml": [
      "RuntimeError",
      "open",
      "safe_load"
    ],
    "empirica.core.docs.doc_planner._load_semantic_index": [
      "get",
      "_load_yaml",
      "exists",
      "join"
    ],
    "empirica.core.docs.doc_planner._find_cli_reference": [
      "listdir",
      "startswith",
      "join",
      "lower",
      "isdir"
    ],
    "empirica.core.docs.doc_planner.compute_doc_plan": [
      "getcwd",
      "SessionDatabase",
      "max",
      "execute",
      "get_project_unknowns",
      "fetchall",
      "dict",
      "items",
      "len",
      "get",
      "lower",
      "_find_cli_reference",
      "append",
      "min",
      "cursor",
      "round",
      "_suggest_if_present",
      "close",
      "get_project_findings",
      "any",
      "_load_semantic_index"
    ],
    "empirica.core.docs.doc_planner._suggest_if_present": [
      "append",
      "get"
    ],
    "empirica.core.validation.rehydration.__init__": [],
    "empirica.core.validation.rehydration.rehydrate_from_checkpoint": [
      "round",
      "_format_rehydration_message",
      "get",
      "calculate_understanding_ratio",
      "min",
      "estimate_rehydration_boost",
      "_identify_rehydration_warnings"
    ],
    "empirica.core.validation.rehydration._identify_rehydration_warnings": [
      "append",
      "len",
      "max",
      "get",
      "sum"
    ],
    "empirica.core.validation.rehydration._format_rehydration_message": [
      "len"
    ],
    "empirica.core.validation.rehydration.calculate_adjusted_preflight": [
      "copy",
      "len",
      "rehydrate_from_checkpoint",
      "get",
      "min"
    ],
    "empirica.core.validation.coherence_validator.__init__": [],
    "empirica.core.validation.coherence_validator.validate_before_handoff": [
      "_check_scope_match",
      "append",
      "_check_findings_honesty",
      "_format_message",
      "_check_trajectory"
    ],
    "empirica.core.validation.coherence_validator._check_scope_match": [
      "get",
      "get_git_diff_summary",
      "abs"
    ],
    "empirica.core.validation.coherence_validator._check_trajectory": [
      "get",
      "analyze_epistemic_trajectory"
    ],
    "empirica.core.validation.coherence_validator._check_findings_honesty": [
      "get",
      "len",
      "sum"
    ],
    "empirica.core.validation.coherence_validator._format_message": [
      "join"
    ],
    "empirica.core.validation.handoff_validator.__init__": [],
    "empirica.core.validation.handoff_validator.validate_handoff": [
      "_check_claim_vs_reality",
      "_check_unknowns_reasonableness",
      "append",
      "_check_overall_coherence",
      "len",
      "any",
      "get",
      "_format_validation_message",
      "_check_findings_credibility"
    ],
    "empirica.core.validation.handoff_validator._check_claim_vs_reality": [
      "get",
      "get_git_diff_summary",
      "lower",
      "len"
    ],
    "empirica.core.validation.handoff_validator._check_findings_credibility": [
      "get",
      "len",
      "sum"
    ],
    "empirica.core.validation.handoff_validator._check_unknowns_reasonableness": [
      "get",
      "len"
    ],
    "empirica.core.validation.handoff_validator._check_overall_coherence": [
      "get",
      "len",
      "sum"
    ],
    "empirica.core.validation.handoff_validator._format_validation_message": [],
    "empirica.core.validation.validation_utils.get_git_diff_summary": [
      "warning",
      "str",
      "int",
      "run",
      "split",
      "enumerate",
      "replace",
      "strip",
      "len"
    ],
    "empirica.core.validation.validation_utils.analyze_epistemic_trajectory": [
      "get",
      "abs"
    ],
    "empirica.core.validation.validation_utils.understand_finding": [
      "get",
      "lower",
      "warning",
      "any"
    ],
    "empirica.core.validation.validation_utils.calculate_understanding_ratio": [
      "len",
      "understand_finding",
      "sum"
    ],
    "empirica.core.validation.validation_utils.estimate_rehydration_boost": [
      "min",
      "calculate_understanding_ratio",
      "len",
      "warning"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_jira_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_confluence_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_slack_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_github_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_database_query_plugin": [
      "InvestigationPlugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.create_common_plugins": [
      "create_slack_plugin",
      "create_jira_plugin",
      "create_github_plugin",
      "create_confluence_plugin"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.__post_init__": [
      "ValueError"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.to_capability_dict": [],
    "empirica.core.metacognitive_cascade.investigation_plugin.__repr__": [
      "len"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.__init__": [],
    "empirica.core.metacognitive_cascade.investigation_plugin.register": [
      "ValueError",
      "info"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.unregister": [
      "info"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.get": [
      "get"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.list_plugins": [
      "list",
      "keys"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.get_all_capabilities": [
      "items",
      "to_capability_dict"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.find_by_vector": [
      "values"
    ],
    "empirica.core.metacognitive_cascade.investigation_plugin.__len__": [
      "len"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade.to_json": [
      "_extract_vector_summary"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._extract_vector_summary": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade.__init__": [
      "keys",
      "warning",
      "int",
      "get_profile_loader",
      "warn",
      "GitEnhancedReflexLogger",
      "error",
      "ParallelReasoningSystem",
      "info",
      "TokenEfficiencyMetrics",
      "len",
      "SessionJSONHandler",
      "MirrorDriftMonitor",
      "SessionDatabase",
      "CanonicalEpistemicAssessor",
      "time",
      "select_profile",
      "initialize_tmux_dashboard"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._parse_vectors_to_assessment": [
      "get",
      "EpistemicAssessmentSchema",
      "get_vector",
      "VectorState"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._identify_knowledge_gaps": [
      "append",
      "items"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._identify_epistemic_gaps": [
      "append",
      "items",
      "get",
      "sort"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._build_tool_capability_map": [
      "_get_standard_tool_capabilities",
      "_get_empirica_tool_capabilities",
      "update",
      "items",
      "_classify_tool_type",
      "append",
      "to_capability_dict"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._classify_tool_type": [
      "lower",
      "any"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._get_standard_tool_capabilities": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._get_empirica_tool_capabilities": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade.update_from_tool_execution": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._verify_readiness": [
      "log_cascade_phase",
      "warning",
      "str",
      "log_thought",
      "items",
      "values",
      "join",
      "info",
      "append",
      "detect_drift",
      "len",
      "any",
      "upper",
      "get"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._make_final_decision": [
      "_extract_vector_summary",
      "_generate_execution_guidance",
      "_build_decision_rationale"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._build_decision_rationale": [
      "append",
      "join"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._generate_execution_guidance": [
      "append",
      "items"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._calculate_epistemic_delta": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._check_calibration_accuracy": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._generate_task_id": [
      "isoformat",
      "hexdigest",
      "now",
      "sha256",
      "encode"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._enter_phase": [],
    "empirica.core.metacognitive_cascade.metacognitive_cascade._update_tmux_display": [
      "trigger_action_update",
      "open",
      "warning",
      "hasattr",
      "_extract_vector_summary",
      "mkdir",
      "dump",
      "Path",
      "time"
    ],
    "empirica.core.metacognitive_cascade.metacognitive_cascade.get_vector": [
      "get",
      "VectorState"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.__init__": [
      "CodeAnalysisStrategy",
      "items",
      "ResearchStrategy",
      "GeneralStrategy",
      "register_strategy",
      "CollaborativeStrategy"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.to_dict": [],
    "empirica.core.metacognitive_cascade.investigation_strategy._extract_gaps": [
      "items"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy._prioritize_gaps": [
      "append",
      "sort",
      "extend"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.register_strategy": [
      "type",
      "isinstance",
      "TypeError"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.get_strategy": [
      "get"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.list_domains": [
      "list",
      "keys"
    ],
    "empirica.core.metacognitive_cascade.investigation_strategy.infer_domain": [
      "get",
      "upper",
      "ValueError",
      "load_profile"
    ],
    "empirica.core.identity.signature.create_eep1_payload": [
      "isoformat",
      "hexdigest",
      "now",
      "sha256",
      "encode"
    ],
    "empirica.core.identity.signature.canonicalize_payload": [
      "dumps"
    ],
    "empirica.core.identity.signature.sign_assessment": [
      "canonicalize_payload",
      "RuntimeError",
      "hex",
      "sign",
      "public_key_hex",
      "isoformat",
      "info",
      "create_eep1_payload",
      "now",
      "encode"
    ],
    "empirica.core.identity.signature.verify_signature": [
      "canonicalize_payload",
      "warning",
      "verify",
      "error",
      "info",
      "encode",
      "fromhex"
    ],
    "empirica.core.identity.signature.verify_eep1_payload": [
      "hexdigest",
      "join",
      "append",
      "now",
      "len",
      "sha256",
      "verify_signature",
      "get",
      "encode",
      "fromisoformat"
    ],
    "empirica.core.identity.signature.compute_cascade_trace_hash": [
      "sha256",
      "hexdigest",
      "encode"
    ],
    "empirica.core.identity.ai_identity.__init__": [
      "Path"
    ],
    "empirica.core.identity.ai_identity.keypair_path": [],
    "empirica.core.identity.ai_identity.public_key_path": [],
    "empirica.core.identity.ai_identity.generate_keypair": [
      "RuntimeError",
      "public_key",
      "isoformat",
      "info",
      "generate",
      "now"
    ],
    "empirica.core.identity.ai_identity.save_keypair": [
      "RuntimeError",
      "NoEncryption",
      "open",
      "hex",
      "mkdir",
      "dump",
      "info",
      "exists",
      "private_bytes",
      "public_bytes",
      "chmod"
    ],
    "empirica.core.identity.ai_identity.load_keypair": [
      "open",
      "FileNotFoundError",
      "info",
      "exists",
      "from_public_bytes",
      "load",
      "get",
      "ValueError",
      "from_private_bytes",
      "fromhex"
    ],
    "empirica.core.identity.ai_identity.sign": [
      "sign",
      "RuntimeError"
    ],
    "empirica.core.identity.ai_identity.verify": [
      "verify",
      "from_public_bytes"
    ],
    "empirica.core.identity.ai_identity.public_key_hex": [
      "RuntimeError",
      "public_bytes",
      "hex"
    ],
    "empirica.core.identity.ai_identity.export_public_key": [
      "public_key_hex",
      "RuntimeError"
    ],
    "empirica.core.identity.ai_identity.list_identities": [
      "open",
      "glob",
      "warning",
      "str",
      "append",
      "exists",
      "load"
    ],
    "empirica.core.identity.ai_identity.load_identity": [
      "AIIdentity",
      "load_keypair",
      "str"
    ],
    "empirica.core.identity.ai_identity.create_identity": [
      "AIIdentity",
      "generate_keypair",
      "str",
      "save_keypair"
    ],
    "empirica.core.identity.ai_identity.identity_exists": [
      "exists"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.example_uncertainty_evaluator": [
      "get"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.register_evaluator": [
      "append",
      "info"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.clear_evaluators": [
      "clear"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.is_enabled": [
      "len"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.evaluate_checkpoint": [
      "warning",
      "is_enabled",
      "error",
      "info",
      "evaluator",
      "append",
      "isinstance"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks.post_checkpoint_hook": [
      "debug",
      "evaluate_checkpoint",
      "_log_decision",
      "is_enabled"
    ],
    "empirica.core.canonical.empirica_git.sentinel_hooks._log_decision": [
      "info"
    ],
    "empirica.core.canonical.empirica_git.session_sync.__init__": [
      "_check_git_repo",
      "getcwd",
      "_check_remote"
    ],
    "empirica.core.canonical.empirica_git.session_sync._check_git_repo": [
      "run"
    ],
    "empirica.core.canonical.empirica_git.session_sync._check_remote": [
      "run",
      "strip",
      "len"
    ],
    "empirica.core.canonical.empirica_git.session_sync.pull_latest": [
      "debug",
      "warning",
      "run",
      "info"
    ],
    "empirica.core.canonical.empirica_git.session_sync.push_checkpoint": [
      "debug",
      "warning",
      "run",
      "info"
    ],
    "empirica.core.canonical.empirica_git.session_sync.auto_sync_before_resume": [
      "pull_latest"
    ],
    "empirica.core.canonical.empirica_git.session_sync.auto_sync_after_checkpoint": [
      "debug",
      "push_checkpoint"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager.auto_checkpoint": [
      "_create_checkpoint",
      "warning",
      "is_enabled",
      "auto_checkpoint",
      "info",
      "CheckpointManager"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager.__init__": [
      "_check_git_repo",
      "getcwd"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager._check_git_repo": [
      "run"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager.is_enabled": [
      "debug"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager._create_checkpoint": [
      "run",
      "isoformat",
      "now",
      "strip",
      "dumps"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager.load_checkpoint": [
      "warning",
      "_find_latest_checkpoint",
      "_load_checkpoint_by_hash"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager._load_checkpoint_by_hash": [
      "run",
      "loads"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager.load_recent_checkpoints": [
      "warning",
      "run",
      "split",
      "append",
      "strip",
      "len",
      "get",
      "_load_checkpoint_by_hash"
    ],
    "empirica.core.canonical.empirica_git.checkpoint_manager._find_latest_checkpoint": [
      "run",
      "split",
      "strip",
      "get",
      "_load_checkpoint_by_hash"
    ],
    "empirica.core.canonical.empirica_git.goal_store.__init__": [
      "_check_git_repo",
      "getcwd"
    ],
    "empirica.core.canonical.empirica_git.goal_store._check_git_repo": [
      "run"
    ],
    "empirica.core.canonical.empirica_git.goal_store.store_goal": [
      "warning",
      "debug",
      "run",
      "isoformat",
      "info",
      "now",
      "strip",
      "dumps"
    ],
    "empirica.core.canonical.empirica_git.goal_store.load_goal": [
      "run",
      "strip",
      "warning",
      "loads"
    ],
    "empirica.core.canonical.empirica_git.goal_store.discover_goals": [
      "startswith",
      "warning",
      "run",
      "load_goal",
      "split",
      "append",
      "strip",
      "len",
      "get"
    ],
    "empirica.core.canonical.empirica_git.goal_store.add_lineage": [
      "store_goal",
      "load_goal",
      "isoformat",
      "append",
      "now",
      "get"
    ],
    "empirica.core.persona.harness.persona_harness.__init__": [
      "warning",
      "load_keypair",
      "PersonaManager",
      "info",
      "load_persona",
      "save_keypair",
      "AIIdentity",
      "generate_keypair",
      "get_type"
    ],
    "empirica.core.persona.harness.persona_harness._create_persona_cascade": [
      "int",
      "_create_persona_aware_assessment",
      "timestamp",
      "_select_investigation_profile",
      "info",
      "now",
      "CanonicalEpistemicCascade"
    ],
    "empirica.core.persona.harness.persona_harness._create_persona_aware_assessment": [
      "original_assess_method",
      "_apply_priors"
    ],
    "empirica.core.persona.harness.persona_harness._apply_priors": [
      "debug",
      "blend_vector_new",
      "calculate_tier_confidences",
      "VectorAssessment"
    ],
    "empirica.core.persona.harness.persona_harness._select_investigation_profile": [
      "get",
      "get_type"
    ],
    "empirica.core.persona.harness.persona_harness._interpret_with_persona": [
      "copy",
      "get_type",
      "_extract_persona_findings",
      "_generate_persona_recommendation"
    ],
    "empirica.core.persona.harness.persona_harness._extract_persona_findings": [
      "get",
      "lower",
      "extend",
      "append"
    ],
    "empirica.core.persona.harness.persona_harness._generate_persona_recommendation": [
      "upper"
    ],
    "empirica.core.persona.harness.persona_harness.get_persona_info": [
      "get_type"
    ],
    "empirica.core.persona.harness.persona_harness.blend_vector_new": [
      "VectorAssessment"
    ],
    "empirica.core.persona.harness.communication.send_message": [
      "open",
      "to_dict",
      "debug",
      "NotImplementedError",
      "error",
      "mkdir",
      "dump",
      "Path",
      "isinstance",
      "ValueError"
    ],
    "empirica.core.persona.harness.communication.receive_message": [
      "glob",
      "open",
      "sleep",
      "unlink",
      "from_dict",
      "debug",
      "NotImplementedError",
      "sorted",
      "error",
      "Path",
      "exists",
      "ValueError",
      "load",
      "time"
    ],
    "empirica.core.persona.harness.communication.to_dict": [],
    "empirica.core.persona.harness.communication.from_dict": [
      "get",
      "cls",
      "MessageType"
    ],
    "empirica.core.persona.harness.communication.sign": [
      "dumps",
      "sign_assessment",
      "to_dict",
      "pop"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator.__init__": [
      "get_composition_strategy",
      "get_arbitration_strategy",
      "PersonaManager",
      "info"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._load_persona_profiles": [
      "ValueError",
      "load_persona"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._create_persona_harnesses": [
      "PersonaHarness"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._compose_assessments": [
      "composition_strategy"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._extract_actions_and_confidences": [
      "determine_action",
      "items",
      "calculate_tier_confidences"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._arbitrate_conflicts": [
      "arbitration_strategy"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._calculate_agreement_score": [
      "len",
      "Counter",
      "values",
      "most_common"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator._detect_conflicts": [
      "items",
      "values",
      "append",
      "len",
      "Counter",
      "set"
    ],
    "empirica.core.persona.sentinel.sentinel_orchestrator.mock_vector": [
      "VectorAssessment"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies.majority_vote_arbitration": [
      "dict",
      "values",
      "info",
      "append",
      "ArbitrationResult",
      "_choose_most_cautious",
      "Counter",
      "most_common",
      "ValueError",
      "len"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies.confidence_weighted_arbitration": [
      "warning",
      "items",
      "values",
      "info",
      "append",
      "majority_vote_arbitration",
      "ArbitrationResult",
      "len",
      "ValueError",
      "max",
      "get",
      "sum"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies.pessimistic_arbitration": [
      "items",
      "info",
      "ArbitrationResult",
      "len",
      "ValueError"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies.domain_weighted_arbitration": [
      "warning",
      "items",
      "values",
      "info",
      "append",
      "ArbitrationResult",
      "len",
      "ValueError",
      "max",
      "get",
      "lower",
      "sum",
      "confidence_weighted_arbitration"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies.escalate_on_conflict_arbitration": [
      "list",
      "items",
      "values",
      "info",
      "ArbitrationResult",
      "len",
      "Counter",
      "ValueError",
      "set"
    ],
    "empirica.core.persona.sentinel.arbitration_strategies._choose_most_cautious": [],
    "empirica.core.persona.sentinel.arbitration_strategies.get_arbitration_strategy": [
      "list",
      "keys",
      "ValueError"
    ],
    "empirica.core.persona.sentinel.composition_strategies.average_composition": [
      "list",
      "VectorAssessment",
      "compose_vector",
      "keys",
      "int",
      "EpistemicAssessmentSchema",
      "items",
      "getattr",
      "join",
      "info",
      "append",
      "mean",
      "len",
      "ValueError"
    ],
    "empirica.core.persona.sentinel.composition_strategies.weighted_by_confidence_composition": [
      "list",
      "VectorAssessment",
      "average_composition",
      "keys",
      "warning",
      "compose_vector_weighted",
      "int",
      "items",
      "EpistemicAssessmentSchema",
      "getattr",
      "calculate_tier_confidences",
      "values",
      "info",
      "append",
      "join",
      "len",
      "ValueError",
      "sum"
    ],
    "empirica.core.persona.sentinel.composition_strategies.weighted_by_domain_composition": [
      "warning",
      "getattr",
      "max",
      "items",
      "values",
      "len",
      "lower",
      "list",
      "VectorAssessment",
      "keys",
      "EpistemicAssessmentSchema",
      "info",
      "append",
      "sum",
      "average_composition",
      "compose_vector_weighted",
      "int",
      "join",
      "ValueError"
    ],
    "empirica.core.persona.sentinel.composition_strategies.get_composition_strategy": [
      "list",
      "keys",
      "ValueError"
    ],
    "empirica.core.persona.sentinel.composition_strategies.compose_vector": [
      "VectorAssessment",
      "int",
      "items",
      "getattr",
      "join",
      "mean",
      "append",
      "len"
    ],
    "empirica.core.persona.sentinel.composition_strategies.compose_vector_weighted": [
      "VectorAssessment",
      "int",
      "items",
      "getattr",
      "join",
      "append",
      "sum"
    ],
    "empirica.core.persona.sentinel.orchestration_result.to_dict": [
      "items",
      "to_dict"
    ],
    "empirica.core.persona.sentinel.orchestration_result.get_summary": [
      "join",
      "append",
      "len",
      "upper",
      "get"
    ],
    "empirica.api.routes.verification.verify_checkpoint": [
      "get",
      "route",
      "jsonify"
    ],
    "empirica.api.routes.verification.list_session_signatures": [
      "route",
      "jsonify"
    ],
    "empirica.api.routes.sessions.list_sessions": [
      "cursor",
      "route",
      "fetchall",
      "str",
      "int",
      "error",
      "append",
      "jsonify",
      "len",
      "fetchone",
      "SessionDatabase",
      "get",
      "execute",
      "min",
      "extend"
    ],
    "empirica.api.routes.sessions.get_session": [
      "cursor",
      "route",
      "fetchall",
      "str",
      "int",
      "error",
      "append",
      "jsonify",
      "len",
      "fetchone",
      "SessionDatabase",
      "execute"
    ],
    "empirica.api.routes.sessions.get_session_checks": [
      "route",
      "str",
      "error",
      "close",
      "append",
      "jsonify",
      "len",
      "SessionDatabase",
      "get_vectors_by_phase",
      "get"
    ],
    "empirica.api.routes.heatmaps.get_file_uncertainty": [
      "route",
      "jsonify"
    ],
    "empirica.api.routes.heatmaps.get_module_epistemic": [
      "route",
      "jsonify"
    ],
    "empirica.api.routes.deltas.get_session_deltas": [
      "cursor",
      "route",
      "str",
      "round",
      "error",
      "enumerate",
      "jsonify",
      "float",
      "len",
      "fetchone",
      "SessionDatabase",
      "execute",
      "sum"
    ],
    "empirica.api.routes.deltas.get_commit_epistemic": [
      "route",
      "jsonify"
    ],
    "empirica.api.routes.comparison.get_ai_learning_curve": [
      "route",
      "int",
      "jsonify",
      "get",
      "min"
    ],
    "empirica.api.routes.comparison.compare_ais": [
      "route",
      "split",
      "jsonify",
      "strip",
      "get"
    ],
    "empirica.integrations.beads.config.__init__": [
      "_load_config",
      "Path"
    ],
    "empirica.integrations.beads.config._load_config": [
      "open",
      "warning",
      "debug",
      "exists",
      "get",
      "_default_config",
      "safe_load"
    ],
    "empirica.integrations.beads.config._default_config": [],
    "empirica.integrations.beads.config.enabled": [
      "get"
    ],
    "empirica.integrations.beads.config.auto_detect": [
      "get"
    ],
    "empirica.integrations.beads.config.use_agent_mail": [
      "get"
    ],
    "empirica.integrations.beads.config.agent_mail_url": [
      "get"
    ],
    "empirica.integrations.beads.config.agent_name": [
      "get"
    ],
    "empirica.integrations.beads.config.save": [
      "open",
      "mkdir",
      "dump",
      "info",
      "exists",
      "safe_load"
    ],
    "empirica.integrations.beads.adapter.__init__": [],
    "empirica.integrations.beads.adapter.is_available": [
      "run",
      "strip",
      "debug"
    ],
    "empirica.integrations.beads.adapter.create_issue": [
      "warning",
      "str",
      "run",
      "error",
      "join",
      "loads",
      "info",
      "is_available",
      "get",
      "extend"
    ],
    "empirica.integrations.beads.adapter.add_dependency": [
      "run",
      "error",
      "is_available",
      "info"
    ],
    "empirica.integrations.beads.adapter.get_ready_work": [
      "str",
      "run",
      "debug",
      "error",
      "loads",
      "len",
      "is_available",
      "isinstance",
      "extend"
    ],
    "empirica.integrations.beads.adapter.update_status": [
      "run",
      "error",
      "is_available",
      "info"
    ],
    "empirica.integrations.beads.adapter.close_issue": [
      "run",
      "error",
      "is_available",
      "info"
    ],
    "empirica.integrations.beads.adapter.get_issue": [
      "run",
      "error",
      "is_available",
      "loads"
    ],
    "empirica.integrations.beads.adapter.get_dependency_tree": [
      "run",
      "error",
      "is_available"
    ],
    "empirica.cli.utils.config_validator.validate_config": [
      "open",
      "str",
      "join",
      "split",
      "validate",
      "exists",
      "load",
      "dirname"
    ],
    "empirica.cli.utils.config_validator.print_validation_error": [
      "dumps",
      "replace",
      "print"
    ],
    "empirica.cli.utils.config_validator.get_schema_name": [
      "get"
    ],
    "empirica.cli.utils.project_resolver.resolve_project_id": [
      "resolve_project_id",
      "exit",
      "close",
      "SessionDatabase",
      "print"
    ],
    "empirica.cli.utils.project_resolver.get_project_name": [
      "get",
      "get_project",
      "SessionDatabase",
      "close"
    ],
    "empirica.cli.command_handlers.cascade_commands.handle_decision_command": [
      "getattr",
      "enumerate",
      "info",
      "run_epistemic_cascade",
      "get",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.cascade_commands.handle_preflight_command": [
      "warning",
      "getattr",
      "load_keypair",
      "SessionDatabase",
      "sign_assessment",
      "print",
      "read",
      "create_cascade",
      "open",
      "run",
      "GitEnhancedReflexLogger",
      "hasattr",
      "items",
      "utcnow",
      "isfile",
      "parse_llm_response",
      "strip",
      "_interpret_score",
      "upper",
      "sha256",
      "get",
      "create_session",
      "handle_cli_error",
      "input",
      "isoformat",
      "_get_recommendation",
      "hexdigest",
      "public_key_hex",
      "error",
      "assess",
      "info",
      "append",
      "isinstance",
      "CanonicalEpistemicAssessor",
      "AIIdentity",
      "encode",
      "dumps",
      "print_header",
      "str",
      "debug",
      "auto_checkpoint",
      "join",
      "close",
      "loads",
      "add_checkpoint",
      "uuid4"
    ],
    "empirica.cli.command_handlers.cascade_commands.handle_postflight_command": [
      "print"
    ],
    "empirica.cli.command_handlers.cascade_commands.handle_workflow_command": [
      "input",
      "handle_cli_error",
      "str",
      "getattr",
      "join",
      "get",
      "_summarize_learning",
      "uuid4",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.cascade_commands._get_cascade_profile_thresholds": [
      "ProfileLoader",
      "get",
      "getattr",
      "get_profile"
    ],
    "empirica.cli.command_handlers.cascade_commands._interpret_score": [
      "_get_cascade_profile_thresholds"
    ],
    "empirica.cli.command_handlers.cascade_commands._get_recommendation": [
      "get_recommendation_from_vectors"
    ],
    "empirica.cli.command_handlers.cascade_commands._calculate_vector_delta": [
      "get"
    ],
    "empirica.cli.command_handlers.cascade_commands._assess_calibration": [
      "get",
      "calc_confidence",
      "round"
    ],
    "empirica.cli.command_handlers.cascade_commands._summarize_learning": [
      "append",
      "items"
    ],
    "empirica.cli.command_handlers.cascade_commands._print_vector_with_delta": [
      "_interpret_score",
      "lower",
      "print"
    ],
    "empirica.cli.command_handlers.cascade_commands.calc_confidence": [
      "get"
    ],
    "empirica.cli.command_handlers.investigation_commands._get_profile_thresholds": [
      "ProfileLoader",
      "getattr",
      "get_profile"
    ],
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_command": [
      "handle_analyze_command",
      "_investigate_file",
      "items",
      "getattr",
      "isfile",
      "_investigate_directory",
      "exists",
      "_investigate_concept",
      "get",
      "handle_cli_error",
      "print",
      "isdir"
    ],
    "empirica.cli.command_handlers.investigation_commands.handle_analyze_command": [
      "_get_profile_thresholds",
      "items",
      "getattr",
      "isinstance",
      "get",
      "analyze",
      "handle_cli_error",
      "EmpiricalPerformanceAnalyzer",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.investigation_commands._investigate_file": [
      "CodeIntelligenceAnalyzer",
      "str",
      "analyze_file",
      "basename",
      "get"
    ],
    "empirica.cli.command_handlers.investigation_commands._investigate_directory": [
      "str",
      "basename",
      "WorkspaceAwareness",
      "analyze_directory",
      "get"
    ],
    "empirica.cli.command_handlers.investigation_commands._investigate_concept": [
      "get",
      "CanonicalEpistemicAssessor",
      "str",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_create_branch_command": [
      "hasattr",
      "getattr",
      "close",
      "create_branch",
      "isinstance",
      "SessionDatabase",
      "ValueError",
      "dumps",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_checkpoint_branch_command": [
      "dumps",
      "int",
      "hasattr",
      "calculate_branch_merge_score",
      "getattr",
      "close",
      "checkpoint_branch",
      "isinstance",
      "SessionDatabase",
      "ValueError",
      "get",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.investigation_commands.handle_investigate_merge_branches_command": [
      "dumps",
      "int",
      "hasattr",
      "merge_branches",
      "getattr",
      "close",
      "len",
      "SessionDatabase",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.identity_commands.handle_identity_create_command": [
      "create_identity",
      "str",
      "hasattr",
      "public_key_hex",
      "getattr",
      "Path",
      "identity_exists",
      "IdentityManager",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.identity_commands.handle_identity_list_command": [
      "str",
      "hasattr",
      "getattr",
      "enumerate",
      "list_identities",
      "len",
      "IdentityManager",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.identity_commands.handle_identity_export_command": [
      "export_public_key",
      "dumps",
      "str",
      "hasattr",
      "items",
      "getattr",
      "load_identity",
      "IdentityManager",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.identity_commands.handle_identity_verify_command": [
      "get_session",
      "str",
      "hasattr",
      "getattr",
      "close",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.workflow_commands.handle_preflight_submit_command": [
      "getattr",
      "SessionDatabase",
      "execute",
      "print",
      "read",
      "open",
      "hasattr",
      "GitEnhancedReflexLogger",
      "len",
      "get",
      "handle_cli_error",
      "error",
      "commit",
      "isinstance",
      "time",
      "dumps",
      "str",
      "exit",
      "close",
      "add_checkpoint",
      "exists",
      "ValueError",
      "_extract_all_vectors",
      "uuid4",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.workflow_commands.handle_check_command": [
      "getattr",
      "enumerate",
      "print",
      "read",
      "open",
      "hasattr",
      "GitEnhancedReflexLogger",
      "len",
      "upper",
      "get",
      "isinstance",
      "dumps",
      "time",
      "str",
      "calculate_decision",
      "exit",
      "type",
      "add_checkpoint",
      "exists",
      "ValueError",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.workflow_commands.handle_check_submit_command": [
      "warning",
      "getattr",
      "print",
      "hasattr",
      "GitEnhancedReflexLogger",
      "items",
      "run",
      "len",
      "upper",
      "get",
      "error",
      "append",
      "isinstance",
      "dumps",
      "str",
      "add_checkpoint",
      "ValueError",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.workflow_commands._extract_numeric_value": [
      "isdigit",
      "items",
      "values",
      "float",
      "replace",
      "isinstance"
    ],
    "empirica.cli.command_handlers.workflow_commands._extract_all_vectors": [
      "_extract_numeric_value",
      "items"
    ],
    "empirica.cli.command_handlers.workflow_commands.handle_postflight_submit_command": [
      "warning",
      "getattr",
      "enumerate",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "read",
      "open",
      "hasattr",
      "GitEnhancedReflexLogger",
      "run",
      "len",
      "get",
      "bootstrap_project_breadcrumbs",
      "error",
      "append",
      "isinstance",
      "dumps",
      "get_last_checkpoint",
      "abs",
      "cursor",
      "str",
      "round",
      "exit",
      "debug",
      "close",
      "add_checkpoint",
      "compute_doc_plan",
      "exists",
      "ValueError",
      "_extract_all_vectors",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.goals_ready_command.handle_goals_ready_command": [
      "BeadsAdapter",
      "dumps",
      "str",
      "getattr",
      "error",
      "close",
      "append",
      "loads",
      "get_ready_work",
      "len",
      "is_available",
      "fetchone",
      "SessionDatabase",
      "get",
      "execute",
      "print"
    ],
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_command": [
      "getattr",
      "enumerate",
      "UsageMonitor",
      "print",
      "get_adapter_costs",
      "items",
      "get_config",
      "handle_monitor_export_command",
      "len",
      "upper",
      "get",
      "reversed",
      "info",
      "handle_monitor_reset_command",
      "health_check_all",
      "handle_monitor_cost_command",
      "debug",
      "get_registry",
      "get_stats",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_export_command": [
      "open",
      "writerow",
      "writeheader",
      "getattr",
      "dump",
      "UsageMonitor",
      "DictWriter",
      "len",
      "get_stats",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_reset_command": [
      "handle_cli_error",
      "input",
      "getattr",
      "reset_stats",
      "UsageMonitor",
      "strip",
      "lower",
      "print"
    ],
    "empirica.cli.command_handlers.monitor_commands.handle_monitor_cost_command": [
      "items",
      "sorted",
      "getattr",
      "UsageMonitor",
      "upper",
      "get_stats",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.monitor_commands.handle_check_drift_command": [
      "setattr",
      "dumps",
      "items",
      "type",
      "getattr",
      "MockAssessment",
      "load_recent_checkpoints",
      "replace",
      "CheckpointManager",
      "detect_drift",
      "MirrorDriftMonitor",
      "upper",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.monitor_commands.__init__": [
      "setattr",
      "items",
      "type",
      "mkdir",
      "Path",
      "get_config",
      "expanduser",
      "get",
      "_load_stats"
    ],
    "empirica.cli.command_handlers.monitor_commands._load_stats": [
      "open",
      "warning",
      "isoformat",
      "now",
      "exists",
      "load"
    ],
    "empirica.cli.command_handlers.monitor_commands._save_stats": [
      "open",
      "dump"
    ],
    "empirica.cli.command_handlers.monitor_commands.record_request": [
      "warning",
      "debug",
      "isoformat",
      "append",
      "now",
      "len",
      "_save_stats"
    ],
    "empirica.cli.command_handlers.monitor_commands.get_stats": [],
    "empirica.cli.command_handlers.monitor_commands.reset_stats": [
      "isoformat",
      "now",
      "_save_stats",
      "info"
    ],
    "empirica.cli.command_handlers.project_commands.handle_project_create_command": [
      "hasattr",
      "create_project",
      "getattr",
      "join",
      "loads",
      "close",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.project_commands.handle_project_handoff_command": [
      "hasattr",
      "items",
      "getattr",
      "create_project_handoff",
      "close",
      "loads",
      "aggregate_project_learning_deltas",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.project_commands.handle_project_list_command": [
      "cursor",
      "fetchall",
      "dict",
      "hasattr",
      "getattr",
      "enumerate",
      "close",
      "len",
      "SessionDatabase",
      "dumps",
      "execute",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.project_commands.handle_project_bootstrap_command": [
      "getattr",
      "enumerate",
      "get_current_subject",
      "SessionDatabase",
      "print",
      "title",
      "hasattr",
      "len",
      "upper",
      "get",
      "bootstrap_project_breadcrumbs",
      "detect_gaps",
      "append",
      "replace",
      "dumps",
      "get_latest_vectors",
      "MemoryGapDetector",
      "join",
      "close",
      "loads",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.project_commands.handle_finding_log_command": [
      "read",
      "open",
      "dumps",
      "resolve_project_id",
      "hasattr",
      "exit",
      "log_finding",
      "getattr",
      "close",
      "get_current_subject",
      "exists",
      "SessionDatabase",
      "get",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.project_commands.handle_unknown_log_command": [
      "resolve_project_id",
      "log_unknown",
      "hasattr",
      "getattr",
      "close",
      "get_current_subject",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.project_commands.handle_deadend_log_command": [
      "log_dead_end",
      "resolve_project_id",
      "hasattr",
      "getattr",
      "close",
      "get_current_subject",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.project_commands.handle_refdoc_add_command": [
      "resolve_project_id",
      "hasattr",
      "getattr",
      "close",
      "SessionDatabase",
      "dumps",
      "add_reference_doc",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.component_commands.handle_list_command": [
      "get_components",
      "items",
      "getattr",
      "sorted",
      "append",
      "get_component_registry",
      "len",
      "format_component_list",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.component_commands.handle_explain_command": [
      "handle_cli_error",
      "getattr",
      "get_component_registry",
      "get_component",
      "get",
      "find_similar_components",
      "print"
    ],
    "empirica.cli.command_handlers.component_commands.handle_demo_command": [
      "handle_cli_error",
      "getattr",
      "enumerate",
      "choice",
      "run_component_demo",
      "get_component_registry",
      "get_component",
      "get",
      "get_working_components",
      "print"
    ],
    "empirica.cli.command_handlers.goal_discovery_commands.handle_goals_discover_command": [
      "discover_goals",
      "str",
      "hasattr",
      "getattr",
      "enumerate",
      "GitGoalStore",
      "len",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.goal_discovery_commands.handle_goals_resume_command": [
      "GoalRepository",
      "dumps",
      "str",
      "add_lineage",
      "load_goal",
      "hasattr",
      "items",
      "getattr",
      "close",
      "GitGoalStore",
      "isinstance",
      "upper",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.skill_commands._load_skill_sources": [
      "open",
      "join",
      "exists",
      "get",
      "safe_load"
    ],
    "empirica.cli.command_handlers.skill_commands.handle_skill_suggest_command": [
      "listdir",
      "open",
      "getcwd",
      "safe_load",
      "get",
      "getattr",
      "join",
      "_load_skill_sources",
      "append",
      "replace",
      "exists",
      "endswith",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.skill_commands.handle_skill_fetch_command": [
      "ZipFile",
      "namelist",
      "parse_markdown_to_skill",
      "getcwd",
      "FileNotFoundError",
      "getattr",
      "_save_skill",
      "print",
      "read",
      "open",
      "strip",
      "get",
      "lower",
      "replace",
      "endswith",
      "decode",
      "dumps",
      "raise_for_status",
      "makedirs",
      "join",
      "split",
      "safe_dump",
      "loads",
      "exists",
      "ValueError",
      "handle_cli_error",
      "safe_load"
    ],
    "empirica.cli.command_handlers.skill_commands._save_skill": [
      "open",
      "getcwd",
      "makedirs",
      "join",
      "safe_dump"
    ],
    "empirica.cli.command_handlers.onboard_handler.handle_onboard_command": [
      "EmpericaOnboardingWizard",
      "run",
      "exit",
      "getattr",
      "run_interactive",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.onboard_handler.check_if_onboarded": [
      "list",
      "glob",
      "len",
      "exists",
      "home"
    ],
    "empirica.cli.command_handlers.onboard_handler.get_onboarding_status": [
      "open",
      "glob",
      "str",
      "sorted",
      "len",
      "exists",
      "load",
      "home",
      "get"
    ],
    "empirica.cli.command_handlers.session_commands.handle_sessions_list_command": [
      "getattr",
      "strftime",
      "SessionDatabase",
      "execute",
      "print",
      "fetchall",
      "hasattr",
      "len",
      "format_timestamp",
      "fromtimestamp",
      "fromisoformat",
      "info",
      "append",
      "isinstance",
      "dumps",
      "print_header",
      "cursor",
      "str",
      "close",
      "bool",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.session_commands.handle_sessions_show_command": [
      "abs",
      "warning",
      "str",
      "items",
      "getattr",
      "enumerate",
      "sorted",
      "close",
      "resolve_session_id",
      "isinstance",
      "get_session_summary",
      "SessionDatabase",
      "get",
      "upper",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.session_commands.handle_session_snapshot_command": [
      "abs",
      "dumps",
      "get_session_snapshot",
      "items",
      "sorted",
      "close",
      "len",
      "resolve_session_id",
      "SessionDatabase",
      "get",
      "print"
    ],
    "empirica.cli.command_handlers.session_commands.handle_sessions_export_command": [
      "open",
      "warning",
      "dumps",
      "str",
      "getattr",
      "dump",
      "info",
      "close",
      "len",
      "resolve_session_id",
      "get_session_summary",
      "SessionDatabase",
      "get",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.session_commands.format_timestamp": [
      "str",
      "hasattr",
      "strftime",
      "isinstance",
      "fromtimestamp",
      "fromisoformat"
    ],
    "empirica.cli.command_handlers.utility_commands._get_utility_profile_thresholds": [
      "ProfileLoader",
      "getattr",
      "get_profile"
    ],
    "empirica.cli.command_handlers.utility_commands.handle_goal_analysis_command": [
      "items",
      "getattr",
      "info",
      "_get_utility_profile_thresholds",
      "run_epistemic_cascade",
      "get",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.utility_commands.handle_sessions_list_command": [
      "cursor",
      "fetchall",
      "getattr",
      "strftime",
      "close",
      "len",
      "SessionDatabase",
      "dumps",
      "execute",
      "total_seconds",
      "handle_cli_error",
      "print",
      "print_header",
      "fromisoformat"
    ],
    "empirica.cli.command_handlers.utility_commands.handle_sessions_show_command": [
      "getattr",
      "enumerate",
      "strftime",
      "fetchone",
      "SessionDatabase",
      "execute",
      "total_seconds",
      "print",
      "fetchall",
      "items",
      "len",
      "get",
      "fromisoformat",
      "isinstance",
      "dumps",
      "print_header",
      "cursor",
      "close",
      "loads",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.utility_commands.handle_sessions_export_command": [
      "absolute",
      "getattr",
      "dump",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "fetchall",
      "open",
      "Path",
      "len",
      "stat",
      "lower",
      "append",
      "print_header",
      "cursor",
      "close",
      "loads",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.mistake_commands.handle_mistake_log_command": [
      "hasattr",
      "log_mistake",
      "getattr",
      "close",
      "SessionDatabase",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.mistake_commands.handle_mistake_query_command": [
      "handle_cli_error",
      "hasattr",
      "getattr",
      "enumerate",
      "close",
      "len",
      "SessionDatabase",
      "dumps",
      "get_mistakes",
      "print"
    ],
    "empirica.cli.command_handlers.modality_commands.handle_modality_route_command": [
      "get_usage_stats",
      "warning",
      "input",
      "hasattr",
      "items",
      "route_request",
      "RoutingPreferences",
      "getattr",
      "error",
      "update",
      "info",
      "float",
      "len",
      "execute_with_routing",
      "ModalitySwitcher",
      "handle_cli_error",
      "lower",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.modality_commands.handle_decision_command": [
      "warning",
      "getattr",
      "enumerate",
      "info",
      "run_epistemic_cascade",
      "get",
      "handle_cli_error",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.onboard.handle_onboard_command": [
      "exit",
      "handle_cli_error",
      "getattr",
      "print"
    ],
    "empirica.cli.command_handlers.goal_claim_command.handle_goals_claim_command": [
      "get_by_id",
      "warning",
      "get_branch_mapping",
      "getattr",
      "fetchone",
      "SessionDatabase",
      "handle_preflight_command",
      "execute",
      "print",
      "GoalRepository",
      "update_status",
      "run",
      "get",
      "MockArgs",
      "dumps",
      "add_mapping",
      "BeadsAdapter",
      "str",
      "exit",
      "close",
      "is_available",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.goal_claim_command.__init__": [],
    "empirica.cli.command_handlers.config_commands.handle_config_command": [
      "handle_config_set_command",
      "getattr",
      "handle_config_init_command",
      "handle_config_get_command",
      "handle_config_show_command",
      "handle_config_validate_command"
    ],
    "empirica.cli.command_handlers.config_commands.handle_config_init_command": [
      "to_dict",
      "save_user_config",
      "ConfigLoader",
      "getattr",
      "exists",
      "home",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.config_commands.handle_config_show_command": [
      "dumps",
      "to_dict",
      "getattr",
      "dump",
      "get_config",
      "exists",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.config_commands.handle_config_validate_command": [
      "getenv",
      "items",
      "getattr",
      "Path",
      "get_config",
      "append",
      "get_routing_config",
      "len",
      "exists",
      "expanduser",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.config_commands.handle_config_get_command": [
      "getattr",
      "get_config",
      "get",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.config_commands.handle_config_set_command": [
      "open",
      "save_user_config",
      "safe_load",
      "ConfigLoader",
      "split",
      "getattr",
      "_parse_value",
      "exists",
      "home",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.config_commands._parse_value": [
      "float",
      "lower",
      "int",
      "loads"
    ],
    "empirica.cli.command_handlers.handoff_commands.handle_handoff_create_command": [
      "warning",
      "getattr",
      "SessionDatabase",
      "get_preflight_assessment",
      "print",
      "EpistemicHandoffReportGenerator",
      "hasattr",
      "len",
      "get",
      "generate_planning_handoff",
      "isinstance",
      "dumps",
      "HybridHandoffStorage",
      "get_postflight_assessment",
      "get_check_phase_assessments",
      "generate_handoff_report",
      "loads",
      "store_handoff",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.handoff_commands.handle_handoff_query_command": [
      "hasattr",
      "get",
      "getattr",
      "enumerate",
      "query_handoffs",
      "load_handoff",
      "len",
      "dumps",
      "handle_cli_error",
      "print",
      "HybridHandoffStorage"
    ],
    "empirica.cli.command_handlers.action_commands.handle_investigate_log_command": [
      "getattr",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "run",
      "hasattr",
      "utcnow",
      "len",
      "list",
      "keys",
      "isoformat",
      "append",
      "commit",
      "setdefault",
      "isinstance",
      "dumps",
      "cursor",
      "debug",
      "close",
      "loads",
      "ValueError",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.action_commands.handle_act_log_command": [
      "getattr",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "run",
      "hasattr",
      "utcnow",
      "len",
      "isoformat",
      "append",
      "commit",
      "setdefault",
      "isinstance",
      "dumps",
      "cursor",
      "debug",
      "join",
      "close",
      "loads",
      "ValueError",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.ask_handler.handle_ask_command": [
      "str",
      "uuid4",
      "hasattr",
      "RoutingPreferences",
      "get",
      "exit",
      "getattr",
      "split",
      "strip",
      "SessionDatabase",
      "execute_with_routing",
      "ModalitySwitcher",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.ask_handler._format_response": [],
    "empirica.cli.command_handlers.checkpoint_commands._get_checkpoint_profile_thresholds": [
      "ProfileLoader",
      "getattr",
      "get_profile"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_create_command": [
      "warning",
      "print_exc",
      "hasattr",
      "GitEnhancedReflexLogger",
      "exit",
      "error",
      "info",
      "close",
      "loads",
      "add_checkpoint",
      "len",
      "SessionDatabase",
      "print",
      "get_latest_vectors"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_load_command": [
      "dumps",
      "print_exc",
      "_get_checkpoint_profile_thresholds",
      "hasattr",
      "GitEnhancedReflexLogger",
      "exit",
      "items",
      "getattr",
      "sorted",
      "error",
      "info",
      "print",
      "get",
      "get_last_checkpoint"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_list_command": [
      "print_exc",
      "str",
      "list_checkpoints",
      "hasattr",
      "GitEnhancedReflexLogger",
      "exit",
      "get",
      "getattr",
      "error",
      "enumerate",
      "info",
      "len",
      "dumps",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.handle_checkpoint_diff_command": [
      "dumps",
      "_get_checkpoint_profile_thresholds",
      "print_exc",
      "hasattr",
      "GitEnhancedReflexLogger",
      "items",
      "exit",
      "getattr",
      "get_last_checkpoint",
      "info",
      "show_tier",
      "get",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.handle_efficiency_report_command": [
      "print_exc",
      "hasattr",
      "exit",
      "export_report",
      "TokenEfficiencyMetrics",
      "compare_efficiency",
      "get",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_commands.show_tier": [
      "items",
      "_get_checkpoint_profile_thresholds",
      "print"
    ],
    "empirica.cli.command_handlers.project_search.handle_project_search_command": [
      "init_collections",
      "search",
      "get",
      "getattr",
      "enumerate",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.performance_commands._get_profile_performance_thresholds": [
      "ProfileLoader",
      "getattr",
      "get_profile"
    ],
    "empirica.cli.command_handlers.performance_commands.handle_benchmark_command": [
      "run_benchmark",
      "items",
      "_get_profile_performance_thresholds",
      "format_execution_time",
      "getattr",
      "print",
      "isinstance",
      "get",
      "handle_cli_error",
      "EmpiricalPerformanceAnalyzer",
      "time"
    ],
    "empirica.cli.command_handlers.performance_commands.handle_performance_command": [
      "handle_benchmark_command",
      "analyze_performance",
      "_get_profile_performance_thresholds",
      "items",
      "getattr",
      "get",
      "handle_cli_error",
      "EmpiricalPerformanceAnalyzer",
      "print",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.decision_commands.handle_decision_command": [
      "warning",
      "isatty",
      "RoutingPreferences",
      "route_request",
      "getattr",
      "enumerate",
      "get_available_models",
      "get_default_model",
      "interactive_epistemic_assessment",
      "print",
      "hasattr",
      "items",
      "strip",
      "len",
      "get",
      "ModalitySwitcher",
      "lower",
      "load_epistemic_state_from_file",
      "input",
      "get_credentials_loader",
      "load_epistemic_state_from_flags",
      "sorted",
      "info",
      "isinstance",
      "int",
      "exit",
      "join",
      "execute_with_routing",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.decision_commands.interactive_epistemic_assessment": [
      "input",
      "enumerate",
      "info",
      "float",
      "strip",
      "lower",
      "print"
    ],
    "empirica.cli.command_handlers.decision_commands.load_epistemic_state_from_file": [
      "open",
      "FileNotFoundError",
      "ValueError",
      "load",
      "print"
    ],
    "empirica.cli.command_handlers.decision_commands.load_epistemic_state_from_flags": [
      "hasattr",
      "getattr"
    ],
    "empirica.cli.command_handlers.decision_commands.handle_decision_batch_command": [
      "open",
      "RoutingPreferences",
      "getattr",
      "enumerate",
      "dump",
      "append",
      "replace",
      "len",
      "isinstance",
      "load",
      "execute_with_routing",
      "ModalitySwitcher",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.session_create.handle_session_create_command": [
      "getattr",
      "get_current_subject",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "read",
      "open",
      "hasattr",
      "run",
      "strip",
      "bootstrap_project_breadcrumbs",
      "get",
      "create_session",
      "commit",
      "dumps",
      "cursor",
      "str",
      "exit",
      "join",
      "close",
      "exists",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.chat_handler.render_markdown": [
      "run",
      "strip"
    ],
    "empirica.cli.command_handlers.chat_handler.handle_chat_command": [
      "uuid4",
      "RoutingPreferences",
      "getattr",
      "_load_chat_session",
      "locals",
      "print",
      "open",
      "format_uvl_response",
      "hasattr",
      "mkdir",
      "Path",
      "_handle_chat_command",
      "strip",
      "len",
      "get",
      "ModalitySwitcher",
      "lower",
      "render_markdown",
      "input",
      "format_uvl_stream_message",
      "format_routing_decision",
      "_save_chat_session",
      "append",
      "write",
      "get_agent_emoji",
      "dumps",
      "startswith",
      "str",
      "exit",
      "split",
      "any",
      "execute_with_routing",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.chat_handler._handle_chat_command": [
      "_list_chat_sessions",
      "split",
      "enumerate",
      "len",
      "clear",
      "lower",
      "print"
    ],
    "empirica.cli.command_handlers.chat_handler._save_chat_session": [
      "create_session",
      "open",
      "isoformat",
      "mkdir",
      "dump",
      "Path",
      "utcnow",
      "len",
      "SessionDatabase",
      "print"
    ],
    "empirica.cli.command_handlers.chat_handler._load_chat_session": [
      "open",
      "warning",
      "info",
      "Path",
      "len",
      "exists",
      "load",
      "get",
      "print"
    ],
    "empirica.cli.command_handlers.chat_handler._list_chat_sessions": [
      "list",
      "glob",
      "open",
      "sorted",
      "Path",
      "next",
      "exists",
      "load",
      "stat",
      "get",
      "print"
    ],
    "empirica.cli.command_handlers.project_embed._load_semantic_index": [
      "safe_load",
      "open",
      "join"
    ],
    "empirica.cli.command_handlers.project_embed._read_file": [
      "read",
      "open"
    ],
    "empirica.cli.command_handlers.project_embed.handle_project_embed_command": [
      "getcwd",
      "upsert_memory",
      "getattr",
      "SessionDatabase",
      "execute",
      "print",
      "get_project_unknowns",
      "fetchall",
      "dict",
      "items",
      "len",
      "upsert_docs",
      "get",
      "_read_file",
      "init_collections",
      "append",
      "dumps",
      "cursor",
      "startswith",
      "join",
      "split",
      "close",
      "get_project_findings",
      "handle_cli_error",
      "_load_semantic_index"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_create_command": [
      "create",
      "to_dict",
      "warning",
      "uuid4",
      "getattr",
      "enumerate",
      "create_issue",
      "float",
      "SessionDatabase",
      "execute",
      "save_goal",
      "print",
      "read",
      "GoalRepository",
      "ScopeVector",
      "open",
      "hasattr",
      "GitGoalStore",
      "len",
      "strip",
      "get",
      "SuccessCriterion",
      "info",
      "append",
      "commit",
      "isinstance",
      "dumps",
      "BeadsAdapter",
      "startswith",
      "store_goal",
      "str",
      "exit",
      "debug",
      "close",
      "is_available",
      "exists",
      "bool",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_add_subtask_command": [
      "create",
      "warning",
      "getattr",
      "create_issue",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "hasattr",
      "save_subtask",
      "TaskRepository",
      "upper",
      "get",
      "add_dependency",
      "info",
      "commit",
      "dumps",
      "BeadsAdapter",
      "close",
      "is_available",
      "handle_cli_error",
      "parse_json_safely"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_complete_subtask_command": [
      "hasattr",
      "time",
      "getattr",
      "close",
      "update_subtask_status",
      "TaskRepository",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_progress_command": [
      "GoalRepository",
      "dumps",
      "hasattr",
      "get_goal_subtasks",
      "time",
      "getattr",
      "close",
      "TaskRepository",
      "len",
      "get",
      "get_goal",
      "handle_cli_error",
      "print",
      "sum"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_list_command": [
      "to_dict",
      "getattr",
      "enumerate",
      "print",
      "title",
      "GoalRepository",
      "hasattr",
      "get_goal_subtasks",
      "items",
      "TaskRepository",
      "len",
      "get_session_goals",
      "append",
      "replace",
      "dumps",
      "time",
      "sum",
      "join",
      "close",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_goals_get_subtasks_command": [
      "dumps",
      "hasattr",
      "get_goal_subtasks",
      "time",
      "enumerate",
      "getattr",
      "close",
      "append",
      "TaskRepository",
      "len",
      "get",
      "handle_cli_error",
      "print",
      "sum"
    ],
    "empirica.cli.command_handlers.goal_commands.handle_sessions_resume_command": [
      "cursor",
      "fetchall",
      "str",
      "dict",
      "hasattr",
      "getattr",
      "enumerate",
      "close",
      "append",
      "print",
      "len",
      "fetchone",
      "SessionDatabase",
      "dumps",
      "execute",
      "handle_cli_error",
      "time"
    ],
    "empirica.cli.command_handlers.goal_complete_command.handle_goals_complete_command": [
      "get_by_id",
      "close_issue",
      "warning",
      "get_branch_mapping",
      "getattr",
      "fetchone",
      "SessionDatabase",
      "execute",
      "print",
      "GoalRepository",
      "run",
      "handle_postflight_command",
      "strip",
      "get",
      "get_branch_for_goal",
      "MockArgs",
      "dumps",
      "BeadsAdapter",
      "str",
      "exit",
      "handle_handoff_create_command",
      "close",
      "is_available",
      "remove_mapping",
      "handle_cli_error"
    ],
    "empirica.cli.command_handlers.goal_complete_command.__init__": [],
    "empirica.cli.command_handlers.doc_commands.handle_doc_check_command": [
      "getattr",
      "enumerate",
      "compute_doc_plan",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.doc_commands.handle_doc_plan_suggest_command": [
      "getattr",
      "print",
      "compute_doc_plan",
      "handle_cli_error",
      "dumps"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_start_command": [
      "Popen",
      "open",
      "sleep",
      "str",
      "_get_mcp_pid",
      "mkdir",
      "getattr",
      "write",
      "_is_mcp_running",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_stop_command": [
      "unlink",
      "sleep",
      "_get_mcp_pid",
      "getattr",
      "kill",
      "_is_mcp_running",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_status_command": [
      "localtime",
      "cpu_percent",
      "_get_mcp_pid",
      "getattr",
      "strftime",
      "create_time",
      "Process",
      "num_threads",
      "memory_info",
      "get",
      "_is_mcp_running",
      "handle_cli_error",
      "lower",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_test_command": [
      "str",
      "run",
      "getattr",
      "_is_mcp_running",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_list_tools_command": [
      "getattr",
      "print",
      "len",
      "get",
      "handle_cli_error",
      "lower",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands.handle_mcp_call_command": [
      "getattr",
      "loads",
      "dumps",
      "handle_cli_error",
      "print",
      "print_header"
    ],
    "empirica.cli.command_handlers.mcp_commands._is_mcp_running": [
      "unlink",
      "_get_mcp_pid",
      "exists",
      "kill"
    ],
    "empirica.cli.command_handlers.mcp_commands._get_mcp_pid": [
      "read",
      "strip",
      "open",
      "int"
    ],
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_sign_command": [
      "CheckpointSigner",
      "exit",
      "get",
      "getattr",
      "sign_checkpoint",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_verify_command": [
      "exit",
      "verify_checkpoint",
      "public_key_hex",
      "get",
      "getattr",
      "load_keypair",
      "cwd",
      "VerificationSigner",
      "dumps",
      "AIIdentity",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_signing_commands.handle_checkpoint_signatures_command": [
      "list_signed_checkpoints",
      "exit",
      "getattr",
      "enumerate",
      "cwd",
      "len",
      "ListSigner",
      "dumps",
      "handle_cli_error",
      "print"
    ],
    "empirica.cli.command_handlers.checkpoint_signing_commands.__init__": [
      "cwd"
    ],
    "empirica.cli.command_handlers.decision_utils.load_feedback_loops_config": [
      "open",
      "warning",
      "join",
      "dirname",
      "safe_load"
    ],
    "empirica.cli.command_handlers.decision_utils.get_agent_feedback_loop_config": [
      "get",
      "load_feedback_loops_config"
    ],
    "empirica.cli.command_handlers.decision_utils.evaluate_cognitive_load": [
      "get",
      "get_agent_feedback_loop_config"
    ],
    "empirica.cli.command_handlers.decision_utils.get_cognitive_load_decision_impact": [
      "evaluate_cognitive_load"
    ],
    "empirica.cli.command_handlers.decision_utils.calculate_decision": [],
    "empirica.cli.command_handlers.decision_utils.get_recommendation_from_vectors": [
      "get",
      "append"
    ],
    "empirica.components.edit_verification.confidence_assessor.__init__": [],
    "empirica.components.edit_verification.confidence_assessor.assess": [
      "_assess_truncation_risk",
      "_assess_match_uniqueness",
      "_assess_whitespace_confidence",
      "_assess_context_freshness"
    ],
    "empirica.components.edit_verification.confidence_assessor.recommend_strategy": [
      "_context_age_description"
    ],
    "empirica.components.edit_verification.confidence_assessor._assess_context_freshness": [],
    "empirica.components.edit_verification.confidence_assessor._assess_whitespace_confidence": [],
    "empirica.components.edit_verification.confidence_assessor._assess_match_uniqueness": [
      "read",
      "count",
      "open"
    ],
    "empirica.components.edit_verification.confidence_assessor._assess_truncation_risk": [
      "len",
      "split",
      "max"
    ],
    "empirica.components.edit_verification.confidence_assessor._context_age_description": [],
    "empirica.components.edit_verification.strategy_executor.__init__": [],
    "empirica.components.edit_verification.strategy_executor._make_flexible_pattern": [
      "escape",
      "replace"
    ]
  }
}